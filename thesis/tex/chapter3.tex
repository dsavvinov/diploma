\section{Глава 3}

\subsection{Извлечение информации из схем эффектов}

\subsubsection{Два направления вывода информации}

По итогам прошлой главы, мы научились получать схему эффектов для произвольного вызова (при условии, конечно, что все участвующие в нем функции аннотированы схемами). Теперь мы хотели бы научиться извлекать из полученных схем полезную информацию.

В целом, мы можем попытаться извлечь информацию из схемы с помощью двух различных подходов:

\begin{itemize}
    \item Зная некоторую информацию о контексте исполнения, попытаться понять, какие посылки исполняются и какие эффекты может иметь вычисление. Мы будем называть этот подход \term{прямым направлением вывода}, т.к. он сонаправлен с потоком вычислений в программе.
    
    \item Зная, что подпрограмма сгенерировала некоторые эффекты, попытаться понять, какой вид имел контекст исполнения. Мы будем называть этот подход \term{обратным направлением вывода}, т.к. он противонаправлен потоку вычислений в программе.
    
\end{itemize}

Рассмотрим для примера следующую схему:

\schema{assertIsNull(x)}
{
    \es{x == null} $\rightarrow$ \es{Returns(Unit)} \\
    \es{x != null} $\rightarrow$ \es{Throws AssertionError}
}{}

Тогда мы можем извлечь некоторую пользу из этой схемы двумя способами, соответствующими описанным выше подходами:

\begin{itemize}
    \item Понять, что пользователь передает в эту функцию переменную, которая гарантированно не является \code{null}, и предупредить о том, что это действие наверняка вызовет исключение. Как следствие, весь последующий код в данном блоке является недостижимым, о чем также можно сообщить, если это поддерживается инструментами разработки:
    
    \begin{minted}{kotlin}
        ...
        assertIsNull("Constant string can not be null")
        println("This statement is unreachable!")
        ...
    \end{minted}
    
    \item Мы можем зайти и с другого конца. Можно посмотреть на следующее после вызова выражение и понять, что вычисление может дойти до него только если исключение не было сгенерировано, т.е. если аргумент, переданный в \code{assertIsNull}, не является \code{null}
    
    \begin{minted}{kotlin}
        val s: String?
        ... <initialize s> ...
        
        assertIsNull(s)
        println(s.length)	// here we can be sure that 's != null'
    \end{minted}
    
    Также как и в предыдущем примере, для того, чтобы конечный пользователь ощутил реальную пользу от этого анализа, необходимо, чтобы инструмент поддерживал некоторый механизм, для которого такая информация была бы полезна. Для этого подхода отлично подходит механизм умных приведений типа в \lang{Kotlin} -- с его помощью мы можем автоматически уточнить тип переменной \code{s} из последнего примера.
\end{itemize}

Алгоритм для прямого вывода достаточно прост и интуитивен -- нужно просто вычислить все операторы в данном контексте, и затем аккуратно собрать эффекты. Некоторые нетривиальности могут возникнуть при обработке посылок, которые оказались вычисленными не до конца, т.е. когда имеющейся в распоряжении информации о контексте не хватает для того, чтобы сделать вывод о том, верна эта посылка или же нет. Однако в таком случае сложно предложить какой-то общий подход к разрешению подобных ситуаций, поскольку это тесно связано с понятием консервативного приближения, и, как следствие, конкретного типа анализа.

В связи с этим, мы не будем заострять внимание на прямом выводе, и подробно рассмотрим алгоритм обратного вывода ниже.


\subsubsection{Алгоритм обратного вывода}

Алгоритм обратного вывода состоит из нескольких подчастей:

\begin{enumerate}
    \item Операция \term{фильтрации}, который оставляет в схеме только интересные нам выражения. Например, если мы хотим узнать вид контекста при условии, что функция успешно завершилась, то этому алгоритму будет передано выражение \code{Returns ???}, и он вернет только те утверждения, которые имеют в заключении эффект \code{Returns}. 
    
    \item Операция \term{слияния}, который принимает на вход набор утверждений, полученных после фильтрации, и объединяет информацию, заложенную в этих утверждениях. 
\end{enumerate}

Начнем с алгоритма фильтрации. Для того, чтобы понять, как он устроен, опишем более формально то, что он должен делать:

\begin{definition}
    Пусть дано выражение $q$ и утверждение $s$. Будем говорить, что $q$ \term{влечет} $s$ ($s$ \term{следует из} $q$), если информации о том, что были сгенерированы эффекты из заключения $s$ достаточно для того, чтобы сделать вывод, что был имел место эффект $q$. Далее мы будем говорить, что $s_{effects}$ влечет $q$ ($q$ следует из $s_{effects}$)
\end{definition}

Поясним это примером. Рассмотрим схему:

\schema{A}
{
    \es{x is String} $\rightarrow$ \es{Returns true} \\
    \es{y != null} $\rightarrow$ \es{Calls(f, 1)} \\
}{}

Рассмотрим первое утверждение из схемы. Оно, очевидно, следует из выражения \code{Returns true}. Но что более интересно, оно следует также и из выражения \code{Returns ???} -- действительно, если заключение утверждения верно (т.е. функция вернула \code{true}), то, конечно, верно, что функция завершилась (т.е. буквально \code{Returns ???})



Теперь, вооружившись отношением <<влечет>> и дуальным к нему <<следует>>, мы можем описать суть алгоритма фильтрации:

\begin{definition}
    Операция фильтрации схемы $S$ по выражению $q$ $Filter(S, q)$ выдает схему $S'$ состоящую только из таких утверждений $S$, которые следуют из $q$.
\end{definition}


\bigskip

Перейдем теперь к операции слияния. Будем считать, что нам дана некоторая схема, и необходимо собрать информацию, заложенную в ее утверждениях. 

Рассмотрим все ту же схему $A$:

\schema{A}
{
    \es{x is String} $\rightarrow$ \es{Returns true} \\
    \es{y != null} $\rightarrow$ \es{Calls(f, 1)} \\
}{}

Данный алгоритм должен на выходе выдать информацию, сообщающую, что:
    
\begin{itemize}
    \item \code{x} является подтипом \code{String}
    \item \code{y} не является \code{null}
    \item Подпрограмма \code{A} возвращает \code{true}
    \item Подпрограмма \code{A} в ходе своего выполнения вызывает функцию \code{f} ровно один раз.
\end{itemize}
    
Отметим, что поскольку операция слияния выполняется в качестве части алгоритма вывода, то некоторая информация уже известна анализатору -- либо информация про контекст (при прямом выводе), либо информация про сгенерированные эффекты (при обратном выводе). Разумеется, анализатору наличие этой информации никак не помешает, поэтому мы не будем пытаться как-то ее отфильтровать.

Основной проблемой при решении задачи слияния является то, что нужно очень аккуратно различать выражения, которые \emph{выполняются все одновременно}, от наборов выражений, в котором \emph{выполняется по меньшей мере одно}. 