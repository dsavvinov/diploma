\section{Глава 2}

В этой главе мы рассмотрим теоретические вопросы устройства систем условных эффектов, т.е. дадим описание, максимально абстрагированное от используемого языка программирования. Структура данной главы следующая:

\begin{enumerate}
    \item Базовые понятия -- условный эффект, схема эффектов и т.д.
    
    \item Принципы комбинирования схем эффектов для вложенных вызовов и некоторые нюансы, появляющиеся при работе с частичными вычислениями.
    
    \item Уменьшение размера схем эффектов. Редукция и аппроксимация -- два подхода к уменьшению размера схем эффектов, с потерей информации и без потери соответственно.
    
    \item Более сложные эффекты на примере уточнений типов в коллекциях.
\end{enumerate}

\subsection{Основные понятия}

\subsubsection{Выбор базового метода}
По итогам прошлой главы мы видели, что для решения проблемы межпроцедурного анализа с точки зрения практики лучше всего подходят контракты и системы эффекты. Также, при анализе этих подходов было замечено, что они довольно похожи друг на друга, и при выборе между ними следует руководствоваться свойствами и требованиями предметной области. Напомним кратко, в чем их основное отличие:

\begin{itemize}
    \item Контракты хорошо подходят, когда в предметной области часто используется концепция предусловий-постусловий --  например, когда требуется формализовать выражения-утверждения типа <<\code{assert(<some condition>)}>>

    \item Системы эффектов лучше выражают утверждения о наличии либо отсутствии некоторых четко определенных и кратко описываемых свойств функции, т.е. утверждения, эквивалентные конструкциям вроде \code{throws(Exception)}, \code{const} и т.д.

\end{itemize}

Если взглянуть в качестве примера предметной области на \lang{Kotlin} и некоторые проблемы, подробно описанные в предыдущей главе, то становится понятно, что хотя иногда нам и хотелось бы формализовать выражения-утверждения, но в целом концепция предусловий/постусловий не является необходимой. Поэтому было принято решение использовать в качестве основного подхода систему эффектов.

Хотелось бы сразу заметить, что хотя мы постарались дать мотивацию данному решению, оно не является безоговорочно верным. Выбор системы эффектов накладывает некоторые специфические ограничения, которые будет подробно обсуждаться в главе 4. 



\subsubsection{Понятие условного эффекта}

Центральным определением в данной работе, является, разумеется, \term{эффект}. Однако несмотря на то, что это определение, судя по всему, было введено еще на заре развития программирования (так, ранние работы по аксиоматизации программирования уже ссылаются на этот термин без отдельного его введения \cite{Hoare69, Schwartz67}), общепринятой формулировки за все это время не появилось. 

В классических источниках, под эффектом чаще всего понимают <<некоторое видимое изменение в окружении>> \cite{Luc88}, или даже еще более конкретно <<изменение в памяти программы>> \cite{Vak09}. Некоторые исследователи и вовсе ограничивают это определение до <<чтения или записи в изменяемое состояние программы>> \cite{Green99}. Это можно резюмировать следующим образом:

\begin{definition}
    \label{def-effect-1}
    \term{Эффектом} называется некоторое изменение, производимое подпрограммой в состоянии вычислителя (кроме возвращения подпрограммой значения).
\end{definition}

Другие же авторы употребляют более широкую трактовку <<эффекта>> \cite{Nielson99}: 

\begin{definition}
    \label{def-effect-2}
    \term{Эффектом} является описание действий, происходящих в ходе выполнения подпрограммы.
\end{definition}

Разумеется, формулировка \ref{def-effect-2} является слишком широкой -- вплоть до того, что под нее подходит непосредственно исходный код тела функции. С другой же стороны, формулировка \ref{def-effect-1} является нежелательно узкой в контексте данной работы. Поясним это на примере. 

Рассмотрим следующую функцию, которая является тривиальной оберткой над проверкой переменной на принадлежность строковому типу:

\begin{minted}{kotlin}
fun isString(x: Any?): Boolean {
return (x is String)
}
\end{minted}

И рассмотрим следующий участок кода:

\begin{minted}{kotlin}
if (isString(t)) {
...
}
\end{minted}

Мы хотели бы сказать, что в истинной ветке условного оператора мы наблюдаем тот эффект, что <<\code{isString} вернула значение \code{true}>>. Однако это действие не подходит под определение эффекта \ref{def-effect-1}. Мы могли бы отказаться от специального случая для возвращаемых значений в этой формулировке, но в дальнейшем мы встретим некоторые утверждения, которые мы тоже хотели бы называть эффектами, но которые не описывают вообще никакого изменения в состоянии вычислителя.

Поэтому нам понадобится определение, чуть более слабое, чем определение \ref{def-effect-1}, но при этом не являющееся чересчур расплывчатым, как \ref{def-effect-2}. Мы сформулируем его следующим образом:

\begin{definition}
    \label{def-effect}
    \term{Эффект} -- это некоторая информация об окружении, получаемая при выполнении подпрограммы.
\end{definition}

Т.к. это определение рассматривает только окружение, то сразу отпадают все слишком широкие его интерпретации. В частности, все, что подпрограмма делает со своими локальными переменными, не подходит под это определение -- что очень удобно, т.к. изменения в локальных переменных нас никоим образом не интересуют.

С другой стороны, это определение включает в себя определение \ref{def-effect-1}, т.к. <<изменение в состоянии>>, несомненно, является <<информацией об окружении>>.

Наконец, как мы увидим чуть позже, под это определение подходят и довольно нестандартные действия, которые нам будет удобно считать эффектами во имя общности подхода.

\bigskip

Теперь, когда мы четко проговорили нюансы понятия <<эффект>>, нам хотелось бы расширить его, формализовав понятие, интуитивно соответствующее тому, что мы раньше называли условным эффектом:

\begin{definition}
    \label{def-cond-effect}
    \term{Утверждением} будем называть пару $(c, e)$, где $e$ -- набор эффектов, а $c$ -- некоторый набор условий. Семантика этой пары такова, что эффект $e$ имеет место тогда, когда $c$ выполняется.  
    
    В дальнейшем мы будем иногда называть условие $c$ \term{посылкой}, а эффекты $e$ -- \term{заключением}, и записывать эту пару следующим образом: $c \to e$.
   
\end{definition}

Во-первых, обратим внимание, что выполнение условий $c$ влечет эффект $e$, однако \emph{невыполнение условий не гарантирует отсутствие эффекта}. Этот нюанс важен для сохранения консервативности некоторых видов анализа, о которых мы будем говорить далее.

Во-вторых, синтаксис записи вида $c \to e$ намеренно выбран похожим на синтаксис оператора импликации мат.логики, и приблизительно из таких же соображений выбраны названия для всех используемых понятий. Мы не хотели бы слишком вдаваться в формальные детали и описывать интерпретацию математической логики в контексте эффектов, но надеемся, что читатель, знакомый с ее базовыми концепциями, получит интуицию, полезную для дальнейшего понимания.



\subsubsection{Понятие схемы эффектов}


Итак, у нас есть понятие <<утверждение>>, описывающее условный эффект. Однако этого еще недостаточно для наших целей. Достаточно взглянуть даже на очень простой пример с функцией \code{isString(x)}, выдающей результат проверки аргумента на принадлежность строковому типу, чтобы понять, что утверждения часто используются в группах. Так, чтобы описать поведение функции \code{isString(x)}, необходимо два утверждения:

\begin{itemize}
    \item Если \code{x is String} верно, то функция возвращает \code{true}
    
    \item Если \code{x is String} неверно, то функция возвращает \code{false}
\end{itemize}

Поэтому в рамках данной работы было введено понятие \term{схемы эффектов}, формализующее данную идею:

\begin{definition}
    \term{Схемой эффектов} называется набор \emph{независимых} утверждений, описывающих условные эффекты некоторого участка кода.
\end{definition}

Обратим внимание, что определение говорит, о \emph{независимости} утверждений в схеме, т.е. исполнение или неисполнение некоторого конкретного утверждения не влияет на другие. Разницу проще всего продемонстрировать наглядно с отрывками соответствующего псевдокода:

\bigskip

\setlength{\tabcolsep}{12pt}
\begin{tabular}{p{0.5\linewidth} | p{0.5\linewidth}}
    
    Зависимые утверждения & Независимые утверждения \\\hline
    
    \begin{minted}[frame=none]{kotlin}
        ...
        if (#$c_i$#) {
            <throw some exception>
        } 
        else if (#$c_{i + 1}$#) {
            #$e_{i + 1}$#
        } 
        ...
       
    \end{minted}
    
    Если выполняется $c_i$, то никакие последующие эффекты не могут иметь место, в частности, $e_{i + 1}$ (даже если выполняется ${c_{i + 1}}$).
    
    &
      
    \begin{minted}[frame=none, xleftmargin=1em]{kotlin}
        ...
        if (#$c_i$#) {
            <throw some exception>
        } 
        if (#$c_{i + 1}$#) {
            #$e_{i + 1}$#
        } 
        ... 
    \end{minted}
    
    Даже если $c_i$ верно, это никак не мешает исполниться $e_{i + 1}$.
\end{tabular}
\setlength{\tabcolsep}{6pt} 

Оба представления эквивалентны в том смысле, что любой набор независимых утверждений можно выразить через зависимые, и наоборот. Однако если задаться вопросом суммарной длины всех утверждений, то можно показать, что в общем случае переход от зависимых к независимым влечет квадратичное увеличение, а вот обратный -- экспоненциальное. 

Кроме того, практика показывает, что алгоритмы, работающие с утверждениями, записываются более кратко и ясно для независимого представления, что явилось решающим фактором для выбора между этими двумя представлениями. 

Важно понимать, что при независимом представлении может быть верным буквально \emph{любое} подмножество утверждений, в том числе и пустое.




\subsubsection{Краткая грамматика языка описания эффектов}

Теперь, определившись с основными понятиями, мы можем ввести грамматику для записи схем эффектов и утверждений. 
Для описания здесь будет использоваться синтаксис, близкий к EBNF (расширенной нормальной форме Бэкуса-Науэра). Мы будем придерживаться следующих соглашений:

\begin{itemize}
    \item Терминалы начинаются с большой буквы, например: \code{ПростойТерминал}
    
    \item Нетерминалы начинаются с маленькой буквы: \code{нетерминальныйСимвол}
    
    \item Каждая продукция начинается с двоеточия <<$\colon$>> и заканчивается точкой с запятой <<;>>
    
    \item Операторы <<|>>, <<*>>, <<+>>, <<?>> несут стандартный смысл альтернативы, итерации (ноль или более), итерации (один или более) или опции (один или менее) соответственно.
    
    \item Кроме того, мы будем писать $\alpha \{ \beta \}$, чтобы обозначить непустой список из символов $\alpha$, разделенных символом $\beta$. 
\end{itemize}

Мы приводим здесь неформальную грамматику, опуская технические детали вроде леворекурсивных правил, точных определений литералов, приоритетов и т.д.  Полная грамматика в синтаксисе \lang{ANTLR} приведена в приложении \ref{appendix-es-grammar}.

\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}

\begin{minted}{antlr}

    effectSchema : statement{ ';' } ;
    
    statement : expression '->' effect{ ',' } ;
    
    expression : operator | Constant | Variable ;
    
    operator : isOperator | andOperator | orOperator | equalOperator ;
    
    effect : returnsEffect | throwsEffect | callsEffect ;
      
    // Операторы
    isOperator     : Variable 'is' Type ;
    andOperator    : expression '\&\&' expression ;
    orOperator     : expression '||' expression ;
    equalOperator  : expression '==' expression ;
    
    // Эффекты
    returnsEffect : 'Returns' '(' (expression | Wildcard)  ')' ;
    throwsEffect  : 'Throws'  '(' (Type       | Wildcard)  ')' ;
    callsEffect   : 'Calls'   '(' (Variable   | Wildcard) ',' Constant ')' ;
    
    // Терминалы
    Constant : <численная либо строковая константа> ; 
    Variable : <корректный идентификатор> ;        
    Type     : <корректный идентификатор> ;
    Wildcard : '???' ;
    
\end{minted}

Семантика операторов:

\begin{itemize}
    \item \code{Is-оператор} -- выдает результат проверки переменной на принадлежность типу, подробнее см. в \cite{kotlin:typechecks}.
    
    \item \code{And-оператор} -- соответствует логической конъюнкции.
    
    \item \code{Or-оператор} -- соответствует логической дизъюнкции.
    
    \item \code{Equal-оператор} -- соответствует проверке на равенство (equality) в \lang{Kotlin}, подробнее см. в \cite{kotlin:equality}.
\end{itemize}

Семантика эффектов:

\begin{itemize}
    \item \code{Returns(x)} говорит, что данный участок кода при исполнении возвращает значение \code{x}.
    
    \item \code{Throws(e)} говорит, что в результате исполнения данного участка кода генерируется исключение \code{e}.
    
    \item \code{Calls(f, c)} говорит, что в результате исполнения данного участка кода \code{c} раз будет вызвана функция \code{f}.
\end{itemize}

Кроме того, нам понадобилось ввести особый символ подстановки <<???>>, означающий неизвестность. Он необходим для того, чтобы можно было записать утверждения вроде: \code{Returns ???} (<<участок кода завершается успешно, но конкретное возвращаемое значение неизвестно>>), или \code{Throws ???} (<<участок кода завершается неуспешно>>). Особенно большое значение наличие таких конструкций будет иметь при извлечении полезной информации из системы эффектов, о чем мы будем говорить в главе 3.

Заметим, что приведенная выше грамматика естественным образом индуцирует дерево, которое мы будем называть \term{деревом схемы эффектов}, или просто \term{дерево схемы}. Фактически, если рассматривать схему как некоторое выражение в грамматике, определенной выше, то дерево этой схемы соответствует дереву разбора этого выражения, из которого удалены все узлы-литералы (такие как разделители, скобки и т.д.). 

\subsubsection{Консервативные приближения и схемы эффектов}

В области статического анализа широко известно понятие <<консервативного приближения>>. Его суть заключается в следующем. 

Задачей статического анализа является получение некоторой информации о динамическом поведении программы до непосредственного исполнения. При этом, зачастую, получить стопроцентно точную информацию или очень сложно, или вовсе невозможно. Поэтому обычно речь идет лишь о получении некоторого <<приближения>> реального поведения программы. 

Однако термин <<приближение>> сам по себе недостаточно выразителен. Например, какая-нибудь ветка условного выражения может быть ложной в $99.999999\%$ случаев. В зависимости от целей, код, который не содержит этой ветки вообще, может быть и отличным приближением (например, для профилирования программы), а может быть и ужасным. Последнее в основном верно для систем, которые изменяют код без прямого участия пользователя -- например, если такой код получился в результате работы оптимизатора перед компиляцией, то это катастрофическая ошибка, поскольку эти две программы в том самом одном случае из десяти миллионов \emph{работают по-разному}. 

Поэтому нам понадобится более сильный термин, а именно, \term{консервативное приближение}.

\begin{definition}
    Мы будем называть преобразование кода \term{консервативным}, если оно не изменяет внешнего поведения программы. Информация, использование которой допускает только консервативные преобразования кода, мы будем называть \term{консервативной} или иногда \term{консерватным приближением} (динамического поведения программы)
\end{definition}

Например, в \code{Java} консервативным преобразованием является удаление \code{else}-ветки выражения вида \code{if (true) \{ ... \} else \{ ... \} } -- действительно, управление никогда не могло попасть в эту ветку, поэтому внешнее поведение измениться при таком преобразовании не могло.

Интуитивно, консервативные приближения могут ошибаться только <<в одну сторону>>, и не могут быть использованы для того, чтобы оправдать преобразование кода, потенциально <<ломающее>> программу. 

Для того, чтобы схемы эффектов можно было использовать на практике, необходимо, чтобы они являлись консервативным приближением описания всех возможных эффектов соответствующего участка кода. Для этого мы не будем требовать, чтобы утверждения схемы \emph{полностью} специфицировали поведение подпрограммы. Другими словами, мы будем по умолчанию полагать, что возможны корректные исполнения, когда ни одна из посылок неверна -- при этом подразумевается, что мы ничего не знаем про эффекты соответствующей подпрограммы. 

Для примера рассмотрим следующую игрушечную функцию:

\begin{minted}{kotlin}
    fun A(x: Int?, y: Int, z: Int): Int {
        if (x == null) throw IllegalArgumentException()
        return (x + y) / z
    }
\end{minted}

Следующая схема является корректным консервативным приближением динамического поведения этой функции:

\schema{A(x, y, z)}{
    \es{x == null} $\rightarrow$ \es{Throws InvalidArgumentException}
}{}

Эта схема действительно описывает часть поведения функции: если первый аргумент \code{null}, то исполнение аварийно завершается с исключением. Однако если это не так, то эта схема говорит, что о функции ничего не известно. В частности, обратите внимание, что в схеме отсутствует утверждение, описывающее тот факт, что функция также аварийно завершается с ошибкой целочисленного деления на ноль в том случае, если \code{z == 0}.

Однако мы не можем слишком сильно ослаблять требования на полноту спецификации. Например, доводя этот принцип до крайности, можно было бы сказать, что и каждое утверждение не является полной спецификацией. Однако это ведет к получению довольно бесполезной и неудобной системы -- действительно, в этой системе, например, нельзя будет выразить утверждение, что функция при исполнении вызывает другую \emph{ровно} один раз. Запись \code{Calls(f, 1)} будет означать, что \code{f} вызывается \emph{по меньшей мере} один раз, т.к. в силу неполноты спецификации, анализатор вынужден считать, что функция может делать еще какие-то дополнительные вызовы \code{f}.




\subsubsection{Изоморфизм схем}

В будущем мы будем определять некоторые трансформации над схемами эффектов. Большинство этих трансформаций в каком-то смысле будут изменять лишь структуру схему, оставляя заложенную в нее информацию неизменной. Опять же, мы могли бы дать полностью формальное определение этому понятию, но это потребовало бы непропорционально больших усилий, поэтому ограничимся интуитивным:

\begin{definition}
    Будем говорить, что схемы $A$ и $B$ являются \term{изоморфными}, если они описывают один и тот же набор условных эффектов. Трансформацию, которая переводит схему $A$ в схему $B$ будем называть \term{изоморфизмом схем}.
\end{definition}

Интуитивно, мы можем спокойно заменить схему изоморфной, и это никак не повлияет на результаты анализа кода, полученные с помощью этой схемы. Например, следующие две схемы являются изоморфными, хотя с чисто синтаксической точки зрения в них записаны разные утверждения:

\schema{A}
{
    \es{x == true && y is Int}   $\rightarrow$ \es{Returns 1} \\
    \es{x == false || y !is Int} $\rightarrow$ \es{Returns 0} \\
}{}

\bigskip

\schema{B}
{
    \es{!(x == false || y !is Int)} $\rightarrow$ \es{Returns 1} \\
    \es{!(x == true && y is Int)}   $\rightarrow$ \es{Returns 0}
}
{}



\subsubsection{Примеры}

Теперь мы ввели все необходимые понятия для того, чтобы научиться аннотировать некоторые функции с не слишком сложными контрактами (в частности, обсуждение уточнений типов в коллекциях мы на некоторое время отложим). В данном разделе мы приведем несколько примеров для того, чтобы наглядно продемонстрировать работу с описанным синтаксисом и терминами.

Начнем с рассмотрения уже использовавшейся нами не раз функции \code{isString(x)}:

\begin{minted}{kotlin}
    fun isString(x: Any?): Boolean {
        return (x is String)
    }
\end{minted}

Ей соответствует следующая схема:

\begin{minted}{text}
    schema isString {
        x is String  -> Returns true
        x !is String -> Returns false
    }
\end{minted}

Как мы видим, эта схема в точности передает контракт \code{isString(x)}: функция возвращает \code{true} если переданный аргумент является подтипом \code{String} и возвращает \code{false} в противном случае. 

Заметим, что в силу того, что мы используем независимые утверждения, схема эффектов не отражает явным образом тот факт, что эти два утверждения описывают \emph{все} возможные результаты выполнения данной функции. Неявно это выражено тем, что для любого объекта \code{x} верно либо \code{x is String}, либо \code{x !is String}. 


\bigskip


Другой пример, который мы хотели бы выразить в системе эффектов, это функция \code{assert}. Мы уже упоминали это соглашение, и здесь мы повторим его: мы будем считать, что \code{assert} всегда генерирует исключение, если переданный аргумент равен \code{false}. На практике это не верно (в частности, для языка \lang{Kotlin}), т.к. поведение \code{assert} может регулироваться флагами окружения. 

\begin{minted}{kotlin}
    fun assert(cond: Boolean): Unit {
        if (!cond) {
            throw AssertionError("Assertion Failed")
        }
    }
\end{minted}

Этой функции соответствует следующая схема:

\begin{minted}{text}
    schema assert {
        cond == true  -> Returns Unit
        cond == false -> Throws AssertionError
    }
\end{minted}

Эта запись отражает контракт функции \code{assert}: она завершается успешно тогда и только тогда, когда аргумент равен \code{true}. Опять же, факт того, что описание в схеме исчерпывающее, выражен неявно -- булева переменная либо истинна, либо ложна.


\bigskip


Наконец, рассмотрим функции типа \code{run}, которые в ходе своей работы вызывают некоторую другую детерминированное число раз:

\begin{minted}{kotlin}
    fun run(block: () -> Unit): Unit {
        block()
    }
\end{minted}

Этой функции соответствует схема:

\begin{minted}{text}
    schema run {
        true -> Calls(block, 1)
    }
\end{minted}

Данная запись отражает то, что функция \code{run} \emph{всегда} (посылка \code{true} всегда истинна) вызывает переданный аргумент \code{block} ровно один раз.

Отметим, что в данном случае схема специфицирует лишь \emph{часть} контракта функции. В частности, она не отражает тот факт, что функция завершается успешно тогда и только тогда, когда успешно завершается вызов \code{block()}.








\subsection{Использование схем эффектов}

\subsubsection{Подстановка аргументов}

Мы научились описывать базовые схемы эффектов для функции. При этом мы не заостряли внимание на том, что все эти схемы используют \emph{параметры} функции. С точки зрения формализма, эти схемы не имеют смысла при вызове функции с конкретными аргументами. Действительно, пусть у нас есть схема для все той же функции \code{isString}:

\begin{minted}{text}
    schema isString {
        x is String  -> Returns true
        x !is String -> Returns false
    }
\end{minted}

И пусть мы вызываем эту функцию в коде:

\begin{minted}{kotlin}
    val someValue: Any?
    <initialize x somehow>
    
    if (isString(someValue)) {
        println("someValue is String!")
    }
\end{minted}

Чисто формально, в строке 5 мы хотели бы получить схему, в которой используется \code{someValue}, а не \code{x}:

\begin{minted}{text}
    schema isString(someValue) {
        someValue is String  -> Returns true
        someValue !is String -> Returns false
    }
\end{minted}

Т.е. мы должны некоторым образом связать формальные параметры (в данном случае \code{x}) и аргументы, использованные при вызове (в данном случае \code{someValue}). Это довольно известный процесс \term{подстановки}, часто рассматриваемый, например, при описании лямбда-исчисления. 

Мы не будем здесь выписывать всю формалистику, связанную с этой операцией, поскольку она, во-первых, абсолютно схожа с процессом подстановки в лямбда-исчислении, а во-вторых, она потребует введения нескольких классических понятий (например, альфа-эквивалентности), совершенно излишних в контексте данной работы. 

В связи с этим, мы приводим здесь лишь интуитивное описание процесса подстановки, отсылая за подробностями в любой хрестоматийный труд по теории языков программирования, например, в \cite{TAPL}.

\begin{definition}
     Пусть схема $S$ записана для объявления некоторой функции с формальным параметром \code{x}. Будем говорить, что <<$S$ абстрагирована по \code{x}>>, а \code{x} -- связана в $S$.
     
     Тогда \term{подстановкой выражения $t$ вместо переменной \code{x} в схему $S$} будем называть схему $S[x \to t]$, которая в точности равна схеме $S$ за исключением того, что любое вхождение \code{x} в ней заменяется на выражение $t$. 
\end{definition}

Классически, при определении подстановки мы сталкиваемся с проблемой захвата переменной -- если схема $S$ абстрагирована по \code{x} и при этом содержит в себе другую схему $Q$, которая также абстрагирована по \code{x}, то подставлять $t$ вместо \code{x} в $Q$ некорректно. 

Обычно эта проблема решается с помощью простого наблюдения: имена связанных переменных не важны, и могут быть выбраны произвольно. Тогда мы можем переименовать все переменные так, чтобы все имена были уникальны. Этого весьма неформального утверждения будет достаточно для наших целей. 




\subsubsection{Комбинирование схем эффектов}

Теперь мы умеем использовать схемы эффектов в простых вызовах. Однако этого пока что недостаточно для практического использования: в частности, вложенные вызовы порождают вложенные схемы, работа с которыми неудобна:

\begin{minted}{kotlin}
    val x: Any?
    ...
    <initialize x somehow>
    ...
    assert(isString(y))
\end{minted}

При построении схемы для данного вызова необходимо выполнить две подстановки: сначала $isString[x \to "Hello, World!"]$ (результат обозначим как $isString'$), потом $assert[cond \to isString']$. Более подробно:

\bigskip

\schema{isString(y)} {
        \es{y is String -> Returns true} \\
        \es{y !is String -> Returns false} \\
}{}

\bigskip 

\schema{assert(isString(y))} 
{
    \schema{isString(y)}
    {
        \es{y is String -> Returns true} \\
        \es{y !is String -> Returns false} \\
    }
    {
        \es{== true} $\rightarrow$ \es{Returns Unit} 
    }
    
    \\[2em]
    
    \schema
    {isString(y)}
    {
        \es{y is String -> Returns true} \\
        \es{y !is String -> Returns false} \\
    } 
    {
        \es{== false} $\rightarrow$ \begin{tabular}{l}
             \es{Throws} \\
            \es{AssertionError}
        \end{tabular}
    }
}
{}

При этом хотелось бы, чтобы схема для вложенного вызова отражала итоговую его семантику, а именно: вызов завершается успешно тогда и только тогда, когда \code{y} является \code{String}. На языке схем эффектов это будет выглядеть так:

\schema{assert(isString(y)}
{
    \es{y is String} $\rightarrow$ \es{Returns Unit} \\
    \es{y !is String} $\rightarrow$ \es{Throws AssertionError}
    
}{}

Для этого нам нужно ввести операцию \term{комбинирования} схем:

\begin{definition}
    Пусть $S$ -- некоторая схема эффектов. Тогда результатом \term{многошагового сглаживания} этой схемы будем называть схему $S_{flat}$, такую, что она не содержит вложенных схем эффектов и при этом изоморфна схеме $S$. Мы иногда будем называть $S_{flat}$ \term{плоской}.
\end{definition}

Мы хотели бы перейти к задаче \term{одношагового сглаживания}: требуется сгладить узел, такой, что некоторые его аргументы являются схемами эффектов, но при этом все эти схемы эффектов сами по себе уже являются плоскими. Это помогло бы нам тем, что имея операцию одношагового сглаживания, легко построить операцию многошагового сглаживания с использованием рекурсии:

\begin{minted}{text}
fun ManyStepFlatten(root) {
    for (i in 1 to |root.childs|) {
        v#$_i$#  #$\leftarrow$# root.childs[i]
        v'#$_i$# #$\leftarrow$# ManyStepFlatten(v#$_i$#) 
    }
    return OneStepFlatten(root, {v#$_1$#, v#$_2$#, #$\ldots$#, v#$_{|root.childs|}$#})
}
\end{minted}

Действительно, рано или поздно $ManyStepFlatten$ доберется до листьев иерархии, тем самым вырождаясь в вызов $OneStepFlatten$. Листья, при этом, разумеется, и так плоские, поэтому требование для $OneStepFlatten$ выполнено. При обратном ходе рекурсии требование плоскости аргументов $OneStepFlatten$ также будет выполняться согласно определению $ManyStepFlatten$. 

Осталось определить $OneStepFlatten$. Внимательное рассмотрение грамматики позволяет заметить, для этого достаточно определить $OneStepFlatten$ для трех случаев (одношаговое сглаживание плоских узлов выполняется тривиально):

\begin{enumerate}   
    \item Сглаживание оператора, хотя бы один из аргументов которого -- схема эффектов
    
    \item Сглаживание утверждения, посылка или заключение которого -- схема эффектов
    
    \item Сглаживание эффекта \code{Returns}, аргумент которого -- схема эффектов
    
    \item Сглаживание схемы эффектов, у которой хотя бы одно из утверждений является схемой эффектов.
\end{enumerate}

Сразу заметим, что одношаговое сглаживание системы эффектов также определяется достаточно просто и соответствует объединению утверждений всех аргументов. 

Таким образом, нам необходимо предоставить следующие алгоритмы:

\begin{itemize}
    \item Сглаживание оператора, все аргументы которого являются схемами эффектов
    
    \item Сглаживание утверждения, посылка и заключение которого являются схемами эффектов
    
    \item Сглаживание эффекта \code{Returns}, аргумент которого -- схема эффектов
\end{itemize}

Конечные версии этих алгоритмов, пригодных для использования на практике являются достаточно сложными и громоздкими. Поэтому мы сделаем следующие несколько предположений:

\begin{itemize}
    \item Все операторы бинарные
    
    \item При сглаживании оператора будем считать, что все его аргументы являются схемами эффектов (а не только некоторые)
    
    \item Все вычисления являются тотальными
\end{itemize}

Мы начнем с достаточно простого алгоритма, работающего только при выполнении этих предположений. Затем мы будем постепенно усложнять его, показывая, как можно отказаться от каждого из этих предположений.

\subsubsection{Сглаживание операторов. Базовый алгоритм}

Для простоты рассмотрим некоторый бинарный оператор $\alpha$ -- предложенный алгоритм будет легко обобщаться на операторы другой арности. Пусть его аргументами являются два выражения $A, B$, с соответствующими схемами:

\schema{A}
{
    $c^A_1 \rightarrow e^A_1$ \\
    $c^A_2 \rightarrow e^A_2$ \\
    $\ldots$ \\
    $c^A_n \rightarrow e^A_n$ \\
}{}

\bigskip

\schema{B}
{
    $c^B_1 \rightarrow e^B_1$ \\
    $c^B_2 \rightarrow e^B_2$ \\
    $\ldots$ \\
    $c^B_m \rightarrow e^B_m$ \\        
}{}

Необходимо построить схему эффектов, соответствующую вычислению $\alpha(A, B)$. 



Сначала мы просто берем декартово произведение множеств утверждений схем $A$ и $B$, получая множество пар утверждений вида: 

$$A \times B = \big\{ (c^A_i \rightarrow e^A_i, c^B_j \rightarrow e^B_j) \rvert i \in 1 \ldots n, j \in 1 \ldots m \big\}$$

Можно видеть, что это множество пар содержит в себе \emph{практически} все возможные пары эффектов, которые могли быть сгенерированы при вычислении аргументов оператора. Более того, ко всем этим парам эффектов прикреплены условия, и для того, чтобы \emph{пара} эффектов выстрелила, необходимо, чтобы были выполнены \emph{оба соответствующих} условия. 

По сути, эти рассуждения являются вольным пересказом следующего преобразования, которое из пары утверждений получает одно:

$$ (c^A_i \rightarrow e^A_i, c^B_j \rightarrow e^B_j) \Rightarrow c^A_i \land c^B_j \rightarrow e^A_i, e^B_j $$

Однако здесь пока что еще нигде не появился оператор $\alpha$. Вообще говоря, мы никак не ограничивали то, что оператор может сделать с аргументами, поэтому в целом мы должны сказать, что затем это утверждение подвергается преобразованию $\alpha$, определяемому самим оператором:

$$ \alpha(c^A_i \land c^B_j \rightarrow e^A_i, e^B_j) $$ 

Здесь мы могли бы и закончить, сказав, что результат этого преобразования может быть абсолютно любым, с любым изменением структуры утверждения вплоть до полного удаления.

Тем не менее, практика показывает, что большинство операторов устроены достаточно просто, и такая общность является излишней. В частности, все операторы, которые будут рассмотрены в этой работе, действуют только и исключительно на заключения, оставляя посылки нетронутыми.

В этом есть некоторая логика, поскольку мы здесь интересуемся наблюдаемыми эффектами при вычислении оператора $\alpha$. Запись $c^A_i \land c^B_j \rightarrow e^A_i, e^B_j$ говорит нам, что аргументы этого оператора при выполненииусловий $c^A_i \land c^B_j$ эффекты $e^A_i, e^B_j$. Но это еще не означает, что мы обязательно пронаблюдаем эти эффекты, т.к. между эти эффекты должны еще пройти через оператор $\alpha$. Очевидно, что этот оператор может повлиять на наблюдаемые эффекты (например, обработав летящее исключение). Но что более интересно, из такого объяснения должно стать ясно, что он не должен влиять на условия $c^A_i \land c^B_j$, потому что это свойство \emph{аргументов} оператора, но не его самого и даже не вычисления оператора на этих аргументах.

Таким образом, мы определим преобразование оператора более точно:

$$ \alpha(c^A_i \land c^B_j \rightarrow e^A_i, e^B_j \equiv c^A_i \land c^B_j \rightarrow \alpha(e^A_i, e^B_j) $$

Что дает нам  следующую схему эффектов:

\schema{/$\alpha$/(A, B)}
{
    $c^A_1 \land c^B_1 \rightarrow \alpha(e^A_1, e^B_1)$ \\
    $c^A_1 \land c^B_2 \rightarrow \alpha(e^A_1, e^B_2)$ \\
    $\ldots$ \\
    $c^A_1 \land c^B_m \rightarrow \alpha(e^A_1, e^B_m)$ \\
    $c^A_2 \land c^B_1 \rightarrow \alpha(e^A_2, e^B_1)$ \\
    $c^A_2 \land c^B_2 \rightarrow \alpha(e^A_2, e^B_2)$ \\
}{}

Однако остается еще один небольшой нюанс. Мы сказали, что декартово произведение $A \times B$ содержит <<почти>> все эффекты вычисления аргументов $A$ и $B$. Какие же эффекты были упущены? Для ответа на этот вопрос вспомним, что возможны такие корректные состояния контекста, что ни одно из утверждений схемы не выполняется.

Другими словами, могут существовать такие состояния контекста, что ни одно из $c^A_i$ не выполняется, но выполняются некоторые $c^B_j$. Отсюда мы бы могли наивно заключить, что вычисление аргументов оператора влечет соответствующие эффекты $e^B_j$, но это было бы неверно. Действительно, неизвестность 