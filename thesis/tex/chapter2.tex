\section{Устройство систем условных эффектов}

\subsection{Основные понятия}

\subsubsection{Понятие условного эффекта}

Центральным определением в данной работе, является, разумеется, \term{эффект}. Однако несмотря на то, что это определение, судя по всему, было введено еще на заре развития программирования (так, ранние работы по аксиоматизации программирования уже ссылаются на этот термин без отдельного его введения \cite{Hoare69, Schwartz67}), общепринятой формулировки за все это время не появилось. 

В классических источниках, под эффектом чаще всего понимают <<некоторое видимое изменение в окружении>> \cite{Luc88}, или даже еще более конкретно <<изменение в памяти программы>> \cite{Vak09}. Некоторые исследователи и вовсе ограничивают это определение до <<чтения или записи в изменяемое состояние программы>> \cite{Green99}. Это можно резюмировать следующим образом:

\begin{definition}
    \label{def-effect-1}
    \term{Эффектом} называется некоторое изменение, производимое подпрограммой в состоянии вычислителя (кроме возвращения подпрограммой значения).
\end{definition}

Другие же авторы употребляют более широкую трактовку <<эффекта>> \cite{Nielson99}: 

\begin{definition}
    \label{def-effect-2}
    \term{Эффектом} является описание действий, происходящих в ходе выполнения подпрограммы.
\end{definition}

Разумеется, формулировка \ref{def-effect-2} является слишком широкой -- вплоть до того, что под нее подходит непосредственно исходный код тела функции. С другой же стороны, формулировка \ref{def-effect-1} является нежелательно узкой в контексте данной работы. Поясним это на примере:

\begin{minted}{kotlin}
	fun always42(): Int {
		return 42
	}
\end{minted}

Мы бы хотели говорить, что данная функция имеет эффект <<Всегда возвращает число 42>>. Однако это действие не подходит под определение эффекта \ref{def-effect-1}. Мы могли бы отказаться от специального случая для возвращаемых значений в этой формулировке, но в дальнейшем мы встретим некоторые утверждения, которые мы тоже хотели бы называть эффектами, но которые не описывают вообще никакого изменения в состоянии вычислителя.

Поэтому нам понадобится определение, чуть более слабое, чем определение \ref{def-effect-1}, но при этом не являющееся чересчур расплывчатым, как \ref{def-effect-2}. Мы сформулируем его следующим образом:

\begin{definition}
    \label{def-effect}
    \term{Эффект} -- это некоторая информация об окружении, получаемая при выполнении подпрограммы.
\end{definition}

Т.к. это определение рассматривает только окружение, то сразу отпадают все слишком широкие его интерпретации. В частности, все, что подпрограмма делает со своими локальными переменными, не подходит под это определение -- что очень удобно, т.к. изменения в локальных переменных нас никоим образом не интересуют.

С другой стороны, это определение включает в себя определение \ref{def-effect-1}, т.к. <<изменение в состоянии>>, несомненно, является <<информацией об окружении>>.

Наконец, как мы увидим чуть позже, под это определение подходят и довольно нестандартные действия, которые нам будет удобно считать эффектами во имя общности подхода.

\bigskip

Однако, даже такое, слегка расширенное понятие эффект недостаточно для того, чтобы формализовать устройство многих функций. 

Для примера рассмотрим следующую функцию, которая является тривиальной оберткой над проверкой переменной на принадлежность строковому типу:

\begin{minted}{kotlin}
fun isString(x: Any?): Boolean {
return (x is String)
}
\end{minted}

Мы бы хотели отразить тот факт, что функция возвращает \code{true} тогда и только тогда, когда \code{x} является \code{String}. Для этого введем формализуем понятие условного эффекта:

\begin{definition}
    \label{def-cond-effect}
    \term{Утверждением} будем называть пару $(c, e)$, где $e$ -- эффект, а $c$ -- некоторый набор условий. Семантика этой пары такова, что эффект $e$ имеет место тогда, когда $c$ выполняется.  
    
    В дальнейшем мы будем иногда называть условие $c$ \term{посылкой}, и записывать эту пару следующим образом: $c \to e$.
   
\end{definition}

Обратим внимание, что выполнение условий $c$ влечет эффект $e$, однако \emph{невыполнение условий не гарантирует отсутствие эффекта}. Этот нюанс важен для сохранения консервативности некоторых видов анализа, о которых мы будем говорить далее.

Также отметим, что обычные эффекты естественным образом выражаются через условные, если в качестве посылки использовать выражение, которое всегда выполняется (немного забегая вперед, скажем, что в качестве такого выражения мы будем использовать \code{true}, т.е. логическую истину).



\subsubsection{Понятие схемы эффектов}


Итак, у нас есть понятие <<утверждение>>, описывающее условный эффект. Однако этого еще недостаточно для наших целей. Достаточно взглянуть даже на очень простой пример с функцией \code{isString(x)}, выдающей результат проверки аргумента на принадлежность строковому типу, чтобы понять, что утверждения часто используются в группах. Так, чтобы описать поведение функции \code{isString(x)}, на самом деле необходимо два утверждения:

\begin{itemize}
    \item Если \code{x is String} верно, то функция возвращает \code{true}
    
    \item Если \code{x is String} неверно, то функция возвращает \code{false}
\end{itemize}

Поэтому в рамках данной работы было введено понятие \term{схемы эффектов}, формализующее данную идею:

\begin{definition}
    \term{Схемой эффектов} называется набор \emph{независимых} утверждений, описывающих условные эффекты некоторого участка кода.
\end{definition}

Обратим внимание, что определение говорит, о \emph{независимости} утверждений в схеме, т.е. исполнение или неисполнение некоторого конкретного утверждения не влияет на другие. Важно понимать, что при этом может быть верным буквально \emph{любое} подмножество утверждений, в том числе и пустое.

Также заметим, что используя независимые утверждения, легко выразить случаи, когда выполнение одного условия влечет сразу несколько эффектов -- для этого достаточно выписать несколько утверждений с одним и тем же условием и разными эффектами.




\subsubsection{Краткая грамматика языка описания эффектов}

Теперь, определившись с основными понятиями, мы можем ввести грамматику для записи схем эффектов и утверждений. 
Для описания здесь будет использоваться синтаксис, близкий к EBNF (расширенной нормальной форме Бэкуса-Науэра). Мы будем придерживаться следующих соглашений:

\begin{itemize}
    \item Терминалы начинаются с большой буквы, например: \code{SimpleTerminal}
    
    \item Нетерминалы начинаются с маленькой буквы: \code{nonterminalSymbol}
    
    \item Каждая продукция начинается с двоеточия <<$\colon$>> и заканчивается точкой с запятой <<;>>
    
    \item Операторы <<|>>, <<*>>, <<+>>, <<?>> несут стандартный смысл альтернативы, итерации (ноль или более), итерации (один или более) или опции (один или менее) соответственно.
    
    \item Кроме того, мы будем писать $\alpha \{ \beta \}$, чтобы обозначить непустой список из символов $\alpha$, разделенных символом $\beta$. 
\end{itemize}

Мы приводим здесь неформальную грамматику, опуская технические детали вроде леворекурсивных правил, точных определений литералов, приоритетов и т.д.  Полная грамматика в синтаксисе \lang{ANTLR} приведена в приложении \ref{appendix-es-grammar}.

\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}

\begin{minted}{antlr}

    effectSchema : statement{ ';' } ;
    
    statement : expression '->' effect{ ',' } ;
    
    expression : operator | Constant | Variable ;
    
    operator : isOperator | andOperator | orOperator | equalOperator ;
    
    effect : returnsEffect | throwsEffect | callsEffect ;
      
    // Операторы
    isOperator     : Variable 'is' Type ;
    andOperator    : expression '\&\&' expression ;
    orOperator     : expression '||' expression ;
    equalOperator  : expression '==' expression ;
    
    // Эффекты
    returnsEffect : 'Returns' '(' (expression | Wildcard)  ')' ;
    throwsEffect  : 'Throws'  '(' (Type       | Wildcard)  ')' ;
    callsEffect   : 'Calls'   '(' (Variable   | Wildcard) ',' Constant ')' ;
    
    // Терминалы
    Constant : <численная либо строковая константа> ; 
    Variable : <корректный идентификатор> ;        
    Type     : <корректный идентификатор> ;
    Wildcard : '???' ;
    
\end{minted}

Семантика операторов:

\begin{itemize}
    \item \code{Is-оператор} -- выдает результат проверки переменной на принадлежность типу, подробнее см. в \cite{kotlin:typechecks}.
    
    \item \code{And-оператор} -- соответствует логической конъюнкции.
    
    \item \code{Or-оператор} -- соответствует логической дизъюнкции.
    
    \item \code{Equal-оператор} -- соответствует проверке на равенство (equality) в \lang{Kotlin}, подробнее см. в \cite{kotlin:equality}.
\end{itemize}

Семантика эффектов:

\begin{itemize}
    \item \code{Returns(x)} говорит, что данный участок кода при исполнении возвращает значение \code{x}.
    
    \item \code{Throws(e)} говорит, что в результате исполнения данного участка кода генерируется исключение \code{e}.
    
    \item \code{Calls(f, c)} говорит, что в результате исполнения данного участка кода \code{c} раз будет вызвана функция \code{f}.
\end{itemize}

Кроме того, нам понадобилось ввести особый символ подстановки <<???>>, означающий неизвестность. Он необходим для того, чтобы можно было записать утверждения вроде: \code{Returns ???} (<<участок кода завершается успешно, но конкретное возвращаемое значение неизвестно>>), или \code{Throws ???} (<<участок кода завершается неуспешно>>). Особенно большое значение наличие таких конструкций будет иметь при извлечении полезной информации из системы эффектов, о чем мы будем говорить в главе 3.

Заметим, что приведенная выше грамматика естественным образом индуцирует дерево, которое мы будем называть \term{деревом схемы эффектов}, или просто \term{дерево схемы}. Фактически, если рассматривать схему как некоторое выражение в грамматике, определенной выше, то дерево этой схемы соответствует дереву разбора этого выражения, из которого удалены все узлы-литералы (такие как разделители, скобки и т.д.). 

\subsubsection{Консервативные приближения и схемы эффектов}

В области статического анализа широко известно понятие <<консервативного приближения>>. Его суть заключается в следующем. 

Задачей статического анализа является получение некоторой информации о динамическом поведении программы до непосредственного исполнения. При этом, зачастую, получить стопроцентно точную информацию или очень сложно, или вовсе невозможно. Поэтому обычно речь идет лишь о получении некоторого <<приближения>> реального поведения программы. 

Однако термин <<приближение>> сам по себе недостаточно выразителен. Например, какая-нибудь ветка условного выражения может быть ложной в $99.999999\%$ случаев. В зависимости от целей, код, который не содержит этой ветки вообще, может быть и отличным приближением (например, для профилирования программы), а может быть и ужасным. Последнее в основном верно для систем, которые изменяют код без прямого участия пользователя -- например, если такой код получился в результате работы оптимизатора перед компиляцией, то это катастрофическая ошибка, поскольку эти две программы в том самом одном случае из десяти миллионов \emph{работают по-разному}. 

Поэтому нам понадобится более сильный термин, а именно, \term{консервативное приближение}.

\begin{definition}
    Мы будем называть преобразование кода \term{консервативным}, если оно не изменяет внешнего поведения программы. Информация, использование которой допускает только консервативные преобразования кода, мы будем называть \term{консервативной} или иногда \term{консерватным приближением} (динамического поведения программы)
\end{definition}

Например, в \code{Java} консервативным преобразованием является удаление \code{else}-ветки выражения вида \code{if (true) \{ ... \} else \{ ... \} } -- действительно, управление никогда не могло попасть в эту ветку, поэтому внешнее поведение измениться при таком преобразовании не могло.

Интуитивно, консервативные приближения могут ошибаться только <<в одну сторону>>, и не могут быть использованы для того, чтобы оправдать преобразование кода, потенциально <<ломающее>> программу. 

Для того, чтобы схемы эффектов можно было использовать на практике, необходимо, чтобы они являлись консервативным приближением описания всех возможных эффектов соответствующего участка кода. Для этого мы не будем требовать, чтобы утверждения схемы \emph{полностью} специфицировали поведение подпрограммы. Другими словами, мы будем по умолчанию полагать, что возможны корректные исполнения, когда ни одна из посылок неверна -- при этом подразумевается, что мы ничего не знаем про эффекты соответствующей подпрограммы. 

Для примера рассмотрим следующую простую функцию:

\begin{minted}{kotlin}
    fun A(x: Int?, y: Int, z: Int): Int {
        if (x == null) throw IllegalArgumentException()
        return (x + y) / z
    }
\end{minted}

Следующая схема является корректным консервативным приближением динамического поведения этой функции:

\schema{A(x, y, z)}{
    \es{x == null} $\rightarrow$ \es{Throws InvalidArgumentException}
}{}

Эта схема действительно описывает часть поведения функции: если первый аргумент \code{null}, то исполнение аварийно завершается с исключением. Однако если это не так, то эта схема говорит, что о функции ничего не известно. В частности, обратите внимание, что в схеме отсутствует утверждение, описывающее тот факт, что функция также аварийно завершается с ошибкой целочисленного деления на ноль в том случае, если \code{z == 0}.

Однако мы не можем слишком сильно ослаблять требования на полноту спецификации. Например, доводя этот принцип до крайности, можно было бы сказать, что и каждое утверждение не является полной спецификацией. Однако это ведет к получению довольно бесполезной и неудобной системы -- действительно, в этой системе, например, нельзя будет выразить утверждение, что функция при исполнении вызывает другую \emph{ровно} один раз. Запись \code{Calls(f, 1)} будет означать, что \code{f} вызывается \emph{по меньшей мере} один раз, т.к. в силу неполноты спецификации, анализатор вынужден считать, что функция может делать еще какие-то дополнительные вызовы \code{f}.


Поэтому в дальнейшем при анализе мы будем считать, что заключение отдельно взятого утверждение описывает все эффекты данного вычисления. Таким образом, для сохранения консервативности, анализатору нет необходимости полагать, что утверждение может иметь какие-либо другие эффекты.

\subsubsection{Изоморфизм схем}

В будущем мы будем определять некоторые трансформации над схемами эффектов. Большинство этих трансформаций в каком-то смысле будут изменять лишь структуру схему, оставляя заложенную в нее информацию неизменной. Опять же, мы могли бы дать полностью формальное определение этому понятию, но это потребовало бы непропорционально больших усилий, поэтому ограничимся интуитивным:

\begin{definition}
    Будем говорить, что схемы $A$ и $B$ являются \term{изоморфными}, если они описывают один и тот же набор условных эффектов. Трансформацию, которая переводит схему $A$ в схему $B$ будем называть \term{изоморфизмом схем}.
\end{definition}

Интуитивно, мы можем спокойно заменить схему изоморфной, и это никак не повлияет на результаты анализа кода, полученные с помощью этой схемы. Например, следующие две схемы являются изоморфными, хотя с чисто синтаксической точки зрения в них записаны разные утверждения:

\schema{A}
{
    \es{x == true && y is Int}   $\rightarrow$ \es{Returns 1} \\
    \es{x == false || y !is Int} $\rightarrow$ \es{Returns 0} \\
}{}

\bigskip

\schema{B}
{
    \es{!(x == false || y !is Int)} $\rightarrow$ \es{Returns 1} \\
    \es{!(x == true && y is Int)}   $\rightarrow$ \es{Returns 0}
}
{}



\subsubsection{Примеры}

Теперь мы ввели все необходимые понятия для того, чтобы научиться аннотировать некоторые функции с не слишком сложными контрактами (в частности, обсуждение уточнений типов в коллекциях мы на некоторое время отложим). В данном разделе мы приведем несколько примеров для того, чтобы наглядно продемонстрировать работу с описанным синтаксисом и терминами.

Начнем с рассмотрения уже использовавшейся нами не раз функции \code{isString(x)}:

\begin{minted}{kotlin}
    fun isString(x: Any?): Boolean {
        return (x is String)
    }
\end{minted}

Ей соответствует следующая схема:

\schema{isString}{
      \es{x is String} $\rightarrow$ \es{Returns(true)} \\
      \es{x !is String} $\rightarrow$ \es{Returns false} \\
}
{}

Как мы видим, эта схема в точности передает контракт \code{isString(x)}: функция возвращает \code{true} если переданный аргумент является подтипом \code{String} и возвращает \code{false} в противном случае. 

Заметим, что в силу того, что мы используем независимые утверждения, схема эффектов не отражает явным образом тот факт, что эти два утверждения описывают \emph{все} возможные результаты выполнения данной функции. Неявно это выражено тем, что для любого объекта \code{x} верно либо \code{x is String}, либо \code{x !is String}. 


\bigskip


Другой пример, который мы хотели бы выразить в системе эффектов, это функция \code{assert}. Мы уже упоминали это соглашение, и здесь мы повторим его: мы будем считать, что \code{assert} всегда генерирует исключение, если переданный аргумент равен \code{false}. На практике это не верно (в частности, для языка \lang{Kotlin}), т.к. поведение \code{assert} может регулироваться флагами окружения. 

\begin{minted}{kotlin}
    fun assert(cond: Boolean): Unit {
        if (!cond) {
            throw AssertionError("Assertion Failed")
        }
    }
\end{minted}

Этой функции соответствует следующая схема:

\schema{assert}{
        \es{cond == true}  $\rightarrow$ \es{Returns(Unit)} \\
        \es{cond == false} $\rightarrow$ \es{Throws AssertionError}
}
{}

Эта запись отражает контракт функции \code{assert}: она завершается успешно тогда и только тогда, когда аргумент равен \code{true}. Опять же, факт того, что описание в схеме исчерпывающее, выражен неявно -- булева переменная либо истинна, либо ложна.


\bigskip


Наконец, рассмотрим функции типа \code{run}, которые в ходе своей работы вызывают некоторую другую детерминированное число раз:

\begin{minted}{kotlin}
    fun run(block: () -> Unit): Unit {
        block()
    }
\end{minted}

Этой функции соответствует схема:

\schema{run}{
        \es{true} $\rightarrow$ \es{Calls(block, 1)}
}
{}

Данная запись отражает то, что функция \code{run} \emph{всегда} (посылка \code{true} всегда истинна) вызывает переданный аргумент \code{block} ровно один раз.

Отметим, что в данном случае схема специфицирует лишь \emph{часть} контракта функции. В частности, она не отражает тот факт, что функция завершается успешно тогда и только тогда, когда успешно завершается вызов \code{block()}.








\subsection{Использование схем эффектов}

\subsubsection{Подстановка аргументов}

\label{section-arguments-substitution}

Мы научились описывать базовые схемы эффектов для функции. При этом мы не заостряли внимание на том, что все эти схемы используют \emph{параметры} функции. С точки зрения формализма, эти схемы не имеют смысла при вызове функции с конкретными аргументами. Действительно, пусть у нас есть схема для все той же функции \code{isString}:

\schema{isString(x)}
{
        \es{x is String} $\rightarrow$ \es{Returns true}
        \es{x !is String} $\rightarrow$ \es{Returns false}
}
{}

И пусть мы вызываем эту функцию в коде:

\begin{minted}{kotlin}
    val someValue: Any?
    <initialize x somehow>
    
    if (isString(someValue)) {
        println("someValue is String!")
    }
\end{minted}

Чисто формально, в строке 5 мы хотели бы получить схему, в которой используется \code{someValue}, а не \code{x}:

\schema{isString(someValue)}{
        \es{someValue is String} $\rightarrow$ \es{Returns true} \\
        \es{someValue !is String} $\rightarrow$ \es{Returns false}
}{}

Т.е. мы должны некоторым образом связать формальные параметры (в данном случае \code{x}) и аргументы, использованные при вызове (в данном случае \code{someValue}). Это довольно известный процесс \term{подстановки}, часто рассматриваемый, например, при описании лямбда-исчисления. 

Мы не будем здесь выписывать всю формалистику, связанную с этой операцией, поскольку она, во-первых, абсолютно схожа с процессом подстановки в лямбда-исчислении, а во-вторых, она потребует введения нескольких классических понятий (например, альфа-эквивалентности), совершенно излишних в контексте данной работы. 

В связи с этим, мы приводим здесь лишь интуитивное описание процесса подстановки, отсылая за подробностями в любой хрестоматийный труд по теории языков программирования, например, в \cite{TAPL}.

\begin{definition}
     Пусть схема $S$ записана для объявления некоторой функции с формальным параметром \code{x}. Будем говорить, что <<$S$ \term{абстрагирована} по \code{x}>>, а \code{x} -- \term{связана} в $S$.
     
     Тогда \term{подстановкой выражения $t$ вместо переменной \code{x} в схему $S$} будем называть схему $S[x \to t]$, которая в точности равна схеме $S$ за исключением того, что любое вхождение \code{x} в ней заменяется на выражение $t$. 
\end{definition}

Классически, при определении подстановки мы сталкиваемся с проблемой захвата переменной -- если схема $S$ абстрагирована по \code{x} и при этом содержит в себе другую схему $Q$, которая также абстрагирована по \code{x}, то подставлять $t$ вместо \code{x} в $Q$ некорректно. 

Обычно эта проблема решается с помощью простого наблюдения: имена связанных переменных не важны, и могут быть выбраны произвольно. Тогда мы можем переименовать все переменные так, чтобы все имена были уникальны. Этого весьма неформального утверждения будет достаточно для наших целей. 




\subsubsection{Сглаживание схем эффектов}

\label{section-flattening}

Теперь мы умеем использовать схемы эффектов в простых вызовах. Однако этого пока что недостаточно для практического использования: в частности, вложенные вызовы порождают вложенные схемы, работа с которыми неудобна:

\begin{minted}{kotlin}
    val x: Any?
    ...
    <initialize x somehow>
    ...
    assert(isString(y))
\end{minted}

При построении схемы для данного вызова необходимо выполнить две подстановки: сначала $isString[x \to y]$ (результат обозначим как $isString'$), потом $assert[cond \to isString']$. Более подробно:

\bigskip

\schema{isString(y)} {
        \es{y is String -> Returns true} \\
        \es{y !is String -> Returns false} \\
}{}

\bigskip 

\schema{assert(isString(y))} 
{
    \schema{isString(y)}
    {
        \es{y is String -> Returns true} \\
        \es{y !is String -> Returns false} \\
    }
    {
        \es{== true} $\rightarrow$ \es{Returns Unit} 
    }
    
    \\[2em]
    
    \schema
    {isString(y)}
    {
        \es{y is String -> Returns true} \\
        \es{y !is String -> Returns false} \\
    } 
    {
        \es{== false} $\rightarrow$ \begin{tabular}{l}
             \es{Throws} \\
            \es{AssertionError}
        \end{tabular}
    }
}
{}

При этом хотелось бы, чтобы схема для вложенного вызова отражала итоговую его семантику, а именно: вызов завершается успешно тогда и только тогда, когда \code{y} является \code{String}. На языке схем эффектов это будет выглядеть так:

\schema{assert(isString(y)}
{
    \es{y is String} $\rightarrow$ \es{Returns Unit} \\
    \es{y !is String} $\rightarrow$ \es{Throws AssertionError}
    
}{}

Для этого нам нужно ввести операцию \term{сглаживания} схем:

\begin{definition}
    Пусть $S$ -- некоторая схема эффектов. Тогда результатом \term{многошагового сглаживания} этой схемы будем называть схему $S_{flat}$, такую, что она не содержит вложенных схем эффектов и при этом изоморфна схеме $S$. Мы иногда будем называть $S_{flat}$ \term{плоской}.
\end{definition}

Мы хотели бы перейти к задаче \term{одношагового сглаживания}: требуется сгладить узел, такой, что некоторые его аргументы являются схемами эффектов, но при этом все эти схемы эффектов сами по себе уже являются плоскими. Это помогло бы нам тем, что имея операцию одношагового сглаживания, легко построить операцию многошагового сглаживания с использованием рекурсии:

\begin{minted}{text}
fun ManyStepFlatten(root) {
    for (i in 1 to |root.childs|) {
        v#$_i$#  #$\leftarrow$# root.childs[i]
        v'#$_i$# #$\leftarrow$# ManyStepFlatten(v#$_i$#) 
    }
    return OneStepFlatten(root, {v#$_1$#, v#$_2$#, #$\ldots$#, v#$_{|root.childs|}$#})
}
\end{minted}

Действительно, рано или поздно $ManyStepFlatten$ доберется до листьев иерархии, тем самым вырождаясь в вызов $OneStepFlatten$. Листья, при этом, разумеется, и так плоские, поэтому требование для $OneStepFlatten$ выполнено. При обратном ходе рекурсии требование плоскости аргументов $OneStepFlatten$ также будет выполняться согласно определению $ManyStepFlatten$. 

Осталось определить $OneStepFlatten$. Внимательное рассмотрение грамматики позволяет заметить, для этого достаточно определить $OneStepFlatten$ для трех случаев (одношаговое сглаживание плоских узлов выполняется тривиально):

\begin{enumerate}   
    \item Сглаживание оператора, хотя бы один из аргументов которого -- схема эффектов
    
    \item Сглаживание утверждения, посылка или заключение которого -- схема эффектов
    
    \item Сглаживание схемы эффектов, у которой хотя бы одно из утверждений является схемой эффектов.
\end{enumerate}

Сразу заметим, что одношаговое сглаживание системы эффектов также определяется достаточно просто и соответствует объединению утверждений всех аргументов. 

Конечные версии этих алгоритмов, пригодных для использования на практике являются достаточно сложными и громоздкими. Поэтому мы сделаем следующие несколько предположений:

\begin{itemize}
    \item Все операторы бинарные
    
    \item При сглаживании оператора будем считать, что все его аргументы являются схемами эффектов (а не только некоторые)
    
    \item Все вычисления являются тотальными
\end{itemize}

Мы начнем с достаточно простого алгоритма, работающего только при выполнении этих предположений. Затем мы будем постепенно усложнять его, показывая, как можно отказаться от каждого из этих предположений.




\subsubsection{Сглаживание операторов. Базовый алгоритм}

Для простоты рассмотрим некоторый бинарный оператор $\alpha$ -- предложенный алгоритм будет легко обобщаться на операторы другой арности. Пусть его аргументами являются два выражения $A, B$, с соответствующими схемами:

\schema{A}
{
    $c^A_1 \rightarrow e^A_1$ \\
    $c^A_2 \rightarrow e^A_2$ \\
    $\ldots$ \\
    $c^A_n \rightarrow e^A_n$ \\
}{}

\bigskip

\schema{B}
{
    $c^B_1 \rightarrow e^B_1$ \\
    $c^B_2 \rightarrow e^B_2$ \\
    $\ldots$ \\
    $c^B_m \rightarrow e^B_m$ \\        
}{}

Необходимо построить схему эффектов, соответствующую вычислению $\alpha(A, B)$. 



Сначала мы просто берем декартово произведение множеств утверждений схем $A$ и $B$, получая множество пар утверждений вида: 

$$A \times B = \big\{ (c^A_i \rightarrow e^A_i, c^B_j \rightarrow e^B_j) \rvert i \in 1 \ldots n, j \in 1 \ldots m \big\}$$

Можно видеть, что это множество пар содержит в себе \emph{практически} все возможные пары эффектов, которые могли быть сгенерированы при вычислении аргументов оператора. Более того, ко всем этим парам эффектов прикреплены условия, и для того, чтобы \emph{пара} эффектов выстрелила, необходимо, чтобы были выполнены \emph{оба соответствующих} условия. 

Можно также думать про эти пары как про возможные пути потока управления -- сначала управление заходит в аргумент $A$, выполняется одно из условий $c^A_i$, выстреливают эффекты $e^A_i$, затем выполняется одно из условий $c^B_j$ и выстреливают соответствующие эффекты $e^B_j$. Таким образом, на этом пути вычисления верны условия $c^A_i$ и $c^B_j$ и генерируются эффекты $e^A_i, e^B_j$.

Рассуждения выше должны были подвести к следующему преобразованию, которое склеивает пару утверждений в одно:

$$ (c^A_i \rightarrow e^A_i, c^B_j \rightarrow e^B_j) \Rightarrow c^A_i \land c^B_j \rightarrow e^A_i, e^B_j $$

Однако здесь пока что еще нигде не появился оператор $\alpha$. Вообще говоря, мы никак не ограничивали то, что оператор может сделать с аргументами, поэтому в целом мы должны сказать, что затем это утверждение подвергается преобразованию $\alpha$, определяемому самим оператором:

$$ \alpha(c^A_i \land c^B_j \rightarrow e^A_i, e^B_j) $$ 

Здесь мы могли бы и закончить, сказав, что результат этого преобразования может быть абсолютно любым, с любым изменением структуры утверждения вплоть до полного удаления.

Тем не менее, практика показывает, что большинство операторов устроены достаточно просто, и такая общность является излишней. В частности, все операторы, которые будут рассмотрены в этой работе, действуют только и исключительно на заключения, оставляя посылки нетронутыми.

В этом есть некоторая логика, поскольку мы здесь интересуемся наблюдаемыми эффектами при вычислении оператора $\alpha$. Запись $c^A_i \land c^B_j \rightarrow e^A_i, e^B_j$ говорит нам, что аргументы этого оператора при выполнении условий $c^A_i \land c^B_j$ влекут эффекты $e^A_i, e^B_j$. Но это еще не означает, что мы обязательно пронаблюдаем эти эффекты, т.к. между ними и наблюдателем еще стоит оператор $\alpha$. Очевидно, что этот оператор может повлиять на наблюдаемые эффекты (например, обработав летящее исключение). Но что более интересно, из такого объяснения должно стать ясно, что он не должен влиять на условия $c^A_i \land c^B_j$, потому что это свойство \emph{аргументов} оператора, но не его самого и даже не вычисления оператора на этих аргументах.

Таким образом, мы определим преобразование оператора более точно:

$$ \alpha(c^A_i \land c^B_j \rightarrow e^A_i, e^B_j \equiv c^A_i \land c^B_j \rightarrow \alpha(e^A_i, e^B_j) $$

Что дает нам  следующую схему эффектов:

\schema{/$\alpha$/(A, B)}
{
    $c^A_1 \land c^B_1 \rightarrow \alpha(e^A_1, e^B_1)$ \\
    $c^A_1 \land c^B_2 \rightarrow \alpha(e^A_1, e^B_2)$ \\
    $\ldots$ \\
    $c^A_1 \land c^B_m \rightarrow \alpha(e^A_1, e^B_m)$ \\
    $c^A_2 \land c^B_1 \rightarrow \alpha(e^A_2, e^B_1)$ \\
    $c^A_2 \land c^B_2 \rightarrow \alpha(e^A_2, e^B_2)$ \\
    $\ldots$ \\
    $c^A_n \land c^B_m \rightarrow \alpha(e^A_n, e^B_m)$ \\
}{}

Заметим, что данный алгоритм естественно обобщается на операторы другой арности -- для оператора арности $r$ и аргументов $A_1, A_2, \ldots, A_r$ следует просто взять за основу $r$-местное декартово произведение $A_1 \times A_2 \times \ldots \times A_r$. Таким образом, мы уже отказались от предположения, что все операторы бинарные.

\bigskip

Остается еще один небольшой нюанс. Мы сказали, что декартово произведение $A \times B$ содержит <<почти>> все эффекты вычисления аргументов $A$ и $B$. Какие же эффекты были упущены? Для ответа на этот вопрос вспомним, что возможны такие корректные состояния контекста, что ни одно из утверждений схемы не выполняется.

Перенося это на наш конкретный случай, это означает, что могут существовать такие состояния контекста, что ни одно из $c^A_i$ не выполняется, но выполняются некоторые $c^B_j$. Отсюда мы бы могли наивно заключить, что вычисление аргументов оператора влечет соответствующие эффекты $e^B_j$, и записать $c^B_j \rightarrow e^B_j$. Однако это было бы, конечно, неверно. Действительно, вычисление аргумента $A$ могло скрывать некоторые другие эффекты, и выполнение условия $c^B_j$ влечет эффекты $e^B_j$ \emph{и еще какие-то неизвестные}, в то время как чуть ранее мы договорились, что запись $c^B_j \rightarrow e^B_j$ говорит о том, что выполнение условия $c^B_j$ влечет \emph{только} эффекты $e^B_j$.

Потенциально, мы могли бы все-таки попытаться побороться за эти эффекты, но для этого потребуется введение новых понятий, либо расширение старых. По этой причине мы оставим попытки учесть такие эффекты. Схема, построенная по описанию выше, конечно, по-прежнему будет консервативным приближением динамического поведения соответствующего участка кода. 




\subsubsection{Приведение к схеме}

Покажем, как отказаться от предположения, что все аргументы операторов являются схемами эффектов. Для этого вспомним еще раз рекурсивный алгоритм сглаживания:

\begin{minted}{text}
	fun ManyStepFlatten(root) {
	    for (i in 1 to |root.childs|) {
		    v#$_i$#  #$\leftarrow$# root.childs[i]
		    v'#$_i$# #$\leftarrow$# ManyStepFlatten(v#$_i$#) 
	    }
	    return OneStepFlatten(root, {v#$_1$#, v#$_2$#, #$\ldots$#, v#$_{|root.childs|}$#})
	}
\end{minted}

Достаточно договориться, что $OneStepFlatten$ всегда возвращает схему эффектов, и тогда предположение о том, что при сглаживании оператора все его аргументы являются схемами, будет выполнено. Действительно, перед сглаживанием оператора на всех его аргументах (детях в дереве схемы) вызывается $ManyStepFlatten$, который после рекурсивных вызовов возвращает результат $OneStepFlatten$.

В свою очередь, $OneStepFlatten$ и так возвращает схемы эффектов при сглаживании операторов. Таким образом, остается лишь немного изменить операцию сглаживания на константах и переменных. Ранее мы говорили, что $OneStepFlatten$ ничего не делает с такими узлами, т.к. они и так являются плоскими. Теперь же $OneStepFlatten(v)$, где $v$ -- это константа или переменная, будет возвращать следующую схему: 

\schema{OneStepFlatten(v)}
{
	\es{true} $\rightarrow$ \es{Returns(v)}	
}{}

Действительно, с точки зрения эффектов константа или переменная $v$ ничем не отличается от константной функции, всегда возвращающей $v$, схема которой и записана выше. 

Таким образом, $OneStepFlatten$ всегда возвращает схему эффектов, следовательно, всегда возвращает схему эффектов $ManyStepFlatten$, следовательно, требование о том, что все аргументы оператора при сглаживании являются схемами, будет выполнено.


\subsubsection{Сглаживание в присутствии частичных вычислений}

У нас осталось одно предположение, которое не выполняется на практике -- а именно, то, что все вычисления являются тотальными, т.е. всегда завершаются успешно. Отказаться от него будет уже не так просто, как от предыдущих двух, потому что частичные вычисления вынуждают намного более аккуратно обращаться с эффектами и учитывать, что аргументы оператора вычисляются последовательно. 

Итак, рассмотрим бинарный оператор $\alpha$, аргументами которого являются два выражения $A, B$, с соответствующими схемами:

\schema{A}
{
	$c^A_1 \rightarrow e^A_1$ \\
	$c^A_2 \rightarrow e^A_2$ \\
	$\ldots$ \\
	$c^A_n \rightarrow e^A_n$ \\
}{}

\bigskip

\schema{B}
{
	$c^B_1 \rightarrow e^B_1$ \\
	$c^B_2 \rightarrow e^B_2$ \\
	$\ldots$ \\
	$c^B_m \rightarrow e^B_m$ \\        
}{}

Необходимо построить схему эффектов, соответствующую вычислению $\alpha(A, B)$, учитывая то, что вычисления могут обрываться, а аргумент $A$ вычисляется раньше аргумента $B$.

Сначала поймем, почему нас не устраивает старый алгоритм. Пусть где-нибудь в схеме $A$ есть утверждение $c^A_i \rightarrow $ \es{Throws Exception, Calls(f, 1)}, а где-нибудь в схеме $B$ есть утверждение $c^B_j \rightarrow$ \es{Calls(f, 2)}. Тогда произведение $\alpha(A, B)$ будет содержать утверждение $c^A_i \land c^B_j \rightarrow \alpha$\code{(Throws Exception, Calls (f, 1), Calls (f, 2))}. 

Нам хотелось бы на выходе получить утверждение $c^A_i \land c^B_j \rightarrow$ \code{Throws Exception, Calls (f, 1)} -- обратите внимание, что эффект \code{Calls(f, 2)} здесь не появляется, т.к. он порождается вычислением аргумента $B$, которое не произошло из-за того, что вычисление аргумента $A$ сгенерировало ошибку. К сожалению, как бы ни было устроено преобразование $\alpha$, оно не сможет отделить корректные эффекты от некорректных -- на этом шаге уже потеряна вся информация, откуда пришел тот или иной эффект или условие.

Поэтому нам придется отступить на шаг назад. Вспомним, как было получено $\alpha(A, B)$. Сначала формировались все возможные пары утверждений $A \times B$:

$$A \times B = \big\{ (c^A_i \rightarrow e^A_i, c^B_j \rightarrow e^B_j) \rvert i \in 1 \ldots n, j \in 1 \ldots m \big\}$$

Затем каждая пара преобразовывалась в одно утверждение:

$$ (c^A_i \rightarrow e^A_i, c^B_j \rightarrow e^B_j) \Rightarrow c^A_i \land c^B_j \rightarrow e^A_i, e^B_j $$

Именно на этом шаге была внесена непоправимая ошибка. Вводя данное преобразование, мы приводили аналогию с путями исполнения -- поскольку ранее мы считали, что все вычисления тотальны, то было корректно считать, что после $c^A_i \rightarrow e^A_i$ управление передается в $c^B_j \rightarrow e^B_j$. Сейчас это не так, и необходимо аккуратнее учесть специфику частичных вычислений.

Для этого мы выделим эффекты \code{Throws} и \code{Returns} в отдельную группу, и будем называть их \term{исходами}. Мы будем делить все исходы на \term{успешные} (\code{Returns}) и \term{неуспешные} (\code{Throws}). Теперь мы можем более аккуратно сформулировать преобразование $Seq$, которое берет два утверждения, выполняющихся последовательно, и формирует из них одно:

\[
Seq(c_1 \rightarrow e_1, c_2 \rightarrow e_2) = 
\begin{cases}
c_1 \land c_2 \rightarrow e_1, e_2 & \text{если } e_1 \text{ содержит успешный исход} \\
c_1 \rightarrow e_1 			   & \text{иначе}
\end{cases}
\]

Таким образом, результирующая схема $\alpha(A, B)$ будем выглядеть следующим образом:

\schema{/$\alpha$/(A, B)}
{
	 $\alpha\Big(Seq (c^A_1 \rightarrow e^A_1, c^B_1 \rightarrow e^B_1) \Big)$ \\
	 $\alpha\Big(Seq (c^A_1 \rightarrow e^A_1, c^B_2 \rightarrow e^B_2) \Big)$ \\
	 $\ldots$ \\
	 $\alpha\Big(Seq (c^A_1 \rightarrow e^A_1, c^B_m \rightarrow e^B_m) \Big)$ \\
	 $\alpha\Big(Seq (c^A_2 \rightarrow e^A_2, c^B_1 \rightarrow e^B_1) \Big)$ \\
	 $\ldots$ \\
	 $\alpha\Big(Seq (c^A_n \rightarrow e^A_n, c^B_m \rightarrow e^B_m) \Big)$ \\
}
{}


\subsubsection{Сглаживание утверждений}

Пусть дано утверждение, заключением которого является набор эффектов $I$, а посылкой -- схема эффектов $A$:

\schema{A}
{
	$c^A_1 \rightarrow e^A_1$ \\
	$c^A_2 \rightarrow e^A_2$ \\
	$\ldots$ \\
	$c^A_n \rightarrow e^A_n$ \\
}{}

Мы бы хотели как можно больше переиспользовать алгоритм сглаживания операторов. Заключение $I$ легко выразить в форме эквивалентной схемы эффектов с одним утверждением <<\code{true -> I}>>, и тогда на это можно смотреть как на еще один бинарный оператор <<$\rightarrow$>>. Однако у него есть своя специфика, связанная с тем, что ложная посылка не влечет заключения. Другими словами, при сглаживании утверждений \code{Returns(false)} является своего рода \emph{неуспешным} исходом. 

При этом нужно учитывать, что утверждения с неуспешным исходом раньше добавлялись в результирующую схему <<как есть>>: $Seq(c^A_i \rightarrow e^A_i, c^B_j \rightarrow e^B_j) = Seq(c^A_i \rightarrow e^A_i)$, если $e^A_i$ содержит неуспешный исход. Теперь же если этот исход \code{Returns(false)}, то необходимо аккуратно удалить \code{Returns(false)} из списка эффектов $e^A_i$, потому что этот \code{Returns} не имеет отношения к результирующей схеме. 

Если $E$ -- список эффектов, а $e$ -- отдельный эффект, то будем обозначать $E \setminus e$ список $E$ без эффекта $e$.

Таким образом, для стрелки импликации $Seq_{impl}$ определен следующим образом

\[
Seq_{impl}(c_1 \rightarrow e_1, c_2 \rightarrow e_2) = 
\begin{cases}
c_1 \land c_2 \rightarrow e_1, e_2 & \text{если } e_1 \text{ содержит успешный исход} \\
c_1 \rightarrow e_1 \setminus Returns(false) & \text{если } e_1 \text{ содержит Returns(false)} \\
c_1 \rightarrow e_1							 & \text{иначе}
\end{cases}
\]



\subsubsection{Примеры преобразований операторов}

Теперь нам осталось лишь определить семантику преобразований операторов. Большинство преобразований устроены очень просто, и причину этого мы уже отметили, когда рассматривали \name{Checker Framework} -- зачастую эффекты приносят с собой некоторые связанные операторы, и вместе образуют замкнутую систему, которая очень мало взаимодействует с остальными. Таким образом, для значительной части преобразований $\alpha(e_1, e_2, \ldots, e_n)$ эффекты будут прозрачно <<подниматься>> через преобразование: $\alpha(e_1, e_2, \ldots, e_n) = e_1, e_2, \ldots, \alpha(e_i, e_{i + 1}, \ldots, e_j), \ldots e_n$.

Например, операторы \code{\&\&}, \code{||}, \code{==}, \code{is}, \code{!}, \code{is} образуют естественную группу вместе с эффектами, которые говорят про возвращаемое значение (\code{Returns}) и работают только с ними. Для них всех преобразование состоит в том, что оператор <<проваливается>> внутрь эффекта: 

\[
\begin{aligned}
	\es{\&\&(Returns(x), Returns(y))} & \equiv \es{Returns (x \&\& y)}    \\
	\es{||(Returns(x), Returns(y))}   & \equiv \es{Returns (x || y)}    \\
	\es{==(Returns(x), Returns(y))}   & \equiv \es{Returns (x == y)}    \\
	\es{is}_{type} \es{(Returns(x))}  & \equiv \es{Returns (x is type)} \\
	\es{!(Returns(x))} 				  & \equiv \es{Returns (!x)}
\end{aligned}
\]

Следует понимать, что хотя каждый оператор в отдельности и работает лишь с фиксированной группой эффектов, <<интересных>> ему, то, что он делает с этой группой и как ее выбирает, остается полностью в его юрисдикции. Выше мы видели, что оператор может выбрать несколько эффектов и слить их в один. Оператор может и удалять эффект (например, если бы ввели оператор \code{Catch E}, соответствующий аналогичной конструкции -- он бы удалял эффект \code{Throws E} из списка), а может и добавлять. Это следует учитывать при реализации системы эффектов на практике.



\subsection{Уменьшение размера схем эффектов}

\label{section-schemas-reducing}

\subsubsection{Проблема роста размера схем}

Если мы еще раз внимательно взглянем на алгоритм комбинирования схем, представленный в предыдущем разделе, то легко видеть, что при комбинировании схем размера $\bigo{n}$, $\bigo{m}$ мы получаем схему размера $\bigo{n \cdot m}$. Такие комбинирования возникают при вложенных вызовах, но важно понимать, что итоговая длина зависит от устройства схем и \emph{не ограничена} сверху произведением всех использованных схем. 

Действительно, рассмотрим функции \code{f(x, y, z)}, \code{g()}, \code{h()}, \code{r()} (типы опущены для ясности). Пусть размеры схем имеют сложность $\bigo{F}$, $\bigo{G}$, $\bigo{H}$, $\bigo{R}$ соответственно. Рассмотрим вызов \code{f(g(), h(), r())}. 

Пусть схема для \code{f} содержит утверждение вида \code{(x == y) \&\& (y == z)}. После выполнения подстановки это утверждение превращается в \code{(g() == h()) \&\& (h() == r())}, которое нуждается в сглаживании. 

Сглаживание выражения \code{g() == h()} дает схему сложностью $\bigo{G \cdot H}$, а сглаживание выражения \code{h() == r()} дает схему сложностью $\bigo{H \cdot R}$. Наконец, сглаживание оператора \code{==} дает схему сложностью $\bigo{G \cdot H^2 \cdot R}$. Если каждое утверждение в $F$ имеет подобную структуру, то в итоге получаем схему сложностью $\bigo{F \cdot G \cdot H^2 \cdot R}$, что \emph{больше}, чем просто произведение всех схем.

Оценку сверху можно получить, если представить схему $f$ в виде дерева с $\bigo{F}$ узлами, а схему $g$ в виде дерева с $\bigo{G}$ узлами. Тогда операция подстановки заменяет некоторые узлы в дереве $f$ на дерево $g$, и верхняя оценка для такой подстановки будет $\bigo{G^F}$ (заметим, что такая оценка является даже недостижимой, поскольку в реальности в некоторые узлы подстановка не может осуществляться -- например, в узлы, соответствующие операторам)

Подобная проблема характерна для условных эффектов при последовательном комбинировании -- например, при обзоре литературы мы уже видели экспоненциальный взрыв длины эффектов в статье \name{Types for Atomicity} \cite{Flanagan08}. Однако там из-за простого устройства условий (они все имеют вид <<Владеет ли функция некоторым набором блокировок?>>) авторам удалось справиться с этой проблемой. В нашем случае, надеяться на простое решение не стоит, т.к. в представленной системе условия могут представлять собой весьма нетривиальные комбинации из операторов, переменных, вызовов и т.д.

В связи с этим, в этом разделе мы поговорим о двух подходах к уменьшению размера схем. Один из них будет уменьшать размер схем без потери информации и будет, по большому счету, заниматься вычислением констант или приведении эффектов к некоторому каноническому виду. Кроме того, мы опишем второй подход, который потенциально может сжимать схемы намного сильнее, но ценой этому будет потеря информации. 


\subsubsection{Сокращение схем эффектов}

Если в схеме встречаются константы, то можно надеяться, что в схеме можно провести некоторые очевидные сокращения, основанные на знании о том, как операторы работают со своими аргументами.

Например, если у нас есть выражение вида \code{false \&\& x}, то очевидно, что оно вычисляется в \code{false} вне зависимости от того, чему равна переменная \code{x}. Таким образом, мы получаем следующий набор безопасных преобразований:

\begin{enumerate}
	\item Сокращение логических операторов:
	
	\es{false && x} $\equiv$ \es{false}
	
	\es{x && false} $\equiv$ \es{false}
	
	\es{true || x} $\equiv$ \es{true}
	
	\es{x || true} $\equiv$ \es{true}
	
	\es{!true} $\equiv$ \es{false}
	
	\es{!false} $\equiv$ \es{true}
	
	\item Сокращение оператора проверки на равенство (неравенство):
	
	Если значения величин $x$ и $y$ точно известны, то \es{x == y} вычисляется в \es{true} или \es{false} в зависимости от того, как сравниваются на равенство соответствующие значения -- конкретные правила определяются языком. Значения могут быть известны, если $x$ и $y$ являются константами, или же переменные, про которые можно точно доказать, что они имеют то или иное значение. 
	
	\item Сокращение оператора проверки на подтипизацию:
	
	\es{x is T} может быть сокращено в \es{true} или \es{false}, если можно доказать, что \es{x} точно является или не является подтипом типа \code{T}. Также как и с оператором равенства, мы всегда знаем точный тип констант, но вот с переменными нужно быть аккуратнее. Конкретные правила зависят от конкретной системы типов -- например, в языках с полиморфизмом нужно помнить, что статический тип переменной может отличаться от динамического. 
	
	\item Сокращение стрелки импликации в утверждениях:
	
	Как мы уже говорили, ложные посылки не влекут следствие, поэтому утверждения вида <<\es{false} $\rightarrow$ \es{E}>> можно удалить из схемы эффектов
\end{enumerate}

Может показаться, что если в вызове не фигурируют константы, то пользы от этого подхода нет совсем, но на самом деле это не так -- константы могут появляться из схемы эффектов. Например, схема для функции \code{assert(x)} содержит выражения вида \code{x == true}. Если вместо \code{x} подставляется некоторая другая схема эффектов, в которой есть утверждения вида \code{Returns(false)} или \code{Returns(true)}, то в схеме, полученной после сглаживания, мы вполне можем увидить выражения вида \code{false == true} или \code{true == true}.

Таким образом, данный подход является вполне работоспособным на практике для схем эффектов, которые используют константы -- и практика показывает, что это довольно часто является правдой.

Кроме того, заметим, что используя более сложные алгоритмы, можно развивать этот подход. Дело в том, что некоторые утверждение не являются независимыми -- например, выражения \code{x is String} и \code{x !is String} не могут быть верными одновременно, поэтому выражение вида \code{(x is String) \&\& (x !is String)} можно безопасно сократить до константы \code{false}. В данной работе мы не будем рассматривать подобные алгоритмы, отсылая читателя к классическим источникам \cite{McCluskey56} или же более современным работам \cite{Jain08}


\subsubsection{Аппроксимация схем эффектов}

Однако иногда сокращения схем оказывается недостаточно. Рассмотрим достаточно логичный и жизненный пример -- пусть есть какой-то очень сложный вызов с большой вложенностью, в недрах которого используется простая функция \code{assertNonNull(x)}, которая содержит утверждение \code{x == null} $\rightarrow$ \code{Throws AssertionError}. Будем считать, что никакая другая функция не обрабатывает это исключение -- тогда и для всего вызова данное утверждение является корректным. Тем не менее, в силу сглаживания, это утверждение будет появляться повсюду вместе с некоторыми другими условиями и эффектами:

\schema{}{
	$\ldots$ \\
	\es{x == null && <some conditions>} $\rightarrow$ \es{Throws AssertionError, <some effects> } \\
	\es{x == null && <other conditions>} $\rightarrow$ \es{Throws AssertionError, <other effects> } \\
	$\ldots$
}
{}

Для данной схемы верно, что если \code{x == null}, то всегда генерируется исключение \code{AssertionError}, но эта информация выражена неявно из-за дополнительных условий и эффектов. На практике, простые и краткие утверждения являются намного более полезными и удобными, чем длинные и подробные. Этому есть некоторое интуитивное обоснование. 

Пусть весь вызов задействует переменные $x_1, x_2, \ldots x_n$, каждая из которых может принимать $D_1, D_2, \ldots D_n$ различных значений. Рассмотрим некоторое утверждение. Чем больше переменных задействовано в его посылке, тем меньшую долю всех входов покрывает это утверждение. Получается, что сами по себе длинные утверждения требуют больше памяти для хранения, больше времени для работы с ними, в то время как реально использоваться они будут реже. 

Для примера рассмотрим частный случай, когда $x_1$ является булевской переменной и $D_1 = 2$. Тогда утверждение, посылка которого имеет вид \es{x/$_1$/ == true}, выполняется для половины всех возможных наборов входных параметров, т.е. грубо говоря, оно будет полезно в каждом втором случае. 

Это неформальное рассуждение должно показать, что на практике вполне полезным преобразованием является замена множества длинных утверждений на одно короткое, пусть даже при этом мы потеряем некоторую информацию. Это преобразование мы будем называть \term{аппроксимацией} схем эффектов.

В целом, эта задача имеет непосредственное отношение к задаче аппроксимации булевых функций, для которой разработаны достаточно эффективные решения \cite{Blais13}. Здесь мы рассмотрим самый простой в реализации, не вдаваясь в подробности его свойств и сравнения с другими, существующими алгоритмами.

\bigskip

Идея алгоритма состоит в следующем. Рассмотрим схему после сглаживания -- тогда посылка любого утверждения представляет собой набор операторов, соединенных логическими связками (отрицание, конъюнкция, дизъюнкция). Операторы, не являющиеся логическими связками, мы заменим на логические переменные $x_1, x_2, \ldots, x_n$ (причем одинаковым по содержанию операторам будут соответствовать одинаковые переменные). Также мы поступим и со всеми эффектами. После этого мы можем привести посылку к дизъюнктивной нормальной форме, и утверждения в схеме будут иметь вид логических формул вида $DNF(x_1, \ldots, x_n) \rightarrow e_1, \ldots, e_m$.

Теперь мы вводим понятие \term{сигнатур} -- каждая сигнатура соответствует некоторой булевой функции. Мы фиксируем некоторый набор $S$ интересующих нас сигнатур -- на практике, он будет состоять из одно- и двухместных булевых функций, т.е. тождественной функции, логического отрицания, конъюнкции, дизъюнкции, эквивалентности, исключающего <<или>> и т.д. 

Далее, мы перебираем все подмножества входных переменных в паре с эффектами. Для каждой пары вида $(x_{i_1}, \ldots, x_{i_r}; e_j)$ мы перебираем все $r$-местные сигнатуры из $S$. Зафкисируем сигнатуру $s$ и пару $(x_{i_1}, \ldots, x_{i_r}; e_j)$. Переберем $2^r$ возможных значений набора переменных $x_{i_1}, \ldots, x_{i_r}$. Для каждого набора есть его \term{результат в сигнатуре}, который определяется вычислением соответствующей сигнатуре функции на этих аргументах. 

\term{Результат} же этого набора {в схеме относительно эффекта} $e_j$ имеет три возможных значения -- <<истина>> (если подстановка этого набора значений в схему эффектов гарантированно влечет эффект $e_j$), <<ложь>> (если подстановка этого набора значений в схему эффектов гарантированно не влечет эффект $e_j$) и <<неизвестность>> (если подстановка этого набора значений в схему не дает возможности судить о наличии либо отсутствие эффекта).

Мы будем говорить, что пара $(x_{i_1}, \ldots, x_{i_r}; e_j)$ \term{удовлетворяет} сигнатуре $s$, если для любого набора значений переменных $x_{i_1}, \ldots, x_{i_r}$ результат этого набора в сигнатуре \emph{в точности} совпадает с результатом в схеме относительно эффекта $e_j$. Интуитивно, если пара $(x_{i_1}, \ldots, x_{i_r}; e_j)$ удовлетворяет сигнатуре $s$, то мы можем добавить в схему эффектов утверждение $f_s (x_{i_1}, \ldots, x_{i_r}) \rightarrow e_j$, где $f_s$ -- соответствующая сигнатуре $s$ булева функция.

Таким образом, можно сформулировать алгоритм:

\begin{minted}{text}
Input: A - схема, S - множество сигнатур
Output: схема, описывающее подмножество эффектов A

Algorithm ApproximateEffectSchema(A, S) {
    #$x_1, x_2, \ldots, x_n \leftarrow $# <переменные, соответствующие всем вызовам операторов>
    #$e_1, \ldots, e_m \leftarrow $#  <переменные, соответствующие всем эффектам>
    A' #$\leftarrow$# <пустая схема>
	
    for ( #$(i_1, \ldots, i_k) \in 2^{\overline{1..n}}$# ) {
        for ( e #$\in \{ e_1, \ldots, e_m \}$# ) {
            for (s #$\in$# S) {
                if (CheckConformingSignature(#$\{ x_{i_1}, \ldots, x_{i_k} \}$#, e, s, A) {
                    добавить утверждение "#$f_s(x_{i_1}, x_{i_2}, \ldots, x_{i_k}) \rightarrow e$#" в A
                }
            }
        }
    }
	
    return A'
}
\end{minted}

Проверку на то, что пара из набора переменных и эффекта удовлетворяет сигнатуре, вынесена в отдельную функцию для ясности:

\begin{minted}{text}
Input: Q - множество из k переменных из схемы A
       e - эффект из схемы A
       s - сигнатура
       A - схема эффектов
Output: true,     если пара (Q, e) удовлетворяет сигнатуре s
        false,    иначе

Algorithm CheckConformingSignature(Q, e, s, A) {
    for (q in <все возможные наборы значений переменных из Q>) {
        signatureResult #$\leftarrow$# s(q)
        schemaResult #$\leftarrow$# A(q)
        if (signatureResult != schemaResult) {
            return false
        }
    }
    return true
}
\end{minted}

Заметим, что, как мы уже говорили, на практике арность сигнатур из $S$ ограничена некоторым небольшим значением $r$. Следовательно, в цикле, перебирающем все подмножества входных переменных, можно ограничиться лишь перебором подмножеств мощностью не более чем $r$. Таким образом, сложность $AprroximateEffectSchema$ составляет:

$$\bigo{\big(\sum \limits_{i = 0}^r 2^{i}\big) \cdot |E| \cdot |S| \cdot CheckConformingSignature}$$, где $|E|$ -- количество эффектов в схеме $A$.

Для того, чтобы оценить сложность $CheckConformingSignature$, заметим, что каждый ее вызов занимает $\bigo{2^i \cdot |A|}$, где $i$ -- размер рассматриваемого набора, а $|A|$ -- размер схемы (поиск результата сигнатуры в схеме линеен по ее размеру). Получаем:

$$\bigo{\big(\sum \limits_{i = 0}^r 2^{i}\big) \cdot |E| \cdot |S| \cdot \big(\sum \limits_{i = 0}^r 2^{i} \cdot |A| \big)}$$

Объединяя суммы и вынося независимый от итерации множитель, получаем:

$$\bigo{\big(\sum \limits_{i = 0}^r 4^{i}\big) \cdot |E| \cdot |S| \cdot |A| }$$

Вычислив сумму геометрического ряда и оценив $|E|$ как $|A|$ сверху, получаем:

$$\bigo{4^{r} \cdot |A|^2 \cdot |S| }$$

Как мы видим, данный алгоритм очень быстро растет при увеличении арности рассматриваемых сигнатур, поэтому разумно ограничиться достаточно малыми арностями, не превосходящими 3. Кроме того, данный алгоритм квадратичен по размеру схемы, но это не является серьезной проблемой, т.к. если мы будем стараться сжать схему всеми возможными способами после каждого сглаживания, то можно верить, что схемы, с которыми мы будем работать, не будут слишком большими.