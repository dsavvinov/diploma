\section{Устройство систем условных эффектов}

\subsection{Основные понятия}

\subsubsection{Понятие условного эффекта}

Центральным определением в данной работе, является, разумеется, \term{эффект}. Однако несмотря на то, что это определение, судя по всему, было введено еще на заре развития программирования (так, ранние работы по аксиоматизации программирования уже ссылаются на этот термин без отдельного его введения \cite{Hoare69, Schwartz67}), общепринятой формулировки за все это время не появилось. 

В классических источниках, под эффектом чаще всего понимают <<некоторое видимое изменение в окружении>> \cite{Luc88}, или даже еще более конкретно <<изменение в памяти программы>> \cite{Vak09}. Некоторые исследователи и вовсе ограничивают это определение до <<чтения или записи в изменяемое состояние программы>> \cite{Green99}. Это можно резюмировать следующим образом:

\begin{definition}
    \label{def-effect-1}
    \term{Эффектом} называется некоторое изменение, производимое подпрограммой в состоянии вычислителя (кроме возвращения подпрограммой значения).
\end{definition}

Другие же авторы употребляют более широкую трактовку <<эффекта>> \cite{Nielson99}: 

\begin{definition}
    \label{def-effect-2}
    \term{Эффектом} является описание действий, происходящих в ходе выполнения подпрограммы.
\end{definition}

Разумеется, формулировка \ref{def-effect-2} является слишком широкой -- вплоть до того, что под нее подходит непосредственно исходный код тела функции. С другой же стороны, формулировка \ref{def-effect-1} является нежелательно узкой в контексте данной работы. Поясним это на примере:

\begin{minted}{kotlin}
    fun always42(): Int {
        return 42
    }
\end{minted}

Мы бы хотели говорить, что данная функция имеет эффект <<Всегда возвращает число 42>>. Однако это действие не подходит под определение эффекта \ref{def-effect-1}. Мы могли бы отказаться от специального случая для возвращаемых значений в этой формулировке, но в дальнейшем мы встретим некоторые утверждения, которые мы тоже хотели бы называть эффектами, но которые не описывают вообще никакого изменения в состоянии вычислителя.

Поэтому нам понадобится определение, чуть более слабое, чем определение \ref{def-effect-1}, но при этом не являющееся чересчур расплывчатым, как \ref{def-effect-2}. Мы сформулируем его следующим образом:

\begin{definition}
    \label{def-effect}
    \term{Эффект} -- это некоторая информация об окружении, получаемая при выполнении подпрограммы.
\end{definition}

Т.к. это определение рассматривает только окружение, то сразу отпадают все слишком широкие его интерпретации. В частности, все, что подпрограмма делает со своими локальными переменными, не подходит под это определение -- что очень удобно, т.к. изменения в локальных переменных нас никоим образом не интересуют.

С другой стороны, это определение включает в себя определение \ref{def-effect-1}, т.к. <<изменение в состоянии>>, несомненно, является <<информацией об окружении>>.

Наконец, как мы увидим чуть позже, под это определение подходят и довольно нестандартные действия, которые нам будет удобно считать эффектами во имя общности подхода.

\bigskip

Однако, даже такое, слегка расширенное понятие эффекта недостаточно для того, чтобы формализовать устройство многих функций. 

Для примера рассмотрим следующую функцию, которая является тривиальной оберткой над проверкой переменной на принадлежность строковому типу:

\begin{minted}{kotlin}
fun isString(x: Any?): Boolean {
    return (x is String)
}
\end{minted}

Мы бы хотели отразить тот факт, что функция возвращает \code{true} тогда и только тогда, когда \code{x} является \code{String}. Для этого формализуем понятие условного эффекта:

\begin{definition}
    \label{def-cond-effect}
    \term{Утверждением} будем называть пару $(c, e)$, где $e$ -- эффект, а $c$ -- некоторый набор условий. Семантика этой пары такова, что эффект $e$ имеет место тогда, когда $c$ выполняется.  
    
    В дальнейшем мы будем иногда называть условие $c$ \term{посылкой}, и записывать эту пару следующим образом: $c \to e$.
   
\end{definition}

Отметим, что обычные эффекты естественным образом выражаются через условные, если в качестве посылки использовать выражение, которое всегда выполняется (немного забегая вперед, скажем, что в качестве такого выражения мы будем использовать \code{true}, т.е. логическую истину).



\subsubsection{Понятие схемы эффектов}


Итак, у нас есть понятие <<утверждение>>, описывающее условный эффект. Однако этого еще недостаточно для наших целей. Достаточно взглянуть даже на очень простой пример с функцией \code{isString(x)}, выдающей результат проверки аргумента на принадлежность строковому типу, чтобы понять, что утверждения часто используются в группах. Так, чтобы описать поведение функции \code{isString(x)}, на самом деле необходимо два утверждения:

\begin{itemize}
    \item Если \code{x is String} верно, то функция возвращает \code{true}
    
    \item Если \code{x is String} неверно, то функция возвращает \code{false}
\end{itemize}

Поэтому в рамках данной работы было введено понятие \term{схемы эффектов}, формализующее данную идею:

\begin{definition}
    \term{Схемой эффектов} называется набор \emph{независимых} утверждений, описывающих условные эффекты некоторого участка кода.
\end{definition}

Обратим внимание, что определение говорит, о \emph{независимости} утверждений в схеме, т.е. исполнение или неисполнение некоторого конкретного утверждения не влияет на другие. Важно понимать, что при этом может быть верным буквально \emph{любое} подмножество утверждений, в том числе и пустое.

Также заметим, что используя независимые утверждения, легко выразить случаи, когда выполнение одного условия влечет сразу несколько эффектов -- для этого достаточно выписать несколько утверждений с одним и тем же условием и разными эффектами.

Важно понимать, что схема эффектов не обязана описывать все эффекты вычисления, и в этом смысле она является не полной спецификацией. С другой стороны, если уж какой-то эффект был упомянут, должны быть полностью описаны все условия, которые его вызывают -- т.е., относительно конкретного эффекта схема обязана быть полной.

Это вполне логично, если вспомнить \name{Checker Framework} и его архитектуру чекеров, каждый из которых представляет отдельно взятую систему эффектов. Функция не обязана перечислять свое поведение относительно каждого из существующих чекеров, но если уж она взялась специфицировать эффекты из некоторого чекера, эта спецификация должна быть корректна и полна -- иначе этот самый чекер не сможет выдать никакого адекватного анализа.

Таким образом, все эти оговорки нужны для того, чтобы, с одной стороны, не заставлять специфицировать абсолютно все поведение функции (что может быть довольно сложно), но, с другой стороны, чтобы имеющаяся спецификация была полезной.




\subsubsection{Краткая грамматика языка описания эффектов}

Теперь, определившись с основными понятиями, мы можем ввести грамматику для записи схем эффектов и утверждений. 
Для описания здесь будет использоваться синтаксис, близкий к EBNF (расширенной нормальной форме Бэкуса-Науэра). Мы будем придерживаться следующих соглашений:

\begin{itemize}
    \item Терминалы начинаются с большой буквы, например: \code{SimpleTerminal}
    
    \item Нетерминалы начинаются с маленькой буквы: \code{nonterminalSymbol}
    
    \item Каждая продукция начинается с двоеточия <<$\colon$>> и заканчивается точкой с запятой <<;>>
    
    \item Операторы <<|>>, <<*>>, <<+>>, <<?>> несут стандартный смысл альтернативы, итерации (ноль или более), итерации (один или более) или опции (один или менее) соответственно.
    
    \item Кроме того, мы будем писать $\alpha \{ \beta \}$, чтобы обозначить непустой список из символов $\alpha$, разделенных символом $\beta$. 
\end{itemize}

Мы приводим здесь неформальную грамматику, опуская технические детали вроде леворекурсивных правил, точных определений литералов, приоритетов и т.д. Также, в данной работе мы иногда будем немного вольно обращаться с некоторыми элементами синтаксиса во имя ясности записи (в частности, мы будем позволять иногда опускать скобки там, где это не может привести к двусмысленности).

Полная грамматика в синтаксисе \lang{ANTLR} приведена в приложении \ref{appendix-es-grammar}. 

\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}

\begin{minted}{antlr}

    effectSchema : statement{ EOL } ;
    
    statement : expression '->' effect{ ',' } ;
    
    expression : operator | Constant | Variable ;
    
    operator : isOperator | andOperator | orOperator | equalOperator ;
    
    effect : returnsEffect | throwsEffect | callsEffect ;
      
    // Операторы
    isOperator     : Variable 'is' Type ;
    andOperator    : expression '&&' expression ;
    orOperator     : expression '||' expression ;
    equalOperator  : expression '==' expression ;
    
    // Эффекты
    returnsEffect : 'Returns' '(' (expression | Wildcard)  ')' ;
    throwsEffect  : 'Throws'  '(' (Type       | Wildcard)  ')' ;
    callsEffect   : 'Calls'   '(' (Variable   | Wildcard) ',' Constant ')' ;
    
    // Терминалы
    Constant : <численная либо строковая константа> ; 
    Variable : <корректный идентификатор> ;        
    Type     : <корректный идентификатор> ;
    Wildcard : '???' ;
    EOL      : <разрыв строки> ;
    
\end{minted}

Семантика операторов:

\begin{itemize}
    \item \code{Is-оператор} -- выдает результат проверки переменной на принадлежность типу, подробнее см. в \cite{kotlin:typechecks}.
    
    \item \code{And-оператор} -- соответствует логической конъюнкции.
    
    \item \code{Or-оператор} -- соответствует логической дизъюнкции.
    
    \item \code{Equal-оператор} -- соответствует проверке на равенство (equality) в \lang{Kotlin}, подробнее см. в \cite{kotlin:equality}.
\end{itemize}

Семантика эффектов:

\begin{itemize}
    \item \code{Returns(x)} говорит, что данный участок кода при исполнении возвращает значение \code{x}.
    
    \item \code{Throws(e)} говорит, что в результате исполнения данного участка кода генерируется исключение \code{e}.
    
    \item \code{Calls(f, c)} говорит, что в результате исполнения данного участка кода \code{c} раз будет вызвана функция \code{f}.
\end{itemize}

Кроме того, нам понадобилось ввести особый символ подстановки <<???>>, означающий неизвестность. Он необходим для того, чтобы можно было записать утверждения вроде: \code{Returns ???} (<<участок кода завершается успешно, но конкретное возвращаемое значение неизвестно>>), или \code{Throws ???} (<<участок кода завершается неуспешно>>). Особенно большое значение наличие таких конструкций будет иметь при извлечении полезной информации из системы эффектов, о чем мы будем говорить в главе 3.

Заметим, что приведенная выше грамматика естественным образом индуцирует дерево, которое мы будем называть \term{деревом схемы эффектов}, или просто \term{дерево схемы}. Фактически, если рассматривать схему как некоторое выражение в грамматике, определенной выше, то дерево этой схемы соответствует дереву разбора этого выражения, из которого удалены все узлы-литералы (такие как разделители, скобки и т.д.). 


\subsubsection{Изоморфизм схем}

В будущем мы будем определять некоторые трансформации над схемами эффектов. Большинство этих трансформаций в каком-то смысле будут изменять лишь структуру схему, оставляя заложенную в нее информацию неизменной. Опять же, мы могли бы дать полностью формальное определение этому понятию, но это потребовало бы непропорционально больших усилий, поэтому ограничимся интуитивным:

\begin{definition}
    Будем говорить, что схемы $A$ и $B$ являются \term{изоморфными}, если они описывают один и тот же набор условных эффектов. Трансформацию, которая переводит схему $A$ в схему $B$ будем называть \term{изоморфизмом схем}.
\end{definition}

Интуитивно, мы можем спокойно заменить схему изоморфной, и это никак не повлияет на результаты анализа кода, полученные с помощью этой схемы. Например, следующие две схемы являются изоморфными, хотя с чисто синтаксической точки зрения в них записаны разные утверждения:

\schema{A}
{
    \es{x == true && y is Int}   $\rightarrow$ \es{Returns 1} \\
    \es{x == false || y !is Int} $\rightarrow$ \es{Returns 0} \\
}{}

\bigskip

\schema{B}
{
    \es{!(x == false || y !is Int)} $\rightarrow$ \es{Returns 1} \\
    \es{!(x == true && y is Int)}   $\rightarrow$ \es{Returns 0}
}
{}



\subsubsection{Примеры}

Теперь мы ввели все необходимые понятия для того, чтобы научиться аннотировать некоторые функции с не слишком сложными контрактами (в частности, обсуждение уточнений типов в коллекциях мы на некоторое время отложим). В данном разделе мы приведем несколько примеров для того, чтобы наглядно продемонстрировать работу с описанным синтаксисом и терминами.

Начнем с рассмотрения уже использовавшейся нами не раз функции \code{isString(x)}:

\begin{minted}{kotlin}
    fun isString(x: Any?): Boolean {
        return (x is String)
    }
\end{minted}

Ей соответствует следующая схема:

\schema{isString}{
      \es{x is String} $\rightarrow$ \es{Returns true} \\
      \es{x !is String} $\rightarrow$ \es{Returns false} \\
}
{}

Как мы видим, эта схема в точности передает контракт \code{isString(x)}: функция возвращает \code{true} если переданный аргумент является подтипом \code{String} и возвращает \code{false} в противном случае. 

Заметим, что в силу того, что мы используем независимые утверждения, схема эффектов не отражает явным образом тот факт, что эти два утверждения описывают \emph{все} возможные результаты выполнения данной функции. Неявно это выражено тем, что для любого объекта \code{x} верно либо \code{x is String}, либо \code{x !is String}. 


\bigskip


Другой пример, который мы хотели бы выразить в системе эффектов, это функция \code{assert}. Мы уже упоминали это соглашение, и здесь мы повторим его: мы будем считать, что \code{assert} всегда генерирует исключение, если переданный аргумент равен \code{false}. На практике это верно, например, для различных тестовых фреймворков, типа \name{JUnit}.

\begin{minted}{kotlin}
    fun assert(cond: Boolean): Unit {
        if (!cond) {
            throw AssertionError("Assertion Failed")
        }
    }
\end{minted}

Этой функции соответствует следующая схема:

\schema{assert}{
        \es{cond == true}  $\rightarrow$ \es{Returns(Unit)} \\
        \es{cond == false} $\rightarrow$ \es{Throws AssertionError}
}
{}

Эта запись отражает контракт функции \code{assert}: она завершается успешно тогда и только тогда, когда аргумент равен \code{true}. Опять же, факт того, что описание в схеме исчерпывающее, выражен неявно -- булева переменная либо истинна, либо ложна.


\bigskip


Наконец, рассмотрим функции типа \code{run}, которые в ходе своей работы вызывают некоторую другую детерминированное число раз:

\begin{minted}{kotlin}
    fun run(block: () -> Unit): Unit {
        block()
    }
\end{minted}

Этой функции соответствует схема:

\schema{run}{
        \es{true} $\rightarrow$ \es{Calls(block, 1)}
}
{}

Данная запись отражает то, что функция \code{run} \emph{всегда} (посылка \code{true} всегда истинна) вызывает переданный аргумент \code{block} ровно один раз.

Отметим, что в данном случае схема специфицирует лишь \emph{часть} контракта функции. В частности, она не отражает тот факт, что функция завершается успешно тогда и только тогда, когда успешно завершается вызов \code{block()}.








\subsection{Использование схем эффектов}

\subsubsection{Подстановка аргументов}

\label{section-arguments-substitution}

Мы научились описывать базовые схемы эффектов для функции. При этом мы не заостряли внимание на том, что все эти схемы используют \emph{параметры} функции. С точки зрения формализма, эти схемы не имеют смысла при вызове функции с конкретными аргументами. Действительно, пусть у нас есть схема для все той же функции \code{isString}:

\schema{isString(x)}
{
        \es{x is String} $\rightarrow$ \es{Returns true} \\
        \es{x !is String} $\rightarrow$ \es{Returns false}
}
{}

И пусть мы вызываем эту функцию в коде:

\begin{minted}{kotlin}
    val someValue: Any?
    <initialize x somehow>
    
    if (isString(someValue)) {
        println("someValue is String!")
    }
\end{minted}

Чисто формально, в строке 4 мы хотели бы получить схему, в которой используется \code{someValue}, а не \code{x}:

\schema{isString(someValue)}{
        \es{someValue is String} $\rightarrow$ \es{Returns true} \\
        \es{someValue !is String} $\rightarrow$ \es{Returns false}
}{}

Т.е. мы должны некоторым образом связать формальные параметры (в данном случае \code{x}) и аргументы, использованные при вызове (в данном случае \code{someValue}). Это довольно известный процесс \term{подстановки}, часто рассматриваемый, например, при описании лямбда-исчисления. 

Мы не будем здесь выписывать всю формалистику, связанную с этой операцией, поскольку она, во-первых, абсолютно схожа с процессом подстановки в лямбда-исчислении, а во-вторых, она потребует введения нескольких классических понятий (например, альфа-эквивалентности), совершенно излишних в контексте данной работы. 

В связи с этим, мы приводим здесь лишь интуитивное описание процесса подстановки, отсылая за подробностями в любой хрестоматийный труд по теории языков программирования, например, в \cite{TAPL}.

\begin{definition}
     Пусть схема $S$ записана для объявления некоторой функции с формальным параметром \code{x}. Будем говорить, что <<$S$ \term{абстрагирована} по \code{x}>>, а \code{x} -- \term{связана} в $S$.
     
     Тогда \term{подстановкой выражения $t$ вместо переменной \code{x} в схему $S$} будем называть схему $S[x \to t]$, которая в точности равна схеме $S$ за исключением того, что любое вхождение \code{x} в ней заменяется на выражение $t$. 
\end{definition}

Классически, при определении подстановки мы сталкиваемся с проблемой захвата переменной -- если схема $S$ абстрагирована по \code{x} и при этом содержит в себе другую схему $Q$, которая также абстрагирована по \code{x}, то подставлять $t$ вместо \code{x} в $Q$ некорректно. 

Обычно эта проблема решается с помощью простого наблюдения: имена связанных переменных не важны, и могут быть выбраны произвольно. Тогда мы можем переименовать все переменные так, чтобы все имена были уникальны. Этого весьма неформального утверждения будет достаточно для наших целей. 




\subsubsection{Сглаживание схем эффектов}

\label{section-flattening}

Теперь мы умеем использовать схемы эффектов в простых вызовах. Однако этого пока что недостаточно для практического использования: в частности, вложенные вызовы порождают вложенные схемы, работа с которыми неудобна:

\begin{minted}{kotlin}
    val x: Any?
    ...
    <initialize x somehow>
    ...
    assert(isString(y))
\end{minted}

При построении схемы для данного вызова необходимо выполнить две подстановки: сначала $isString[x \to y]$ (результат обозначим как $isString'$), потом $assert[cond \to isString']$. Более подробно:

\bigskip

\schema{isString(y)} {
        \es{y is String -> Returns true} \\
        \es{y !is String -> Returns false} \\
}{}

\bigskip 

\schema{assert(isString(y))} 
{
    \schema{isString(y)}
    {
        \es{y is String -> Returns true} \\
        \es{y !is String -> Returns false} \\
    }
    {
        \es{== true} $\rightarrow$ \es{Returns Unit} 
    }
    
    \\[2em]
    
    \schema
    {isString(y)}
    {
        \es{y is String -> Returns true} \\
        \es{y !is String -> Returns false} \\
    } 
    {
        \es{== false} $\rightarrow$ \begin{tabular}{l}
             \es{Throws} \\
            \es{AssertionError}
        \end{tabular}
    }
}
{}

При этом хотелось бы, чтобы схема для вложенного вызова отражала итоговую его семантику, а именно: вызов завершается успешно тогда и только тогда, когда \code{y} является \code{String}. На языке схем эффектов это будет выглядеть так:

\schema{assert(isString(y)}
{
    \es{y is String} $\rightarrow$ \es{Returns Unit} \\
    \es{y !is String} $\rightarrow$ \es{Throws AssertionError}
    
}{}

Для этого нам нужно ввести операцию \term{сглаживания} схем:

\begin{definition}
    Пусть $S$ -- некоторая схема эффектов. Тогда результатом \term{многошагового сглаживания} этой схемы будем называть схему $S_{flat}$, такую, что она не содержит вложенных схем эффектов и при этом изоморфна схеме $S$. Мы иногда будем называть $S_{flat}$ \term{плоской}.
\end{definition}

Мы хотели бы перейти к задаче \term{одношагового сглаживания}: требуется сгладить узел, такой, что некоторые его аргументы являются схемами эффектов, но при этом все эти схемы эффектов сами по себе уже являются плоскими. Это помогло бы нам тем, что имея операцию одношагового сглаживания, легко построить операцию многошагового сглаживания с использованием рекурсии:

\begin{minted}{text}
fun ManyStepFlatten(root) {
    for (i in 1 to |root.childs|) {
        v#$_i$#  #$\leftarrow$# root.childs[i]
        v'#$_i$# #$\leftarrow$# ManyStepFlatten(v#$_i$#) 
    }
    return OneStepFlatten(root, {v#$_1$#, v#$_2$#, #$\ldots$#, v#$_{|root.childs|}$#})
}
\end{minted}

Действительно, рано или поздно $ManyStepFlatten$ доберется до листьев иерархии, тем самым вырождаясь в вызов $OneStepFlatten$. Листья, при этом, разумеется, и так плоские, поэтому требование для $OneStepFlatten$ выполнено. При обратном ходе рекурсии требование плоскости аргументов $OneStepFlatten$ также будет выполняться согласно определению $ManyStepFlatten$. 

Осталось определить $OneStepFlatten$. Внимательное рассмотрение грамматики позволяет заметить, для этого достаточно определить $OneStepFlatten$ для трех случаев (одношаговое сглаживание плоских узлов выполняется тривиально):

\begin{enumerate}   
    \item Сглаживание оператора, хотя бы один из аргументов которого -- схема эффектов
    
    \item Сглаживание утверждения, посылка или заключение которого -- схема эффектов
    
    \item Сглаживание схемы эффектов, у которой хотя бы одно из утверждений является схемой эффектов.
\end{enumerate}

Сразу заметим, что одношаговое сглаживание схемы эффектов также определяется достаточно просто и соответствует объединению утверждений всех аргументов. 

Конечные версии этих алгоритмов, пригодных для использования на практике являются достаточно сложными и громоздкими. Поэтому мы сделаем следующие несколько предположений:

\begin{itemize}
    \item Все операторы бинарные
    
    \item При сглаживании оператора будем считать, что все его аргументы являются схемами эффектов (а не только некоторые)
    
    \item Все вычисления являются тотальными
\end{itemize}

Мы начнем с достаточно простого алгоритма, работающего только при выполнении этих предположений. Затем мы будем постепенно усложнять его, показывая, как можно отказаться от каждого из этих предположений.




\subsubsection{Сглаживание операторов. Базовый алгоритм}

Пассмотрим некоторый бинарный оператор $\alpha$. Пусть его аргументами являются два выражения $A, B$, с соответствующими схемами:

\schema{A}
{
    $c^A_1 \rightarrow e^A_1$ \\
    $c^A_2 \rightarrow e^A_2$ \\
    $\ldots$ \\
    $c^A_n \rightarrow e^A_n$ \\
}{}

\bigskip

\schema{B}
{
    $c^B_1 \rightarrow e^B_1$ \\
    $c^B_2 \rightarrow e^B_2$ \\
    $\ldots$ \\
    $c^B_m \rightarrow e^B_m$ \\        
}{}

Необходимо построить схему эффектов, соответствующую вычислению $\alpha(A, B)$. 



Сначала мы просто берем декартово произведение множеств утверждений схем $A$ и $B$, получая множество пар утверждений вида: 

$$A \times B = \big\{ (c^A_i \rightarrow e^A_i, c^B_j \rightarrow e^B_j) \rvert i \in 1 \ldots n, j \in 1 \ldots m \big\}$$

Можно видеть, что это множество пар содержит в себе \emph{практически} все возможные пары эффектов, которые могли быть сгенерированы при вычислении аргументов оператора. Более того, ко всем этим парам эффектов прикреплены условия, и для того, чтобы \emph{пара} эффектов выстрелила, необходимо, чтобы были выполнены \emph{оба соответствующих} условия. 

Можно также думать про эти пары как про возможные пути потока управления -- сначала управление заходит в аргумент $A$, выполняется одно из условий $c^A_i$, выстреливают эффекты $e^A_i$, затем выполняется одно из условий $c^B_j$ и выстреливают соответствующие эффекты $e^B_j$. Таким образом, на этом пути вычисления верны условия $c^A_i$ и $c^B_j$ и генерируются эффекты $e^A_i, e^B_j$.

Рассуждения выше должны были подвести к следующему преобразованию, которое склеивает пару утверждений в одно:

$$ (c^A_i \rightarrow e^A_i, c^B_j \rightarrow e^B_j) \Rightarrow c^A_i \land c^B_j \rightarrow e^A_i, e^B_j $$

Однако здесь пока что еще нигде не появился оператор $\alpha$. Вообще говоря, мы никак не ограничивали то, что оператор может сделать с аргументами, поэтому в целом мы должны сказать, что затем это утверждение подвергается преобразованию $\alpha$, определяемому самим оператором:

$$ \alpha(c^A_i \land c^B_j \rightarrow e^A_i, e^B_j) $$ 

Здесь мы могли бы и закончить, сказав, что результат этого преобразования может быть абсолютно произвольным, с любым изменением структуры утверждения, вплоть до полного его удаления.

Тем не менее, практика показывает, что большинство операторов устроены достаточно просто и такая общность является излишней. В частности, все операторы, которые будут рассмотрены в этой работе, действуют только и исключительно на заключения, оставляя посылки нетронутыми.

В этом есть некоторая логика, поскольку мы здесь интересуемся наблюдаемыми эффектами при вычислении оператора $\alpha$. Запись $c^A_i \land c^B_j \rightarrow e^A_i, e^B_j$ говорит нам, что аргументы этого оператора при выполнении условий $c^A_i \land c^B_j$ влекут эффекты $e^A_i, e^B_j$. Но это еще не означает, что мы обязательно пронаблюдаем эти эффекты, т.к. между ними и наблюдателем еще стоит оператор $\alpha$. Очевидно, что этот оператор может повлиять на наблюдаемые эффекты (например, обработав летящее исключение). Но что более интересно, из такого объяснения должно стать ясно, что оператор не должен влиять на условия $c^A_i \land c^B_j$, потому что это свойство \emph{аргументов} оператора, но не его самого и даже не вычисления оператора на этих аргументах.

Таким образом, мы определим преобразование оператора более точно:

$$ \alpha(c^A_i \land c^B_j \rightarrow e^A_i, e^B_j) \equiv c^A_i \land c^B_j \rightarrow \alpha(e^A_i, e^B_j) $$

Что дает нам  следующую схему эффектов:

\schema{/$\alpha$/(A, B)}
{
    $c^A_1 \land c^B_1 \rightarrow \alpha(e^A_1, e^B_1)$ \\
    $c^A_1 \land c^B_2 \rightarrow \alpha(e^A_1, e^B_2)$ \\
    $\ldots$ \\
    $c^A_1 \land c^B_m \rightarrow \alpha(e^A_1, e^B_m)$ \\
    $c^A_2 \land c^B_1 \rightarrow \alpha(e^A_2, e^B_1)$ \\
    $c^A_2 \land c^B_2 \rightarrow \alpha(e^A_2, e^B_2)$ \\
    $\ldots$ \\
    $c^A_n \land c^B_m \rightarrow \alpha(e^A_n, e^B_m)$ \\
}{}

Заметим, что данный алгоритм естественно обобщается на операторы другой арности -- для оператора арности $r$ и аргументов $A_1, A_2, \ldots, A_r$ следует просто взять за основу $r$-местное декартово произведение $A_1 \times A_2 \times \ldots \times A_r$. Таким образом, мы уже отказались от предположения, что все операторы бинарные.

\bigskip

Остается еще один небольшой нюанс. Мы сказали, что декартово произведение $A \times B$ содержит <<почти>> все эффекты вычисления аргументов $A$ и $B$. Какие же эффекты были упущены? Для ответа на этот вопрос вспомним, что возможны такие корректные состояния контекста, что ни одно из утверждений схемы не выполняется.

Перенося это на наш конкретный случай, это означает, что могут существовать такие состояния контекста, что ни одно из $c^A_i$ не выполняется, но выполняются некоторые $c^B_j$. Отсюда мы бы могли наивно заключить, что вычисление аргументов оператора влечет соответствующие эффекты $e^B_j$, и записать $c^B_j \rightarrow e^B_j$. Однако это было бы, конечно, неверно. Действительно, вычисление аргумента $A$ могло скрывать некоторые другие эффекты, и выполнение условия $c^B_j$ влечет эффекты $e^B_j$ \emph{и еще какие-то неизвестные}, в то время как чуть ранее мы договорились, что запись $c^B_j \rightarrow e^B_j$ говорит о том, что выполнение условия $c^B_j$ влечет \emph{только} эффекты $e^B_j$.

Потенциально, мы могли бы все-таки попытаться побороться за эти эффекты, но для этого потребуется введение новых понятий, либо расширение старых. По этой причине мы оставим попытки учесть такие эффекты. Схема, построенная по описанию выше, конечно, по-прежнему будет консервативным приближением динамического поведения соответствующего участка кода. 




\subsubsection{Приведение к схеме}

Покажем, как отказаться от предположения, что все аргументы операторов являются схемами эффектов. Для этого вспомним еще раз рекурсивный алгоритм сглаживания:

\begin{minted}{text}
    fun ManyStepFlatten(root) {
        for (i in 1 to |root.childs|) {
            v#$_i$#  #$\leftarrow$# root.childs[i]
            v'#$_i$# #$\leftarrow$# ManyStepFlatten(v#$_i$#) 
        }
        return OneStepFlatten(root, {v#$_1$#, v#$_2$#, #$\ldots$#, v#$_{|root.childs|}$#})
    }
\end{minted}

Достаточно договориться, что $OneStepFlatten$ всегда возвращает схему эффектов, и тогда предположение о том, что при сглаживании оператора все его аргументы являются схемами, будет выполнено. Действительно, перед сглаживанием оператора на всех его аргументах (детях в дереве схемы) вызывается $ManyStepFlatten$, который после рекурсивных вызовов возвращает результат $OneStepFlatten$.

В свою очередь, $OneStepFlatten$ и так возвращает схемы эффектов при сглаживании операторов. Таким образом, остается лишь немного изменить операцию сглаживания на константах и переменных. Ранее мы говорили, что $OneStepFlatten$ ничего не делает с такими узлами, т.к. они и так являются плоскими. Теперь же $OneStepFlatten(v)$, где $v$ -- это константа или переменная, будет возвращать следующую схему: 

\schema{OneStepFlatten(v)}
{
	\es{true} $\rightarrow$ \es{Returns(v)}	
}{}

Действительно, с точки зрения эффектов константа или переменная $v$ ничем не отличается от константной функции, всегда возвращающей $v$, схема которой и записана выше. 

Таким образом, $OneStepFlatten$ всегда возвращает схему эффектов, следовательно, всегда возвращает схему эффектов $ManyStepFlatten$, следовательно, требование о том, что все аргументы оператора при сглаживании являются схемами, будет выполнено.


\subsubsection{Сглаживание в присутствии частичных вычислений}

У нас осталось одно предположение, которое не выполняется на практике -- а именно, то, что все вычисления являются тотальными, т.е. всегда завершаются успешно. Отказаться от него будет уже не так просто, как от предыдущих двух, потому что частичные вычисления вынуждают намного более аккуратно обращаться с эффектами и учитывать, что аргументы оператора вычисляются последовательно. 

Итак, рассмотрим бинарный оператор $\alpha$, аргументами которого являются два выражения $A, B$, с соответствующими схемами:

\schema{A}
{
	$c^A_1 \rightarrow e^A_1$ \\
	$c^A_2 \rightarrow e^A_2$ \\
	$\ldots$ \\
	$c^A_n \rightarrow e^A_n$ \\
}{}

\bigskip

\schema{B}
{
	$c^B_1 \rightarrow e^B_1$ \\
	$c^B_2 \rightarrow e^B_2$ \\
	$\ldots$ \\
	$c^B_m \rightarrow e^B_m$ \\        
}{}

Необходимо построить схему эффектов, соответствующую вычислению $\alpha(A, B)$, учитывая то, что вычисления могут обрываться, а аргумент $A$ вычисляется раньше аргумента $B$.

Сначала поймем, почему нас не устраивает старый алгоритм. Пусть где-нибудь в схеме $A$ есть утверждение $c^A_i \rightarrow $ \es{Throws Exception, Calls(f, 1)}, а где-нибудь в схеме $B$ есть утверждение $c^B_j \rightarrow$ \es{Calls(f, 2)}. Тогда старый алгоритм выдаст схему $\alpha(A, B)$, которая будет содержать утверждение $c^A_i \land c^B_j \rightarrow \alpha$\code{(Throws Exception, Calls (f, 1), Calls (f, 2))}. 

Нам же хотелось бы на выходе получить утверждение $c^A_i \land c^B_j \rightarrow$ \code{Throws Exception, Calls (f, 1)} -- обратите внимание, что эффект \code{Calls(f, 2)} здесь не появляется, т.к. он порождается вычислением аргумента $B$, которое не произошло из-за того, что вычисление аргумента $A$ сгенерировало ошибку. К сожалению, как бы ни было устроено преобразование $\alpha$, оно не сможет отделить корректные эффекты от некорректных -- на этом шаге уже потеряна вся информация, откуда пришел тот или иной эффект или условие.

Поэтому нам придется отступить на шаг назад. Вспомним, как было получено $\alpha(A, B)$. Сначала формировались все возможные пары утверждений $A \times B$:

$$A \times B = \big\{ (c^A_i \rightarrow e^A_i, c^B_j \rightarrow e^B_j) \rvert i \in 1 \ldots n, j \in 1 \ldots m \big\}$$

Затем каждая пара преобразовывалась в одно утверждение:

$$ (c^A_i \rightarrow e^A_i, c^B_j \rightarrow e^B_j) \Rightarrow c^A_i \land c^B_j \rightarrow e^A_i, e^B_j $$

Именно на этом шаге была внесена непоправимая ошибка. Вводя данное преобразование, мы приводили аналогию с путями исполнения -- поскольку ранее мы считали, что все вычисления тотальны, то было корректно считать, что после $c^A_i \rightarrow e^A_i$ управление передается в $c^B_j \rightarrow e^B_j$. Сейчас это не так, и необходимо аккуратнее учесть специфику частичных вычислений.

Для этого мы выделим эффекты \code{Throws} и \code{Returns} в отдельную группу, и будем называть их \term{исходами}. Мы будем делить все исходы на \term{успешные} (\code{Returns}) и \term{неуспешные} (\code{Throws}). Теперь мы можем более аккуратно сформулировать преобразование $Seq$, которое берет два утверждения, выполняющихся последовательно, и формирует из них одно:

\[
Seq(c_1 \rightarrow e_1, c_2 \rightarrow e_2) = 
\begin{cases}
c_1 \land c_2 \rightarrow e_1, e_2 & \text{если } e_1 \text{ содержит успешный исход} \\
c_1 \rightarrow e_1 			   & \text{иначе}
\end{cases}
\]

Таким образом, результирующая схема $\alpha(A, B)$ будем выглядеть следующим образом:

\schema{/$\alpha$/(A, B)}
{
	 $\alpha\Big(Seq (c^A_1 \rightarrow e^A_1, c^B_1 \rightarrow e^B_1) \Big)$ \\
	 $\alpha\Big(Seq (c^A_1 \rightarrow e^A_1, c^B_2 \rightarrow e^B_2) \Big)$ \\
	 $\ldots$ \\
	 $\alpha\Big(Seq (c^A_1 \rightarrow e^A_1, c^B_m \rightarrow e^B_m) \Big)$ \\
	 $\alpha\Big(Seq (c^A_2 \rightarrow e^A_2, c^B_1 \rightarrow e^B_1) \Big)$ \\
	 $\ldots$ \\
	 $\alpha\Big(Seq (c^A_n \rightarrow e^A_n, c^B_m \rightarrow e^B_m) \Big)$ \\
}
{}


\subsubsection{Сглаживание утверждений}

В целом, процедура сглаживания утверждений очень похожа на процедуру сглаживания операторов, но она обладает рядом чисто технических тонкостей, о которых нельзя не упомянуть.

Пусть дано утверждение, заключением которого является набор эффектов $I$, а посылкой -- схема эффектов $A$, определенная следующим образом:

\schema{A}
{
	$c^A_1 \rightarrow e^A_1$ \\
	$c^A_2 \rightarrow e^A_2$ \\
	$\ldots$ \\
	$c^A_n \rightarrow e^A_n$ \\
}{}

Мы бы хотели как можно больше переиспользовать алгоритм сглаживания операторов. Заключение $I$ легко выразить в форме эквивалентной схемы эффектов с одним утверждением <<\code{true -> I}>>, и тогда на это можно смотреть как на еще один бинарный оператор <<$\rightarrow$>>. Однако у него есть своя специфика, связанная с тем, что ложная посылка не влечет заключения. Другими словами, при сглаживании утверждений \code{Returns(false)} является своего рода \emph{неуспешным} исходом. 

При этом нужно учитывать, что утверждения с неуспешным исходом раньше добавлялись в результирующую схему <<как есть>>: $Seq(c^A_i \rightarrow e^A_i, c^B_j \rightarrow e^B_j) = Seq(c^A_i \rightarrow e^A_i)$, если $e^A_i$ содержит неуспешный исход. Теперь же если этот исход \code{Returns(false)}, то необходимо аккуратно удалить \code{Returns(false)} из списка эффектов $e^A_i$, потому что этот \code{Returns} не имеет отношения к результирующей схеме. 

Если $E$ -- список эффектов, а $e$ -- отдельный эффект, то будем обозначать $E \setminus e$ список $E$ без эффекта $e$.

Таким образом, для стрелки импликации $Seq_{impl}$ определен следующим образом

\[
\begin{split}
    Seq_{impl}(c_1 & \rightarrow e_1, c_2 \rightarrow e_2) = \\
    & = \begin{cases}
        c_1 \land c_2 \rightarrow e_1, e_2 & \text{если } e_1 \text{ содержит успешный исход} \\
        c_1 \rightarrow e_1 \setminus Returns(false) & \text{если } e_1 \text{ содержит Returns(false)} \\
        c_1 \rightarrow e_1							 & \text{иначе}
    \end{cases}
\end{split}
\]



\subsubsection{Примеры преобразований операторов}

Теперь нам осталось лишь определить семантику преобразований операторов. Большинство преобразований устроены очень просто, и причину этого мы уже отметили, когда рассматривали \name{Checker Framework} -- зачастую эффекты приносят с собой некоторые связанные операторы, и вместе образуют замкнутую систему, которая очень мало взаимодействует с остальными. 

Таким образом, для значительной части преобразований $\alpha(e_1, e_2, \ldots, e_n)$ большинство эффектов будет прозрачно <<подниматься>> через преобразование: $\alpha(e_1, e_2, \ldots, e_n) = e_1, e_2, \ldots, \alpha(e_i, e_{i + 1}, \ldots, e_j), \ldots e_n$.

Например, операторы \code{\&\&}, \code{||}, \code{==}, \code{is}, \code{!}, \code{is} образуют естественную группу вместе с эффектами, которые говорят про возвращаемое значение (\code{Returns}) и работают только с ними. Для них всех преобразование состоит в том, что оператор <<проваливается>> внутрь эффекта: 

\[
\begin{aligned}
	\es{\&\&(Returns(x), Returns(y))} & \equiv \es{Returns (x \&\& y)}    \\
	\es{||(Returns(x), Returns(y))}   & \equiv \es{Returns (x || y)}    \\
	\es{==(Returns(x), Returns(y))}   & \equiv \es{Returns (x == y)}    \\
	\es{is}_{type} \es{(Returns(x))}  & \equiv \es{Returns (x is type)} \\
	\es{!(Returns(x))} 				  & \equiv \es{Returns (!x)}
\end{aligned}
\]

А вот эффект \code{Calls} вообще не требует для работы с ним никаких дополнительных операторов -- поэтому и правил работы с ним никаких нет, достаточно заложенных в систему алгоритмов комбинации. 

Следует понимать, что хотя каждый оператор в отдельности и работает лишь с фиксированной группой эффектов, <<интересных>> ему, то, что он делает с этой группой и как ее выбирает, остается полностью в его юрисдикции. Выше мы видели, что оператор может выбрать несколько эффектов и слить их в один. Оператор может и удалять эффект (например, если бы ввели оператор \code{Catch E}, соответствующий аналогичной конструкции -- он бы удалял эффект \code{Throws E} из списка), а может и добавлять. Это следует учитывать при реализации системы эффектов на практике.



\subsection{Уменьшение размера схем эффектов}

\label{section-schemas-reducing}

\subsubsection{Проблема роста размера схем}

Если мы еще раз внимательно взглянем на алгоритм комбинирования схем, представленный в предыдущем разделе, то легко видеть, что при комбинировании схем размера $\bigo{n}$, $\bigo{m}$ мы получаем схему размера $\bigo{n \cdot m}$. Такие комбинирования возникают при вложенных вызовах, но важно понимать, что итоговая длина зависит от устройства схем и \emph{не ограничена} сверху произведением всех использованных схем. 

Действительно, рассмотрим функции \code{f(x, y, z)}, \code{g()}, \code{h()}, \code{r()} (типы опущены для ясности). Пусть размеры схем имеют сложность $\bigo{F}$, $\bigo{G}$, $\bigo{H}$, $\bigo{R}$ соответственно. Рассмотрим вызов \code{f(g(), h(), r())}. 

Пусть схема для \code{f} содержит утверждение вида \code{(x == y) \&\& (y == z)}. После выполнения подстановки это утверждение превращается в \\
\code{(g() == h()) \&\& (h() == r())}, которое нуждается в сглаживании. 

Сглаживание выражения \code{g() == h()} дает схему сложностью $\bigo{G \cdot H}$, а сглаживание выражения \code{h() == r()} дает схему сложностью $\bigo{H \cdot R}$. Наконец, сглаживание оператора \code{==} дает схему сложностью $\bigo{G \cdot H^2 \cdot R}$. Если каждое утверждение в $F$ имеет подобную структуру, то в итоге получаем схему сложностью $\bigo{F \cdot G \cdot H^2 \cdot R}$, что \emph{больше}, чем просто произведение всех схем.

Оценку сверху можно получить, если представить схему $f$ в виде дерева с $\bigo{F}$ узлами, а схему $g$ в виде дерева с $\bigo{G}$ узлами. Тогда операция подстановки заменяет некоторые узлы в дереве $f$ на дерево $g$, и верхняя оценка для такой подстановки будет $\bigo{G^F}$ (заметим, что такая оценка является даже недостижимой, поскольку в реальности в некоторые узлы подстановка не может осуществляться -- например, в узлы, соответствующие операторам)

Подобная проблема характерна для условных эффектов при последовательном комбинировании -- например, при обзоре литературы мы уже видели экспоненциальный взрыв длины эффектов в статье \name{Types for Atomicity} \cite{Flanagan08}. Однако там из-за простого устройства условий (они все имеют вид <<Владеет ли функция некоторым набором блокировок?>>) авторам удалось справиться с этой проблемой. В нашем случае, надеяться на простое решение не стоит, т.к. в представленной системе условия могут представлять собой весьма нетривиальные комбинации из операторов, переменных, вызовов и т.д.

В связи с этим, в этом разделе мы поговорим о двух подходах к уменьшению размера схем. Один из них будет уменьшать размер схем без потери информации и будет, по большому счету, заниматься вычислением констант или приведении эффектов к некоторому каноническому виду. Кроме того, мы опишем второй подход, который потенциально может сжимать схемы намного сильнее, но ценой этому будет потеря информации. 


\subsubsection{Сокращение схем эффектов}

Если в схеме встречаются константы, то можно надеяться, что в схеме можно провести некоторые очевидные сокращения, основанные на знании о том, как операторы работают со своими аргументами.

Например, если у нас есть выражение вида \code{false \&\& x}, то очевидно, что оно вычисляется в \code{false} вне зависимости от того, чему равна переменная \code{x}. Таким образом, мы получаем следующий набор безопасных преобразований:

\begin{enumerate}
	\item Сокращение логических операторов:
	
	\es{false && x} $\equiv$ \es{false}
	
	\es{x && false} $\equiv$ \es{false}
	
	\es{true || x} $\equiv$ \es{true}
	
	\es{x || true} $\equiv$ \es{true}
	
	\es{!true} $\equiv$ \es{false}
	
	\es{!false} $\equiv$ \es{true}
	
	\item Сокращение оператора проверки на равенство (неравенство):
	
	Если значения величин $x$ и $y$ точно известны, то \es{x == y} вычисляется в \es{true} или \es{false} в зависимости от того, как сравниваются на равенство соответствующие значения -- конкретные правила определяются языком. Значения могут быть известны, если $x$ и $y$ являются константами, или же переменные, про которые можно точно доказать, что они имеют то или иное значение. 
	
	\item Сокращение оператора проверки на подтипизацию:
	
	\es{x is T} может быть сокращено в \es{true} или \es{false}, если можно доказать, что \es{x} точно является или не является подтипом типа \code{T}. Также как и с оператором равенства, мы всегда знаем точный тип констант, но вот с переменными нужно быть аккуратнее. Конкретные правила зависят от конкретной системы типов -- например, в языках с полиморфизмом нужно помнить, что статический тип переменной может отличаться от динамического. 
	
	\item Сокращение стрелки импликации в утверждениях:
	
	Как мы уже говорили, ложные посылки не влекут следствие, поэтому утверждения вида <<\es{false} $\rightarrow$ \es{E}>> можно удалить из схемы эффектов
\end{enumerate}

Может показаться, что если в вызове не фигурируют константы, то пользы от этого подхода нет совсем, но на самом деле это не так -- константы могут появляться из схемы эффектов. Например, схема для функции \code{assert(x)} содержит выражения вида \code{x == true}. Если вместо \code{x} подставляется некоторая другая схема эффектов, в которой есть утверждения вида \code{Returns(false)} или \code{Returns(true)}, то в схеме, полученной после сглаживания, мы вполне можем увидить выражения вида \code{false == true} или \code{true == true}.

Таким образом, данный подход является вполне работоспособным для схем эффектов, которые используют константы -- и практика показывает, что такие схемы встречаются весьма часто.

Кроме того, заметим, что используя более сложные алгоритмы, можно развивать этот подход. Дело в том, что некоторые утверждение не являются независимыми -- например, выражения \code{x is String} и \code{x !is String} не могут быть верными одновременно, поэтому выражение вида \code{(x is String) \&\& (x !is String)} можно безопасно сократить до константы \code{false}. В данной работе мы не будем рассматривать подобные алгоритмы, отсылая читателя к классическим источникам \cite{McCluskey56} или же более современным работам \cite{Jain08}


\subsubsection{Аппроксимация схем эффектов}

Однако иногда сокращения схем оказывается недостаточно. Рассмотрим достаточно логичный и жизненный пример -- пусть есть какой-то очень сложный вызов с большой вложенностью, в недрах которого используется простая функция \code{assertNonNull(x)}, которая содержит утверждение \\ \code{x == null} $\rightarrow$ \code{Throws AssertionError}. Будем считать, что никакая другая функция не обрабатывает это исключение -- тогда и для всего вызова данное утверждение является корректным. Тем не менее, в силу сглаживания, это утверждение будет появляться повсюду вместе с некоторыми другими условиями и эффектами:

\schema{}{
	$\ldots$ \\
	\es{x == null && /$c_1$/} $\rightarrow$ \es{Throws AssertionError, /$e_1$/} \\
	\es{x == null && } $\overline{c_1}$ $\rightarrow$ \es{Throws AssertionError, /$e_2$/} \\
	$\ldots$
}
{}

Для данного вызова верно, что если \code{x == null}, то всегда генерируется исключение \code{AssertionError}, но эта информация выражена в схеме неявно из-за дополнительных условий и эффектов. На практике, простые и краткие утверждения являются намного более полезными и удобными, чем длинные и подробные. Этому есть некоторое интуитивное обоснование. 

Пусть весь вызов задействует переменные $x_1, x_2, \ldots x_n$, каждая из которых может принимать $D_1, D_2, \ldots D_n$ различных значений. Рассмотрим некоторое утверждение. Чем больше переменных задействовано в его посылке, тем меньшую долю всех входов покрывает это утверждение. Получается, что сами по себе длинные утверждения требуют больше памяти для хранения, больше времени для работы с ними, в то время как реально использоваться они будут реже. 

Для примера рассмотрим частный случай, когда $x_1$ является булевской переменной и $D_1 = 2$. Тогда утверждение, посылка которого имеет вид \es{x/$_1$/ == true}, выполняется для половины всех возможных наборов входных параметров, т.е. грубо говоря, оно будет полезно в каждом втором случае. 

Это неформальное рассуждение должно показать, что на практике вполне полезным преобразованием является замена множества длинных утверждений на одно короткое, пусть даже при этом мы потеряем некоторую информацию. Это преобразование мы будем называть \term{аппроксимацией} схем эффектов.

В целом, эта задача имеет непосредственное отношение к задаче аппроксимации булевых функций, для которой разработаны достаточно эффективные решения \cite{Blais13}. Здесь мы рассмотрим наиболее простой в реализации, не вдаваясь в подробности его свойств и сравнения с другими, существующими алгоритмами. Однако даже не смотря на его простоту, он требует введения ряда понятий и терминов, в которых можно легко <<потеряться>>. Поэтому мы будем рассматривать его работу на примере следующей схемы:

\schema{example}
{
	\es{x is String && x !is String} $\rightarrow$ \es{Returns(true)} \\
	\es{y == null && b == true} $\rightarrow$ \es{Throws IllegalArgumentException} \\
	\es{y == null && b == false} $\rightarrow$ \es{Throws IllegalArgumentException} \\
	\es{y != null && b == true} $\rightarrow$ \es{Returns(false)}
}
{}
\bigskip

Мы будем время от времени возвращаться к этой схеме, чтобы продемонстрировать некоторые понятия на ее примере. Подобные отступления будут выделены текстом в рамке.

\bigskip

Идея алгоритма состоит в следующем. Рассмотрим схему после сглаживания -- тогда посылка любого утверждения представляет собой набор операторов, соединенных логическими связками (отрицание, конъюнкция, дизъюнкция). Операторы, не являющиеся логическими связками, мы заменим на логические переменные $x_1, x_2, \ldots, x_n$. Одинаковым по содержанию операторам будут соответствовать одинаковые переменные. 

Кроме того, совместность логических переменных должна по возможности соответствовать совместности логических операторов -- т.е. если выражению \code{x is String} была назначена переменная $x_1$, то выражению \code{x !is String} должна быть назначена переменная $\overline{x_1}$, а не $x_2$. Разумеется, некоторые связи могут быть достаточно сложными для того, чтобы их так просто выявить, но с практической точки зрения, вполне достаточно рассмотреть простые случаи типа \code{is/!is}, \code{==/!=} и \code{true/false}.

Аналогично мы поступим и со всеми эффектами. После этого мы можем привести посылку к дизъюнктивной нормальной форме, и утверждения в схеме будут иметь вид логических формул вида $DNF(x_1, \ldots, x_n) \rightarrow e$.

\begin{framed}
	Для схемы $example$ мы заменяем операторы и эффекты на переменные следующим образом:
	
	\begin{tabular}{cc}
		\es{x is String}  & $x_1$ \\
		\es{x !is String} & $\overline{x_1}$ \\
		\es{y == null}    & $x_2$ \\
		\es{b == true} 	 & $x_3$ \\
		\es{b == false}   & $\overline{x_3}$ \\
		\es{y != null}    & $\overline{x_2}$ \\
		\es{Returns(true)} & $e_1$ \\
		\es{Throws IllegalArgumentException} & $e_2$ \\
		\es{Returns(false)} & $e_3$ 
	\end{tabular}
	
	После этого получаем следующий набор логических формул:
	
	\[
	\begin{aligned}
		x_1 \land \overline{x_1} & \rightarrow e_1 \\
		x_2 \land x_3 & \rightarrow e_2 \\
		x_2 \land \overline{x_5} & \rightarrow e_2 \\
		\overline{x_2} \land x_3 & \rightarrow e_3
	\end{aligned}	
	\]
\end{framed}

Мы фиксируем набор $S$ интересующих нас булевых функций.

\begin{framed}
	Для нашего примера мы рассмотрим две функции: одноместную  функцию $Id$, соответствующую тождественной функции, и нульместную функцию $False$, соответствующую тождественно ложной функции.
\end{framed}

После этого мы перебираем все возможные наборы значений для всех входных переменных, и для каждого набора выписываем, какие эффекты были сгенерированы при таких значениях, а какие нет. Интуитивно, мы получаем нечто вроде таблицы истинности для нескольких функций, каждая из которых соответствует какому-то эффекту. Наша дальнейшая задача будет заключаться в том, чтобы оставить только те эффекты, которые могут быть выражены через достаточно простые функции -- т.е., через функции из набора $S$.

\begin{framed}
	\begin{tabular}{c|c|c|c|c|c}
		$x_1$ & $x_2$ & $x_3$ & $e_1$ & $e_2$ & $e_3$ \\
		\hline
		0     & 0     & 0     &     0 & 0     & 0     \\
		0     & 0     & 1     &     0 & 0     & 1     \\
		0     & 1     & 0     &     0 & 1     & 0     \\
		0     & 1     & 1     &     0 & 1     & 0     \\
		1     & 0     & 0     &     0 & 0     & 0     \\
		1     & 0     & 1     &     0 & 0     & 0     \\
		1     & 1     & 0     &     0 & 1     & 0     \\
		1     & 1     & 1     &     0 & 1     & 0     \\
	\end{tabular}
\end{framed}

Для того, чтобы найти простые зависимости, мы перебираем все функции из $S$. Пусть мы зафиксировали функцию $s$ арности $r$. Мы бы сейчас хотели узнать -- нет ли в нашей схеме каких-нибудь $r$ переменных и какого-то эффекта, таких, что их связь описывается в точности функцией $s$. 

Давайте перебирать все наборы из $r$ переменных и эффекта. Зафкисируем пару $(x_{i_1}, \ldots, x_{i_r}; e_j)$. Как проверить, что зависимость между этими переменными и эффектом в действительности описывается функцией $s$? Интуитивно кажется, что для этого нужно проверить, что наличие либо отсутствие эффекта в схеме согласовано с выводом функции $s$ для любого набора значений переменных. 

Формулизуем это. Переберем $2^r$ возможных значений набора переменных $x_{i_1}, \ldots, x_{i_r}$. Для каждого набора есть его \term{результат функции $s$ на этом наборе}, который определяется тривиальным вычислением $s$ на этих аргументах. 

\term{Результат} же этого набора {в схеме относительно эффекта} $e_j$ определяется чуть-чуть более сложнее. Возьмем набор значений, и взглянем на те строчки, где он появляется. Если \emph{во всех} этих строчках эффект $e_j$ имеет одно и то же значение, то результатом этого набора относительно эффекта $e_j$ является это значение. В противном случае, этот набор значений \emph{не определяет} эффект $e_j$, и мы будем говорить, что результатом этого набора является \term{неизвестность}

\begin{framed}
	Например, результатом набора значений $x_2 = true, x_3 = false$ относительно эффекта $e_2$ является истина, поскольку в обоих строчках, в которых появляется этот набор, данный эффект имеет значение $1$.
	
	А вот набор значений $x_3 = true$ относительно этого же самого эффекта имеет значение <<неизвестность>>, поскольку, например, при $x_1 = 0, x_2 = 1, x_3 = 1$ получаем $e_2 = 1$, но при $x_1 = 0, x_2 = 0, x_3 = 1$ получаем $e_2 = 0$.
\end{framed}

Мы будем говорить, что пара $(x_{i_1}, \ldots, x_{i_r}; e_j)$ \term{описывается} функцией $s$, если для любого набора значений переменных $x_{i_1}, \ldots, x_{i_r}$ результат функции на этом наборе \emph{в точности} совпадает с результатом в схеме относительно эффекта $e_j$. 

Нетрудно видеть, что если пара $(x_{i_1}, \ldots, x_{i_r}; e_j)$ описывается функцией $s$, то мы можем добавить в результирующую схему утверждение вида \\ $s(x_{i_1}, \ldots, x_{i_r}) \rightarrow e_j$.


\begin{framed}
	Например, в рассматриваемом примере эффект пара $(\{x_2\}; e_2)$ описывается функцией $Id$. Пара $(\emptyset; e_1)$ описывается функцией $False$, что означает, что эффект $e_1$ никогда не генерируется.
\end{framed}

\bigskip

Мы не будем выписывать псевдокод данного алгоритма, поскольку выше мы привели очень подробное описание с примерами. Отметим, что построение таблицы истинности экспоненциально по количеству переменных в схеме. В свою очередь, потенциально это количество пропорционально размеру схемы. Может показаться, что данный алгоритм не особо решил проблему, поскольку экспонента в одном месте (при комбинации схем) была заменена экспоненту в другом месте (при аппроксимации). Тем не менее, на практике выигрыш получается довольно ощутимым за счет того, что после нескольких сглаживаний мы можем легко получить очень большую (по сравнению с исходной) схему, в то время как переменных в ней будет использоваться по-прежнему не так много.