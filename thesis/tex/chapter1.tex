\section{Анализ предметной области и существующих решений }


\subsection{Обзор существующих решений}


\subsubsection{Системы эффектов}

Системы эффектов появились в конце 80-ых годов как логичное развитие систем типов. Из-за этого, между системами типов и системами эффектов существует естественная связь, служащая источником для различных интуиций и полезных параллелей. Поскольку осознание этой связи значительно облегчает понимание любых фактов и свойств систем эффектов, ниже будет вкратце описано, откуда эта связь появляется.

\bigskip

В компьютерных программах существует два основополагающих понятия: это объекты, которые хранят информацию, и функции, которые что-то делают с объектами

Системы типов отвечают за информацию об объектах. Мы можем написать нечто вроде \code{a: Int}, и это будет означать, что в этой переменной хранится целое число.

Но мощь систем типов ограничена, когда речь заходит о функциях -- что и неудивительно, т.к. тип говорит о свойствах объекта, а не процедур. Отчасти проблема решается сигнатурами, но по сути, это всего лишь информация об аргументах и возвращаемом объекте, но никак не о том, что с ними делает функция. Так, сигнатура \code{void doSomething()} в \lang{Java} не дает никакой информации, и программисту остается лишь надеяться на адекватное название и комментарии в коде.

Отсюда и рождается идея эффектов и систем эффектов. Эффект для процедуры -- это тоже самое, что тип для объекта. Так, в одной из первых работ по системам эффектов, дается следующее определение:

\begin{definition}
  \term{Эффектом} выражения называется краткое описание всех наблюдаемых побочных эффектов, которые это выражение может вызвать при вычислении \cite{Luc88}.
  \label{def-effect}
\end{definition}

Традиционно для подобных исследований, авторы немного лукавят и не определяют <<побочный эффект>> строго, надеясь на интуицию читателя (в их оправдание скажем, что интуиция, скорее всего, не подведет). В главе 2 мы аккуратно разберемся со всеми этими понятиями и дадим точные определения. Пока же можно считать, что <<побочный эффект>> соответствует некоторому изменению в памяти программы.


Тесная связь между системами типов и системами эффектов сходу дает значительное количество полезных наблюдений. Чтобы подчеркнуть двойственность между этими двумя системами, эти наблюдения оформлены в таблицу \ref{types-effects-comparison}

\begin{table}
\begin{tabular}{ | p{0.4\linewidth} | p{0.4\linewidth} | }
  \hline
  Системы типов & Системы эффектов \\\hline

  Помогают предотвращать ошибки -- например, от сохранения строкового значения в тип \code{Int}.
  &
  Помогают предотвращать ошибки -- например, от использования функции, которая бросает исключение, вне блока \code{try-catch}.
  \\\hline

  Помогают компилятору -- например, знание о типе переменной может позволить хранить ее в памяти более оптимально.
  &
  Помогают компилятору -- например, знание о том, в какие переменные пишет функция и какие читает, может позволить переупорядочивание кода, ранее невозможное.
  \\\hline


  \multicolumn{2}{| p{0.8\linewidth + 2\tabcolsep}|}{Типы/эффекты могут быть либо явно написаны пользователем, либо выведены автоматически}

    \\\hline

    \multicolumn{2}{| p{0.8\linewidth + 2\tabcolsep} |}{Бывает полезной возможность введения пользовательских типов/эффектов}
  \\\hline

\end{tabular}
\label{types-effects-comparison}
\caption{Сравнение типов и эффектов}
\end{table}

\bigskip

Основопологающей работой является уже упомянутая несколько раз статья Lucassen, Gifford <<Polymorphic effect system>> (1988) \cite{Luc88}. В ней авторы описывают основы систем эффектов, предлагают формализм, схожий с формализмом систем типов, позволяющий описывать эффекты. Данное исследование является в большей степени математической формализацией концепта эффектов, нежели руководством к тому, как использовать этот концепт на практике.

С точки зрения практики, очень интересной является статья Greenhouse, Boyland <<An Object-Oriented Effect System>> (1999) \cite{Green99}. В ней авторы задаются уже вполне жизненными и насущными вопросами о применении систем эффектов в условиях объекто-ориентированного \lang{Java}-подобного языка. Так, рассмотрены проблемы наследования эффектов, инкапсуляции в присутствии эффектов.

Cледует отметить, что в этих двух статьях, как и в большинстве других, авторы уделают крайне мало внимания расширяемости системы по типам эффектов, и как следствие, по типам анализа, рассматривая простые \code{read/write} эффекты чтения-записи в перменную, которые отличаются очень простыми правилами комбинирования.

В качестве редкого примера эффектов, более интересных с концептуальной точки зрения, можно привести многопоточные условные эффекты из работы Flanagan, Freund, Lifshin <<Types for atomicity: Static Checking and Inference for Java>> (2008) \cite{Flanagan08}. Авторы ставят цель разработать систему эффектов, способную обнаруживать ошибки в программах на \lang{Java}, связанные с многопоточностью. В связи с этим вводится класс эффектов, связанных с различными типами многопоточного взаимодействия. Также очень интересно отметить, что здесь появляются некоторые простые условные эффекты, связанные с тем, что поведение многопоточных методов почти всегда зависит от владения той или иной блокировкой. Авторы сталкиваются с некоторыми проблемами, свойственными условным эффектам -- в частности, экспоненциальный взрыв длины аннотаций при последовательном комбинировании эффектов (мы подробней будем говорить об этом в главе 2).

Следует отметить замечательную особенность эффектов -- вычислительная сложность анализа зависит от количества аннотаций эффектов и их типов, но не от длины кода (разумеется, в отсутствии автоматического вывода эффектов). Таким образом, пользователь подобной системы <<платит только за то, что использует>>: работа с проектом без аннотаций будет очень похожа на то, как если бы системы эффектов не было вовсе. Более того, пользователь может захотеть проаннотировать только некоторую подсистему, либо же использовать ровно один простой тип эффектов (какие-нибудь проверяемые исключения) -- в том и в другом случае, он может легко получить желаемый результат без значительной платы процессорным временем.


\bigskip

Взглянем теперь в сторону практических реализаций систем эффектов.

Реализацией идеи систем эффектов по оригинальной статье является язык программирования FX-87 \cite{FX87}. К несчастью, этот язык на сегодняшний день уже не поддерживается и развивается (чему он, вероятно, в значительной степени обязан в высшей степени нечитаемому синтаксису). Кроме того, данный язык является функциональным, что еще более уменьшает актуальность этой реализации для настоящего исследования.

Намного более практико-ориентированной, и потому более интересной, явлется \name{Checker Framework} \cite{checker-framework}. Это фреймворк, построенный на основе JSR-308 \cite{JSR308}, и позволяющий организовывать небольшие системы эффектов на основе \lang{Java}-аннотаций. Кроме того, возможно аннотирование объектов. Фреймворк предоставляет набор готовых аннотаций, равно как и возможность задавать собственные.

\name{Checker Framework} построен на понятии \name{checker}-ов -- небольших модулей, отвечающих за решение одной конкретной задачи анализа (с чисто технической точки зрения, каждый такой модуль является процессором аннотаций). \name{Checker}-ы независимы друг от друга, и могут добавляться в систему по мере необходимости, что обеспечивает масштабируемость по типам анализа.

Полезным наблюдением, которое можно извлечь из принципа устройства \name{Checker Framework} является тот факт, что подавляющее большинство эффектов нетривиально взаимодействуют только с эффектами такого же типа и никак не влияют на все остальные - именно на этом основывается модульная структура с \name{checker}-ами. Это дает очень важное понимание того, насколько хорошо ведут себя системы эффектов при масштабировании -- добавление нового эффекта никак не зависит от количества уже существующих эффектов (при условии, что он с ними не взаимодействует, что чаще всего действительно так). Это второе очень важное свойство систем эффектов, помимо независимости вычислительной сложности анализа от длины кода.








\subsubsection{Контракты}

Подходом к той же самой проблеме, но несколько с другой стороны являются \term{контракты}.

\begin{definition}
  \label{def-contract}
  \term{Контракт} -- это формальная, точная и проверяемая спецификация программной единицы, описывающая ее взаимодействие с другими программными единицами \cite{Meyer92}
\end{definition}

Чаще всего в качестве программной единицы используется функция. Контракты для функций описываются предусловием, постусловием и инвариантом. Предусловие -- это набор ограничений на окружение, которые функция ожидает видеть выполненными. Постусловие -- это условия, которые функция обязуется выполнить, если было выполнено предусловие. Инвариант -- это условия, которые функция обязуется выполнять всегда.

Внимательно вдумавшись в определение \ref{def-contract}, можно заметить, что оно очень близко по смыслу к определению \ref{def-effect}. Это и не удивительно, т.к. оба метода ставят своей целью явно специфицировать межпроцедурные взаимодействия.  Отличие контрактов от эффектов заключается больше в синтаксисе записи и терминологии, нежели в концептуальных различиях. В достаточно мощной системе эффектов можно выразить понятие контракта, и обратно, с помощью контрактов и некоторого числа дополнительных конструкций можно записать эффекты функции. Разумеется, некоторые эффекты легче укладываются в концепцию контрактов, и наоборот.

Несмотря на схожесть контрактов и эффектов с точки зрения выразительности, между ними есть разница, если задуматься о чисто практических вопросах -- а именно, о том, какого рода утверждения нужно будет чаще формализовывать в рамках системы анализа.

Системы эффектов часто являются интуитивно понятными, когда каждый эффект говорит о наличии либо отсутствии некоторого четко определенного и кратко описываемого свойства у функции -- возможности бросить исключение, чистоты, и т.д. Само по себе свойство может быть довольно нетривиальным -- например, если пытаться формализовать понятие чистоты не используя непосредственно термин <<чистая функция>>, то придется формализовать довольно длинную мысль: <<на одним и том же наборе входных аргументов функция всегда возвращает одно и то же значение, и при этом выполнение функции никогда не вызывает наблюдаемых побочных эффектов>>. Однако важно, что будучи однажды введенным, это свойство записывается кратко и емко.

Контракты же удобны, если центральные понятия -- предусловия и постусловия -- будут часто использоваться. То же самое понятие чистоты функции никак не связано с предусловиями и постусловиями, и даже с понятием инварианта -- это просто неотъемлемое свойство функции. Некоторым расширением синтаксиса контрактов, конечно, можно его выразить ровно также, как и в эффектов -- но если в предметной области все утверждения похожи по своему устройству на чистоту, то смысла в контрактах остается не много.

Подводя итог, можно сказать, что в целом по своим свойствам контракты очень похожи на эффекты, а выбор конкретного подхода должен зависеть от предметной области и от того, какого рода утверждения будут чаще использоваться в итоговой системе.






\subsubsection{Анализ потока данных}

Анализ потока данных (англ. \eng{data-flow analysis}) является методом статического анализа, возникшим в результате развития компиляторов, и, как следствие, потребности в эффективном и практичном способе доказательства \emph{некоторых} свойств программы.

Отличие анализа потока данных от тех же языков спецификации заключается в том, что анализ потока данных не пытается доказать корректность программы в целом, а вместо этого сосредотачивается на некоторых, достаточно простых и полезных свойствах, например, константности переменных, типах и аттрибутах переменных, и т.д. \cite{Sharir78}

Мы будем достаточно подробно обсуждать детали работы анализа потока данных чуть позже, здесь же ограничимся тем, что он анализирует непосредственно исходный код. В этом его основное отличие от систем эффектов и контрактов -- анализ потока данных, с одной стороны, работает прозрачно для пользователя, не требуя от него никаких специальных аннотаций. С другой же стороны, это приводит к некоторых техническим ограничениям. В частности, отсутствие исходного кода делает анализ невозможным, что приводит к некоторым проблемам при использовании в языках с раздельной компиляцией.

Кроме того, как несложно догадаться, вычислительная сложность анализа потока данных растет вместе с размером анализируемого кода \cite{Sagiv96}. В связи с этим, на практике наиболее распространен внутрипроцедурный анализ потока данных, т.к. он значительно проще в реализации, и вместе с тем все равно позволяет получать довольно полезные на практике утверждения \cite{dragon-book}.

В контексте данной работы интерес представляет межпроцедурный анализ потока данных. Одним из наиболее логичных и распространенных методов борьбы с возрастающей сложностью при межпроцедурном анализе является <<сжатие>> информации о подпрограммах \cite{Weihl80, Barth78}. Суть достаточно проста -- вместо того, чтобы пытаться <<в лоб>> проанализировать код всей программы, мы заменяем все подпрограммы на некоторые краткие описания ее эффектов и взаимодействий, релевантных для конкретного типа анализа. После этого, межпроцедурный анализ начинает напоминать внутрипроцедурный -- при анализе конкретной подпрограммы, вместо кода использованных в ней других подпрограмм, используются полученные ранее краткие описания.

Как и следует ожидать, итоговые характеристики подобного подхода очень сильно зависят от того, как получаются эти <<краткие описания>>. По этой причине мы не будем подробно анализировать возможные виды межпроцедурного анализа, основанные на этой идее, поскольку этот анализ будет довольно точно следовать анализу конкретного метода, использованного для извлечения кратких описаний.




\subsubsection{Языки спецификаций}

\begin{definition}
  \term{Языком спецификаций} называется формальный язык, призванный описывать свойства и поведение систем на более высоком уровне абстракции, нежели языки программирования.
\end{definition}

Как следует из определения, целью языков спецификации является как можно более подробное формальное описание систем. В связи с этим, большинство современных известных языков спецификации являются очень мощными системами, построенных вокруг фундаментальных понятий алгебры, математической логики, теории типов, теории категорий.

Например, язык спецификаций \name{Z-нотация} (англ. \eng{Z-notation}) основывается на теории множеств, лямбда-исчислении и логики предикатов первого порядка \cite{Z-notation}. Язык \name{CASL} поддерживает логику первого порядка, индукцию, частичные функции, наследование, и др. \cite{CASL}.

Благодаря мощному инструментарию, языки спецификации могут формализовывать довольно сложные и нетривиальные утверждения, связи и взаимодействия в системе. Следует ожидать, что в языках спецификации можно выразить и системы эффектов, и контракты, и это действительно так -- язык \name{Larch} использует ключевые слова \code{require}, \code{ensure} для описания предусловий и постусловий \cite{Larch}

В силу врожденной гибкости и выразительности, языки спецификаций обладают впечатляющей расширяемостью по типам анализа. Ценой же этому становится сложность. Подобные языки вводят значительное количество новых концепций и понятий, а также требуют от пользователя знания фундаментальных теорий, положенных в основу языка (чаще всего, алгебры и математической логики). Спецификации к программам могут быть длиннее и сложнее самих программ. В связи с этим, языки спецификаций в основном находят свое применение в тех областях разработки ПО, где недопустимы даже малейшие сбои и ошибки -- например, при разработке аппаратов радиотерапии \cite{Jacky97}.

Таким образом, языки спецификаций -- это отдельный, готовый инструмент, предназначенный в большей степени для формального доказательства корректности программ, нежели чем для улучшения качества статического анализа. Тем не менее, их выразительность, гибкость, а также в целом возможность воспользоваться готовым решением вроде CASL или Larch может иногда выглядеть довольно заманчиво.



\newpage



\subsection{Предметная область}

До этого момента мы, в основном, говорили несколько абстрактно и неконкретно. Это и неудивительно, т.к. такие понятия, как <<язык формальной спецификации>> или <<контракты>> являются очень широкими, способными гибко подстраиваться под любую предметную область и ее требования.

Вместе с тем, продолжать дальнейший разговор без предъявления некоторых реальных проблем видится видится крайне малоосмысленным. Поэтому в данном разделе будет рассказана краткая вводная в язык \code{Kotlin} и несколько реальных проблем синтаксического анализа в нем, связанных с межпроцедурным анализом. Это позволит сформулировать несколько несложных требований к разрабатываемой системе, которые будут служить нам базовой проверкой ее адекватности реальным задачам.


\subsubsection{Механизм умных приведений типов}

Важным механизмом, понимание которого необходимо для дальнейшего разговоре о \lang{Kotlin}, является механизм \term{умных приведений типов} (англ. \eng{smartcasts}).

Очень часто, перед явным приведением типа в коде выполняется проверка на подтип (для того, чтобы такое приведение было безопасным). В \lang{Java} это выглядит примерно следующим образом:

\begin{minted}{java}
if (x instanceof string) {
string s = (string) x;
... usage of s ...
}
\end{minted}

Суть механизма умных приведений типов заключается в том, чтобы облегчить программисту жизнь и выполнить приведение к более частному типу автоматически там, где это безопасно.

Вот эквивалентный участок кода на \lang{Kotlin}:

\begin{minted}{kotlin}
if (x is String) {
    val len = x.length
}
\end{minted}

Во второй строке произошло автоматические приведение типа, благодаря чему стал возможным доступ к полю \code{String.length}.

Особенно удобно это вместе с \code{when}-конструкцией, которая является более мощным аналогом \code{switch-case} из \code{Java}, в частности, позволяя использовать в \code{Kotlin} синтаксис, напоминающий сравнение с образцом (англ. \code{pattern matching}).

\begin{minted}{kotlin}
when (x) {
is String -> x.length   // x casted to String
is List<Int> -> x.size  // x casted to List
is Double -> x * 2.0    // x casted to Double

}
\end{minted}




\subsubsection{Проблемы механизма умных приведений типов}

Основная проблема заключается в том, что анализ возможности приведения типа выполняется без учета межпроцедурных взаимодействий. Так, давайте вспомним уже знакомую нам функцию проверки на строковый тип:

\begin{minted}{kotlin}
fun isString(x: Any?): Boolean {
return x is String
}
\end{minted}

Теперь если использовать эту функцию в качестве условия условного оператора, то умное приведение типа выполнено не будет:

\begin{minted}{kotlin}
if (isString(x)) {
val s = x as String    // explicit cast needed
}
\end{minted}

Особенно актуальна эта проблема для работы с коллекциями с использованием stream-like API, предоставляемом в \lang{Kotlin}. Так, существует метод \code{filter}, который оставляет в коллекции только те элементы, на которых переданный предикат вернул \code{true}. Этот метод довольно часто используется для того, чтобы оставить в коллекции только объекты определенного типа: \code{list.filter(x -> x is String)} оставит в коллекции \code{list} только строки.

Разумеется, в обоих описанных случаях компилятор не может просто так выполнить умное приведение типа -- для этого ему нужно знать некоторый <<контракт>> вызываемой функции.

Для \code{isString} нужно знать, что <<\code{isString(x)} возвращает \code{true} тогда и только тогда, когда \code{x} -- \code{String}>>.

Для \code{filter} нужно знать, что он оставляет в коллекции только те объекты, на которых переданный предикат вернул \code{true}.


\bigskip

Другим распространенным случаем, когда умное приведение типов можно было бы сделать, но оно не делается, являются функции, которые могут завершиться с исключением.

Рассмотрим следующий пример:

\begin{minted}{kotlin}
assert(x is String)
val s = x as String    // explicit cast needed
\end{minted}

Если мы будем считать, что \code{assert} бросает исключение всегда, когда его условие -- \code{false} (на практике это зависит от ключей окружения, но мы опустим эти детали реализации), тогда во второй строке автоматическое приведение типа может быть безопасно выполнено. Тем не менее, на данный момент компилятор \lang{Kotlin} этого не делает, ровно по тем же причинам, что и в примерах выше -- он не выполняет межпроцедурного анализа, и потому ему не известен контракт <<assert>>.




\subsubsection{Анализ инициализации переменных}

\lang{Kotlin} поддерживает отложенную инициализацию локальных переменных и будет отслеживать и предупреждать об использовании неинициализированных переменных:

\begin{minted}{kotlin}
val x: Int
// println(x)
x = 5
println(x)
\end{minted}

Если раскомментировать строку 2, то компилятор вполне законно выдаст ошибку об использовании неинициализированной переменной.

Теперь рассмотрим функцию \code{run}, которая просто вызывает переданную ей лямбду:
\begin{minted}{kotlin}
fun run(block: () -> Unit): Unit {
block()
}
\end{minted}

Если теперь выполнить отложенную инициализацию переменной внутри лямбды, переданной внутрь \code{run}, то компилятор уже не сможет доказать, что переменная была корректно проинициализированна:

\begin{minted}{kotlin}
val x: Int
run ({ () -> x = 5 })
println(x)
\end{minted}

Компилятор отвергает подобный код, ошибочно сообщая об использовании неинициализированной переменной в строке 3. Причина этого примерно такая же, как и во всех предыдущих примерах: компилятор не знает контракта функции \code{run}, и потому не знает, что лямбда \code{\{ () -> x = 5 \}} будет гарантированно вызвана.

Этот пример умышленно утрирован для простоты объяснения. На самом деле, это вполне актуальная и серьезная проблема, т.к. \code{Kotlin} придерживается философии введения как можно меньшего количества ключевых слов. Это возможно из-за существования лямбд и функций высшего порядка, а также из-за синтаксического сахара, позволяющего передавать лямбду в виде блока, если она передается последней в списке параметров. Именно так реализован аналог ключевого слова \code{synchronized} из \lang{Java}: в \lang{Kotlin} это обычная функция, определенная примерно следующим образом (детали взятия и освобождения блокировки опущены для ясности).

\begin{minted}{kotlin}
fun synchronized(block: () -> Unit): Unit {
... take lock ...
block()
... release lock ...
}
\end{minted}

В пользовательском коде использование этой функции с учетом описанного выше синтаксического сахара выглядит следующим образом:

\begin{minted}{kotlin}
val x: Int
synchornized {
x = 5
}
println(x)
\end{minted}

Точно также, как в примере с \code{run}, компилятор заявляет о том, что в строке 5 переменная \code{x} не инициализирована. Это уже более серьезная проблема, т.к. здесь нельзя обойтись парой избыточных символов, как это было в примере с умными приведениями типа.
q
Такой случай использования является вполне жизненным и распространенным, и в будущем будет появляться лишь больше функций, похожих на \code{run} и \code{synchronized}. Например, абсолютно также реализована идиома \code{try-with-resources} из \code{Java}, различные функции для работы с корутинами, и т.д.

Для того, чтобы решить это проблему, необходимо некоторым образом донести до компилятора контракт всех таких функций: что они вызывают переданную им лямбду некоторое статически детерминированное число раз.





\subsection{Актуальность, цель и задачи работы}

Подведем краткий итог проблем, которые мы пронаблюдали в предметной области:

\begin{itemize}
    \item Корнем всех перечисленных выше проблем являются неучтенные межпроцедурные взаимодействия

    \item Для того, чтобы корректно дополнить анализ, необходимо извлечь некоторые факты и утверждения о том, как именно работают функции (связь входного и выходного значения, как в \code{isString}, или же информация о поведении функции по отношению к переданным аргументам, как в \code{run})

    \item Следует ожидать, что контракты могут становиться весьма нетривиальными, равно как и то, что достаточно простые контракты может оказаться непросто выводить в автоматическом режиме (например, функция может действительно вызывать лямбду ровно один раз, но при этом делать еще множество других нетривиальных вещей, тем самым затрудняя анализ).
\end{itemize}

На основе этих утверждений, можно сформулировать ряд ожидаемых требований:

\begin{enumerate}
  \item Система должна быть способна описывать межпроцедурные взаимодействия с условиями (например, связь между аргументами функции и возвращаемым значением).

  \item Система должна поддерживать явные пользовательские аннотации.

  \item Система должна быть удобной для интеграции с существующими решениями (компиляторами, IDE).

  \item Вычислительная сложность анализа должна позволять работу с крупными проектами (от сотен тысяч строк кода).

  \item Система должна по возможности легко расширяться по типам анализа.
\end{enumerate}

Вспомним рассмотренные нами подходы. Их соответствие означенным критериям сведено в таблицу \ref{approaches-analysis}

\begin{table}
\begin{tabular}{ | p{0.15\linewidth} | p{0.15\linewidth} | p{0.15\linewidth} | p{0.15\linewidth} | p{0.20\linewidth} | p{0.15\linewidth} | }
  \hline
               & Условные контракты & Явные аннотации            & Удобство интеграции & Независимость от длины кода & Расширяемость \\\hline

  Анализ потока данных &   -          & -               & +           & -               & +          \\\hline

  Языки спецификаций   & +          & +               & -           & +               & +         \\\hline

  Эффекты           & +/-           & +               & +           & +               & +          \\\hline

  Контракты         & +           & +               & +           & +               & +/-         \\\hline
\end{tabular}
\label{approaches-analysis}
\caption{Сравнение различных подходов к межпроцедурному анализу}
\end{table}

Прокомментируем некоторые моменты.

\begin{itemize}
  \item Языки спецификации очень неудобны для интеграции в существующие решения. В особенности это ощущается, если между существующим решением и языком спецификации поток информации двунаправленный -- добавить в компилятор логику обращения за информацией в язык спецификаций относительно несложно, но вот сделать обратное может быть или очень нетривиально, или зачастую вовсе невозможно.

  \item Символ <<+/->> следует читать как <<система потенциально удовлетворяет критерию, но вопрос реализации изучен слабо>>
\end{itemize}

Можно видеть, что ни одно из существующих решений не удовлетворяет всем требованиям. Однако, эффекты и контракты видятся как наилучшие подходы к решению поставленных проблем. Для того, чтобы выбрать между этими двумя подходами, нужно вспомнить, что при анализе мы отмечали их большую схожесть, и сделали вывод, что выбор необходимо делать исходя из предметной области.

Внимательное рассмотрение проблем, поставленных в предметной области, дает понять, что в данном конкретном случае концепция предусловий-постусловий не является часто используемой, и зачастую не используется, поэтому было принято решение взять за основу системы эффектов. Таким образом, можно сформулировать цель и задачи:


\paragraph{Цель.} Разработать систему эффектов, выполняющую анализ кода посредством использования информации о поведении вызываемых функций, и реализовать ее прототип в компиляторе языка \lang{Kotlin}

\paragraph{Задачи:}

\begin{enumerate}
  \item Выполнить анализ существующих решений

  \item Разработать систему эффектов

  \item Реализовать разработанную систему в компиляторе \code{Kotlin}.

  \item Провести анализ полученного решения, выявить его достоинтсва и недостатки.
\end{enumerate}
