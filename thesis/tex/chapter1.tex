\section{Глава 1}

\subsection{Теоретические основы}

В данной работе нам понадобится ряд формальных определений и терминов, которые мы будем использовать в дальнейшем. 

\subsubsection{Понятие подпрограммы}

Первым делом, условимся использовать термины \term{подпрограмма}, \term{функция}, \term{метод}, \term{процедура} взаимозаменяемо, в смысле, интуитивно соответствующему англ. \eng{callable}. Более формально:

\begin{definition}
    \term{Подпрограммой} (функцией, методом, процедурой) будем называть выделенную последовательность инструкций, в которую может быть передано управление, и которая по завершению возвращает его в место вызова \cite{Wheeler52}.
\end{definition}

Отметим, что также в это определение укладываются все объекты, на которых можно произвести непосредственный вызов, если таковые поддерживаются языком -- например, объекты, с переопределенным методом \code{invoke} в \lang{Kotlin}, \code{apply} в \lang{Scala}, \code{\_\_call\_\_} в \lang{Python} и т.д.





\subsubsection{Понятие эффекта и системы эффектов}

Центральным определением в данной работе, является, разумеется, \term{эффект}. Однако несмотря на то, что это определение, судя по всему, было введено еще на заре развития программирования (так, ранние работы по аксиоматизации программирования уже ссылаются на этот термин без отдельного его введения \cite{Hoare69, Schwartz67}), общепринятой формулировки за все это время не появилось. 

В классических источниках, под эффектом чаще всего понимают <<некоторое видимое изменение в окружении>> \cite{Luc88}, или даже еще более конкретно <<изменение в памяти программы>> \cite{Vak09}. Некоторые исследователи и вовсе ограничивают это определение до <<чтения или записи в изменяемое состояние программы>> \cite{Green99}. Это можно резюмировать следующим образом:

\begin{definition}
\label{def-effect-1}
    \term{Эффектом} называется некоторое изменение, производимое подпрограммой в состоянии вычислителя (кроме возвращения подпрограммой значения).
\end{definition}

Другие же авторы употребляют более широкую трактовку <<эффекта>> \cite{Nielson99}: 

\begin{definition}
\label{def-effect-2}
    \term{Эффектом} является описание действий, происходящих в ходе выполнения подпрограммы.
\end{definition}

Разумеется, формулировка \ref{def-effect-2} является слишком широкой -- вплоть до того, что под нее подходит непосредственно исходный код тела функции. С другой же стороны, формулировка \ref{def-effect-1} является нежелательно узкой в контексте данной работы. Поясним это на примере. 

Рассмотрим следующую функцию, которая является тривиальной оберткой над проверкой переменной на принадлежность строковому типу:

\begin{minted}{kotlin}
fun isString(x: Any?): Boolean {
    return (x is String)
}
\end{minted}

И рассмотрим следующий участок кода:

\begin{minted}{kotlin}
if (isString(t)) {
    ...
}
\end{minted}

Мы хотели бы сказать, что в истинной ветке условного оператора мы наблюдаем тот эффект, что <<\code{isString} вернула значение \code{true}>>. Однако это действие не подходит под определение эффекта \ref{def-effect-1}. Мы могли бы отказаться от специального случая для возвращаемых значений в этой формулировке, но в дальнейшем мы встретим некоторые утверждения, которые мы тоже хотели бы называть эффектами, но которые не описывают вообще никакого изменения в состоянии вычислителя.

Поэтому нам понадобится определение, чуть более слабое, чем определение \ref{def-effect-1}, но при этом не являющееся чересчур расплывчатым, как \ref{def-effect-2}. Мы сформулируем его следующим образом:

\begin{definition}
    \label{def-effect}
    \term{Эффект} -- это некоторая информация об окружении, получаемая при выполнении подпрограммы.
\end{definition}

Т.к. это определение рассматривает только окружение, то сразу отпадают все слишком широкие его интерпретации. В частности, все, что подпрограмма делает со своими локальными переменными, не подходит под это определение -- что очень удобно, т.к. изменения в локальных переменных нас никоим образом не интересуют.

С другой стороны, это определение включает в себя определение \ref{def-effect-1}, т.к. <<изменение в состоянии>>, несомненно, является <<информацией об окружении>>.

Наконец, как мы увидим чуть позже, под это определение подходят и довольно нестандартные действия, которые нам будет удобно считать эффектами во имя общности подхода.


\bigskip

Естественным продолжением определения эффекта является определение \term{системы эффектов}. Само по себе название уже достаточно интуитивно, особенно если провести параллель <<эффект также относится к системе эффектов, как тип относится к системе типов>>. Тем не менее, мы дадим здесь формальное определение, т.к. это понятие также является центральным в данной работе и будет многократно использоваться в дальнейшем:

\begin{definition}
    \term{Система эффектов} -- это множество правил, по которым подпрограммам и их конкретным вызовам приписываются эффекты, и по которым осуществляется взаимодействие эффектов.
\end{definition}




\subsubsection{Анализ потока данных}

Кроме того, нам в дальнейшем нам понадобятся основные концепции data-flow анализа.

Начнем с понятия графа потока управления (англ. \eng{control-flow graph, CFG}) Каждая инструкция в нем представлена одной вершиной, и если между вершинами $u$ и $v$ есть ребро, то это означает что после инструкции $u$ управление может быть передано 
в инструкцию $v$. 

Рассмотрим простой пример кода:

\begin{minted}{kotlin}
    if (x == 0) {
        println("True branch")
    } else {
        println("False branch")
    }
    println("If-end")    
\end{minted}

Ему соответствует граф потока управления, как на рисунке \ref{control-flow-example}

\begin{figure}
    \centering
    \includegraphics[scale=0.5]{img/control-flow-example}
    \caption{Пример графа потока управления}
    \label{control-flow-example}
\end{figure}


Так, после инструкции, вычисляющей условие в \code{if}, поток управления раздвоился, отражая тот факт, что мы не можем знать при статическом анализе (без дополнительных предположений), какая из веток выполнится. После ветки вновь сливаются в один поток, как и следовало ожидать.

Разумеется, граф потока управления не обязан быть ацикличным -- конструкции \code{for}, \code{while}, \code{goto} (безусловных переход) могут вносить в него обратные ребра.

Важно заметить, что любому возможному пути исполнения в программе обязательно соответствует некоторый путь в CFG, но обратное не верно. Например, путь может проходить через истинную ветку выражения \linebreak \code{if (x == 0) } и через истинную ветку выражения \code{if (x != 0)}, хотя между первым и вторым оператором могло и не быть никаких изменений переменной \code{x}, и иногда это даже можно доказать статически.
Тем не менее, это не нарушает консервативности анализа, поскольку при анализе будет обязательно рассмотрен любой реально возможный путь исполнения. 

Конструкция графов потока управления сама по себе позволяет обнаружить совсем простые ошибки, вроде недостижимого кода из-за неправильного использования безусловных переходов. Однако она становится особо мощной и полезной, если использовать ее вместе с концепцией анализа потока данных.

\begin{definition}
	Анализ потока данных (англ. \eng{data-flow analysis})  -- это метод статического анализа, который основывается на извлечении информации из характеристик и свойств потока данных вдоль различных путей исполнения в программе.
\end{definition}

Основная идея основывается на наблюдении, что в любой момент времени при выполнении программы существует некоторое глобальное состояние, которое состоит из множества всех переменных, их значений, а также другой информации, зависящей от конкретного типа анализа (например, счетчик количества вызовов для функций, статус инициализации переменной, и т.д.). Тогда для каждой точки программы можно ввести понятие \term{значения потока данных} (от англ. \eng{data-flow value}), которое является абстракцией всех возможных глобальных состояний, которые можно наблюдать в данной точке. Для краткости, в дальнейшем мы будем писать DFV вместо <<значение потока данных>>.

В силу того, что потенциально количество возможных путей исполнения в программе может быть бесконечно \cite{dragon-book}, на практике делается два упрощения: во-первых, конкретное DFV не хранит историю, как управление могло придти к этой точке программы, а во-вторых, в зависимости от конкретного анализа, откидывается некоторая излишняя информация. Так, например, при анализе инициализации переменных, нам не важно, какие значения может иметь переменная, и на каких путях исполнения они могли быть получены. Достаточно знать, правда ли, что на любом пути исполнения, достигающем данную точку, данная переменная была инициализирована, или нет. Таким образом, для каждой переменной достаточно просто хранить бинарный флаг, что значительно упрощает реализацию на практике.

Далее, каждой инструкции $s$ соответствует \term{входное состояние} -- глобальное состояние непосредственно перед выполнением инструкции, которое мы будем обозначать $in[s]$, и \term{выходное состояние} -- соответственно, глобальное состояние непосредственно после выполнения инструкции (его мы будем обозначать $out[s]$). Обратим внимание, что выходное состояние для одной инструкции является входным для следующей, с котором она соединена ребром в CFG. Каждому входному (выходному) состояние соответствует некоторое DFV, и в силу предыдущего факта, это отображение является сюръекцией, но не биекцией.

Кроме того, каждая инструкция задает некоторое преобразование, называемое \term{функцией перехода} (англ. \eng{transfer function}), которое по входному состоянию выдает выходное. Конкретный вид преобразования определяется анализом и самой инструкций. 

Таким образом, мы получаем набор уравнений на переменные $in[x]$, $out[x]$ для всех $x \in I$, где $I$ -- множество инструкций в программе. Хотелось бы получить некоторое решение этих уравнений, т.е. множество значений для входных-выходных состояний, удовлетворяющее этим уравнениям. Мы не будем вдаваться в подробности того, как это делается, т.к. это иррелевантно к данной работе, подробней про методы решения систем уравнений на поток данных можно прочитать в канонических источниках: \cite{dragon-book, muchnick}. В дальнейшем нам будет достаточно концепции графа потока управления, входных-выходных состояний и функций перехода.



\newpage

\subsection{Предметная область}

Для того, чтобы получить конкретную почву для дальнейших рассуждений и ограничить область рассматриваемых проблем, мы здесь приведем несколько имеющихся на данный момент проблем со статическим анализом в языке \lang{Kotlin}. 



\subsubsection{Механизм умных приведений типов}

Важным механизмом, понимание которого необходимо для дальнейшего разговоре о \lang{Kotlin}, является механизм \term{умных приведений типов} (англ. \eng{smartcasts}). 

Очень часто, перед явным приведением типа в коде выполняется проверка на подтип (для того, чтобы такое приведение было безопасным). В \lang{Java} это выглядит примерно следующим образом:

\begin{minted}{java}
    if (x instanceof string) {
        string s = (string) x;
        ... usage of s ...
    }
\end{minted}

Суть механизма умных приведений типов заключается в том, чтобы облегчить программисту жизнь и выполнить приведение к более частному типу автоматически там, где это безопасно. 

Вот эквивалентный участок кода на \lang{Kotlin}: 

\begin{minted}{kotlin}
    if (x is String) {
        val len = x.length
    }
\end{minted}

Во второй строке произошло автоматические приведение типа, благодаря чему стал возможным доступ к полю \code{String.length}.

Особенно удобно это вместе с \code{when}-конструкцией, которая является более мощным аналогом \code{switch-case} из \code{Java}, в частности, позволяя использовать в \code{Kotlin} синтаксис, напоминающий сравнение с образцом (англ. \code{pattern matching}).

\begin{minted}{kotlin}
    when (x) {
        is String -> x.length   // x casted to String
        is List<Int> -> x.size  // x casted to List
        is Double -> x * 2.0    // x casted to Double
        
    }
\end{minted}




\subsubsection{Проблемы механизма умных приведений типов}

Основная проблема заключается в том, что анализ возможности приведения типа выполняется без учета межпроцедурных взаимодействий. Так, давайте вспомним уже знакомую нам функцию проверки на строковый тип:

\begin{minted}{kotlin}
    fun isString(x: Any?): Boolean {
        return x is String
    }
\end{minted}

Теперь если использовать эту функцию в качестве условия условного оператора, то умное приведение типа выполнено не будет:

\begin{minted}{kotlin}
    if (isString(x)) {
        val s = x as String    // explicit cast needed
    }
\end{minted}

Особенно актуальна эта проблема для работы с коллекциями с использованием stream-like API, предоставляемом в \lang{Kotlin}. Так, существует метод \code{filter}, который оставляет в коллекции только те элементы, на которых переданный предикат вернул \code{true}. Этот метод довольно часто используется для того, чтобы оставить в коллекции только объекты определенного типа: \code{list.filter(x -> x is String)} оставит в коллекции \code{list} только строки.

Разумеется, в обоих описанных случаях компилятор не может просто так выполнить умное приведение типа -- для этого ему нужно знать некоторый <<контракт>> вызываемой функции. 

Для \code{isString} нужно знать, что <<\code{isString(x)} возвращает \code{true} тогда и только тогда, когда \code{x} -- \code{String}>>. 

Для \code{filter} нужно знать, что он оставляет в коллекции только те объекты, на которых переданный предикат вернул \code{true}.


\bigskip

Другим распространенным случаем, когда умное приведение типов можно было бы сделать, но оно не делается, являются функции, которые могут завершиться с исключением. 

Рассмотрим следующий пример:

\begin{minted}{kotlin}
    assert(x is String)
    val s = x as String    // explicit cast needed
\end{minted}

Если мы будем считать, что \code{assert} бросает исключение всегда, когда его условие -- \code{false} (на практике это зависит от ключей окружения, но мы опустим эти детали реализации), тогда во второй строке автоматическое приведение типа может быть безопасно выполнено. Тем не менее, на данный момент компилятор \lang{Kotlin} этого не делает, ровно по тем же причинам, что и в примерах выше -- он не выполняет межпроцедурного анализа, и потому ему не известен контракт <<assert>>. 




\subsubsection{Анализ инициализации переменных}

\lang{Kotlin} поддерживает отложенную инициализацию локальных переменных и будет отслеживать и предупреждать об использовании неинициализированных переменных:

\begin{minted}{kotlin}
    val x: Int
    // println(x)
    x = 5
    println(x)
\end{minted}

Если раскомментировать строку 2, то компилятор вполне законно выдаст ошибку об использовании неинициализированной переменной. 

Теперь рассмотрим функцию \code{run}, которая просто вызывает переданную ей лямбду: 
\begin{minted}{kotlin}
    fun run(block: () -> Unit): Unit {
        block()
    }
\end{minted}

Если теперь выполнить отложенную инициализацию переменной внутри лямбды, переданной внутрь \code{run}, то компилятор уже не сможет доказать, что переменная была корректно проинициализированна:

\begin{minted}{kotlin}
    val x: Int
    run ({ () -> x = 5 })
    println(x)
\end{minted}

Компилятор отвергает подобный код, ошибочно сообщая об использовании неинициализированной переменной в строке 3. Причина этого примерно такая же, как и во всех предыдущих примерах: компилятор не знает контракта функции \code{run}, и потому не знает, что лямбда \code{\{ () -> x = 5 \}} будет гарантированно вызвана.

Этот пример умышленно утрирован для простоты объяснения. На самом деле, это вполне актуальная и серьезная проблема, т.к. \code{Kotlin} придерживается философии введения как можно меньшего количества ключевых слов. Это возможно из-за существования лямбд и функций высшего порядка, а также из-за синтаксического сахара, позволяющего передавать лямбду в виде блока, если она передается последней в списке параметров. Именно так реализован аналог ключевого слова \code{synchronized} из \lang{Java}: в \lang{Kotlin} это обычная функция, определенная примерно следующим образом (детали взятия и освобождения блокировки опущены для ясности).

\begin{minted}{kotlin}
    fun synchronized(block: () -> Unit): Unit {
        ... take lock ...
        block()
        ... release lock ...
    }
\end{minted}

В пользовательском коде использование этой функции с учетом описанного выше синтаксического сахара выглядит следующим образом:

\begin{minted}{kotlin}
    val x: Int
    synchornized {
        x = 5
    }
    println(x)
\end{minted}

Точно также, как в примере с \code{run}, компилятор заявляет о том, что в строке 5 переменная \code{x} не инициализирована. Это уже более серьезная проблема, т.к. здесь нельзя обойтись парой избыточных символов, как это было в примере с умными приведениями типа. 

Такой случай использования является вполне жизненным и распространенным, и в будущем будет появляться лишь больше функций, похожих на \code{run} и \code{synchronized}. Например, абсолютно также реализована идиома \code{try-with-resources} из \code{Java}, различные функции для работы с корутинами, и т.д.

Для того, чтобы решить это проблему, необходимо некоторым образом донести до компилятора контракт всех таких функций: что они вызывают переданную им лямбду некоторое статически детерминированное число раз. 





\subsubsection{Анализ}

Подведем краткий итог проблем, которые мы пронаблюдали в предметной области:

\begin{itemize}
    \item Корнем всех перечисленных выше проблем являются неучтенные межпроцедурные взаимодействия
    
    \item Для того, чтобы корректно дополнить анализ, необходимо извлечь некоторые факты и утверждения о том, как именно работают функции (связь входного и выходного значения, как в \code{isString}, или же информация о поведении функции по отношению к переданным аргументам, как в \code{run})
    
    \item Следует ожидать, что контракты могут становиться весьма нетривиальными, равно как и то, что достаточно простые контракты может оказаться непросто выводить в автоматическом режиме (например, функция может действительно вызывать лямбду ровно один раз, но при этом делать еще множество других нетривиальных вещей, тем самым затрудняя анализ).
\end{itemize}

Таким образом, мы интересуемся некоторыми системами, облегчающими межпроцедурный анализ за счет использования знания о том, как функция взаимодействует с окружением. Кроме того, хотелось бы, чтобы такие системы позволяли пользователю прописать вручную контракты в местах, где автоматический вывод не справляется.

Если внимательно посмотреть на эту формулировку, то можно заметить, что это практически определение систем эффектов. Тем не менее, в следующем разделе мы рассмотрим еще некоторых систем, которые решают практически ту же проблему, и проведем их сравнительный анализ.










\subsection{Обзор существующих решений}

В качестве наиболее близких и подходящих по свойствам, мы рассмотрим четыре подхода к решению означенной проблемы: системы эффектов, контракты, языки спецификации и некоторые эзотерические методы, вроде зависимых типов и монад. Кроме того, будет произведен небольшой обзор практических реализаций каждого из методов.

\subsubsection{Системы эффектов}

Системы эффектов появились в конце 80-ых годов как логичное развитие систем типов. Из-за этого, между системами типов и системами эффектов существует естественная связь, служащая источником для различных интуиций и полезных параллелей. Поскольку осознание этой связи значительно облегчает понимание любых фактов и свойств систем эффектов, ниже будет вкратце описано, откуда эта связь появлятся.

\bigskip

В компьютерных программах существует два основополагающих понятия: это объекты, которые хранят информацию, и функции, которые что-то делают с объектами

Системы типов отвечают за информацию об объектах. Мы можем написать нечто вроде \code{a: Int}, и это будет означать, что между программистом и компилятором установлено некоторое соглашение относительно того, какого рода информация соответствует этой переменной -- в зависимости от конкретного языка, это может означать, например, что в \code{a} хранится 32-битное знаковое целое число. Более конкретные спецификации могут даже устанавливать соглашение о том, как именно кодируется это число и как оно хранится в памяти.

Но мощь систем типов ограничена, когда речь заходит о функциях -- что и неудивительно, т.к. тип говорит о свойствах объекта, а не процедур. Отчасти проблема решается сигнатурами, но по сути, это всего лишь информация об аргументах и возвращаемом объекте, но никак не о том, что с ними делает функция. Так, сигнатура \code{void doSomething()} в \lang{Java} не дает никакой информации, и программисту остается лишь надеяться на адекватное название и комментарии в коде.

Отсюда и рождается идея эффектов и систем эффектов. Эффект для процедуры -- это тоже самое, что тип для объекта. Так, в одной из первых работ по системам эффектов, дается следующее определение:

\begin{definition}
	\term{Эффектом} выражения называется краткое описание всех наблюдаемых побочных эффектов, которые это выражение может вызвать при вычислении \cite{Luc88}.
\end{definition}

Традиционно для подобных исследований, авторы немного лукавят и не определяют <<побочный эффект>> строго, надеясь на интуицию читателя (в их оправдание скажем, что интуиция, скорее всего, не подведет). В главе 2 мы четко разберемся со всеми этими понятиями и дадим точные определения. Пока же можно считать, что <<побочный эффект>> соответствует некоторому изменению в памяти программы.


Тесная связь между системами типов и системами эффектов сходу дает значительное количество полезных наблюдений. Чтобы подчеркнуть двойственность между этими двумя системами, эти наблюдения оформлены в таблицу \ref{types-effects-comparison}

\begin{table}
\begin{tabular}{ | p{0.4\linewidth} | p{0.4\linewidth} | }	
	\hline
	Системы типов & Системы эффектов \\\hline
	
	Помогают предотвращать ошибки -- например, от сохранения строкового значения в тип \code{Int}.
	&
	Помогают предотвращать ошибки -- например, от использования функции, которая бросает исключение, вне блока \code{try-catch}.
	\\\hline
	
	Помогают компилятору -- например, знание о типе переменной может позволить хранить ее в памяти более оптимально.
	&
	Помогают компилятору -- например, знание о том, в какие переменные пишет функция и какие читает, может позволить переупорядочивание кода, ранее невозможное.
	\\\hline
	
	
	Типы могут быть либо явно написаны пользователем, либо выведены автоматически.
	&
	Эффекты могут быть либо явно написаны пользователем, либо выведены автоматически
	\\\hline
	
	
	Бывает полезной возможность введения пользовательского типа.
	&
	Бывает полезной возможность введения пользовательских эффектов.
	\\\hline

\end{tabular}
\label{types-effects-comparison}
\caption{Сравнение типов и эффектов}
\end{table}

\bigskip

Основопологающей работой является уже упомянутая несколько раз статья Lucassen, Gifford <<Polymorphic effect system>> (1988) \cite{Luc88}. В ней авторы описывают основы систем эффектов, предлагают формализм, схожий с формализмом систем типов, позволяющий описывать эффекты.

В качестве примеров эффектов рассматриваются эффекты \code{read/write} чтения-записи в переменную. Следует отметить, что эти эффекты хотя и довольно сложны для автоматического вывода, но будучи однажды аннотированными, комбинируются и вычисляются довольно просто. 

Следует также отметить, что данное исследование является в большей степени математической формализацией концепта эффектов, нежели конкретными попытками воплотить это на практике.

С точки зрения практики, очень интересной является статья Greenhouse, Boyland <<An Object-Oriented Effect System>> (1999) \cite{Green99}. В ней авторы задаются уже вполне жизненными и насущными вопросами о применении систем эффектов в условиях объекто-ориентированного \lang{Java}-подобного языка. Так, рассмотрены проблемы наследования эффектов, инкапсуляции в присутствии эффектов. В частности, была рассмотрена любопытная проблема, связанная с глубинным противоречием эффектов и инкапсуляции -- с одной стороны, эффект должен рассказать что-то о том, как работает метод, но с другой стороны, принцип инкапсуляции запрещает раскрывать детали реализации данного метода! Для решения этой проблемы было введено понятие <<регионов>>, которое не является необходимым для этой работы и потому рассматриваться не будет.

Для данной работы важно, что в данной статье по-прежнему рассматриваются лишь \code{read/write} эффекты. Кроме того, подразумевается, что все эффекты являются частью языка и вводятся в него в виде специальных ключевых слов, тем самым вопрос о добавлении новых эффектов (и уж тем более пользовательских) не поднимается.

Продолжая тему практических приложений систем эффектов, нельзя не упомянуть массивный труд Bierman, Parkinson, Pitts <<An imperative core calculus for Java and Java with effects>> (2003) \cite{Bierman03}. В этом техническом отчете авторы предоставляют формализацию довольно значительного подмножества \lang{Java}, вместе с правилами вывода, подробным описанием системы типов, операционной семантикой и т.д. В частности, авторы применили к полученному формализованному <<ядру>> языка наработки Greenhouse, Boyland и добавили систему эффектов, доказали ее корректность и предложили алгоритм вывода эффектов. Разумеется, в силу того, что основная часть была взята из работы <<An object-Oriented Effect System>>, никаких концептуально новых подходов к системам эффектов введено не было.

Более любопытные эффекты рассматриваются в работе Flanagan, Freund, Lifshin <<Types for atomicity: Static Checking and Inference for Java>> (2008) \cite{Flanagan08}. Авторы ставят цель разработать систему эффектов, способную обнаруживать ошибки в программах на \lang{Java}, связанные с многопоточностью. В связи с этим вводится класс эффектов, связанных с различными типами многопоточного взаимодействия. 

Также очень интересно отметить, что здесь появляются некоторые простые условные эффекты, связанные с тем, что поведение многопоточных методов почти всегда зависит от владения той или иной блокировкой. 

Несмотря на то, что описанная система не поддерживает никаких условий, кроме собственно описывающих факт владения блокировкой, авторы уже сталкиваются с некоторыми проблемами, свойственными условным эффектам -- в частности, экспоненциальный взрыв длины аннотаций при последовательном комбинировании эффектов (мы подробней будем говорить об этом в главе 2). Отметим здесь только, что в силу простого устройства условий, авторам удается ввести довольно простые правила редукции слишком длинных аннотаций и благополучно обогнуть эту проблему.


\bigskip

Взглянем теперь в сторону практических реализаций систем эффектов. 

Первым делом сразу следует отметить различные известные языковые механизмы, которые не называются системами эффектов явно, но тем не менее ими являются: проверяемые исключения в \lang{Java} и ключевое слово \code{throws}, ключевое слово \code{const} в \lang{C++}, или даже \lang{Java}-аннотация \code{@Deprecated}. Они все, разумеется, являются слишком негибкими и узкими, поэтому здесь они упомянуты больше для полноты обзора, нежели ради некоторых полезных наблюдений.

Мощной реализацией идеи систем эффектов является язык программирования FX-87 \cite{FX87}, разработанный в соавторстве с Gifford, который, как мы помним, вместе с Lucassen заложил основы систем эффектов. К несчастью, этот язык на сегодняшний день уже не поддерживается и развивается (чему он, вероятно, в значительной степени обязан в высшей степени нечитаемому синтаксису). Кроме того, данный язык является функциональным, что еще более уменьшает актуальность этой реализации для настоящего исследования.

Намного более практико-ориентированной, и потому более интересной, явлется \name{Checker Framework} \cite{checker-framework}. Это фреймворк, построенный на основе JSR-308 \cite{JSR308}, и позволяющий организовывать небольшие системы эффектов на основе \lang{Java}-аннотаций. Фреймворк предоставляет набор готовых аннотаций, равно как и возможность задавать собственные.

Полезным наблюдением, которое можно извлечь из принципа устройства \name{Checker Framework} является тот факт, что подавляющее большинство эффектов нетривиально взаимодействуют только с эффектами такого же типа и никак не влияют на все остальные. Этим активно пользуется \name{Checker Framework}, вводя понятия \name{checker} -- это модуль, который знает о некотором количестве эффектов в программе и выполняет их комбинацию, вывод, проверку. В программе может быть множество \name{checker}-ов и множество эффектов, а архитектура \name{Checker Framework} сама устроит так, чтобы нужные эффекты попали на обработку к нужным \name{checker}-ам. Это значительно упрощает добавление новых эффектов и поддержку старых.
