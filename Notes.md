## 13.02.2017

### `Is`-оператор.

Рассмотрим ситуацию: `{ bla-bla -> Returns(value, returnType) } is rhs -> bla-bla`

**Важное наблюдение:** верхней границей `returnType` является тип из сигнатуры вызываемой функции. В процессе работы системы эффектов `returnType` может уточняться, т.е. спускаться вниз по иерархии типов.

**Следствие 1**. Если `returnType` и `rhs` находятся в разных ветках иерархии, то результат `Is` -- точно `False`.

**Следствие 2**. Если `returnType` -- потомок `rhs`, то результат `Is` -- точно `True`

**Следствие 3**. Если `rhs` -- потомок `returnType`, то результат `Is` не может быть выведен статически.

> Нужно как-то различать тип, который мы получили из сигнатуры и тип, который был декларирован в эффекте.

> В первом случае в ситуации №3 мы действительно ничего не знаем о результате `Is`.
> Пример: `fun foo(): Any? = "haha, tricked you!"`

> Во втором же случае в ситуации №3 мы можем с уверенностью заявить, что результат `Is` -- `False`.

> В конечном итоге, это упирается в то, что мы хотим знать -- может ли `returnType` быть еще подвинут вниз, или это уже конечная станция и дальше он ну никак не уточнится (бывает ли такое?)

--------

- А еще неплохо было бы наверное договориться, что любой Conclusion содержит или `Returns` (если ничего не знаем, то с пустыми полями -- он просто будет показывать завершение функции) или `Throws`.

## 14.02.2017

- Код в `Evaluator` при визите `Is` выглядит настолько стремно, что аж плохо. Нужно подумать, куда вытащить `evaluateIs`. Может быть, интерфейс `Evaluatable`?

- `Effect` на самом деле является еще одной связкой с семантикой "влечет", типа `Then`.

## 15.02.2017

- Идея обобщения `Effect` до связки с семантикой импликации нравится все больше:
  - Описание того, что происходит при вычислениях в эффекте становится намного более ясным и понятным - просто еще несколько правил вывода для еще одного комбинатора.
  - Исчезают уродливые конструкции вида `true → ...` для обозначения безусловных эффектов (выполняются всегда).
  Причина их появления была в том, что раньше `EffectSchema` -- это всегда список эффектов. Теперь же `EffectSchema` -- это просто пучок детей типа `EsNode` (можно конкретизировать дальше, чтобы запретить всяким константам быть непосредственными детьми схемы), поэтому абсолюно корректно, если `EffectSchema` имеет ровно одного ребенка (например, `Returns(42)` для константной функции, или `throws RuntimeException` для функции делящей на ноль и т.д.)

- Пока пишем так, потом зарефачимся если чо.

- Стойкое ощущение, что для симметрических комбинаторов понадобится double-dispatching, т.к. даже если тем или иным способом сделать `evalute()` виртуальным, то тип правой части все равно придется уточнять для вызова корректной перегрузки.

Алгоритм комбинации двух схем **E1** и **E2**

```java
for (effect : E1.effects) {
  r = getReturnValue(effect)
  p = effect.premise
  c = effect.conclusion without Returns-clause
  switch(r) {
    case TRUE: // дописать `p` к каждому эффекту E2 слева и дописать `c` к каждому эффекту E2 справа
    // Действительно, в результате выполнения `p`, `E1` возвращает True (и вызывает некоторые сайд-эффекты `c`), и как следствие, вызывает правую часть.
    case FALSE: // добавить эффект вида: `p -> c`
    // Действительно, если выполнится `p`, то `E1` вернет False, и правая часть не запустится, НО выстрелят сайдэффекты `c`
    case UNKNOWN: // дописать `p AND E1.return == True` к каждому эффекту E2 слева и `c` справа
    // добавить эффект вида `p and E1.return == False -> c`
    // Действительно, просто рассмотрели два случая и сделали то, что делали бы при точно известном значении.
  }
}
```

Непонятно как имплементить!

Фикс:

```java
trueEffects = // все эффекты из E1, которые возвращают True
falseEffects = // все эффекты из E1, которые возвращают False
unknownEffects = // все эффекты из E1, которые что-то возвращают, но неизвестно, что именно

1. Копируем в результирующую схему все из E1 -- это опишет все сайдэффекты E1
2. Дополнительно копируем все эффекты из E2, дописывая к каждому в premise `trueEffects.premises.join(OR) OR (unknownEffects.premises.map { it AND E1.return == True}.join(OR))` -- это опишет нам возможные сайдэффекты из E2 + точные условия, когда это может произойти.
```

Проблема: схватили факториал по глубине в наивной имплементации! Теоретически, можно сэкономить, если не копировать вот эту здоровенную ноду: `trueEffects.premises.join(OR) OR (unknownEffects.premises.map { it AND E1.return == True}.join(OR))`, а создать ее один раз и везде выставлять ссылки на нее (потенциально может потом взорваться мозг, хотя вроде как не должен бы)

Алсо, можно решать это, если после каждой комбинации редуцировать ES до какого-то разумного размера.   Действительно, априори нас не очень интересуют какие-то очень конкретные code-paths, типа "первый аргумент равен тому-то, и если второй не равен тому-то и третий равен тому-то, и глобальная переменная такая-то, то выдаем то-то". Проблема таких клозов в том, что они покрывают очень малое пространство домена функции, а при этом на работу с ними мы тратим, напротив, много времени и памяти.
Поэтому в принципе можно считать, что ES у нас не слишком большие.

### Размышления

Recap: чего хотим:

- Эффекты, завязанные на значениях (контракты)
- Эффекты invoke-counter

- Текущий код пишется из предположения, что схемы всех функций мы знаем. В таком случае, нет необходимости запариваться с частичным применением - нам остается только анализировать вызовы, и можно считать, что они делаются полные
  - Однако нужно разобраться с переменными, про которые мы ничего не знаем.
  - Хотелось бы даже в таких случаях что-то понимать, например `isNull(unknown) == isNotNull(unknown)` (при условии хорошей ES isNull, конечно же)

## 16.02.2017

Хорошо бы задуматься о введении новых эффектов и их комбинировании.

- Безусловные эффекты являются частным случаем ES (у них в premise просто какой-нибудь stub, например, true)

- Возьмем, к примеру, эффект "вызываем callable такой-то столько-то раз", будем писать `Calls(callable, times)`

- Если мы знаем, что foo(x) всегда `Calls(f, 1)` и bar(x) всегда `Calls(f, 2)`, то хотелось бы как-то научиться понимать, что foo(bar(x)) всегда `Calls(f, 3)`

Как это работает на данный момент?

foo {
  true -> Calls(f, 1) & Returns(x)
}

bar {
  true -> Calls(f, 2) & Returns(x)
}

foo (bar(x)) {
  true -> Calls(f, 1) & Returns(bar(x))
} ⇒ {
  true -> Calls(f, 1) & Returns({
    true -> Calls(f, 2) & Return
  })
}

Чет жопа.

---------------------

Возможно, стоит не париться на этапе вычисления, и просто комбинировать все подряд, а потом сделать отдельную фазу упрощения, когда будет отрезать всякую хрень

Вообще, очень нужно понятие `Return-Value`, потому что нужно на него иногда ссылаться (особенно если хотим работать с неизвестными значениями). А работать с неизвестными значениями мы точно хотим, т.к. иначе нельзя будет в результате вызова узнать что-то про контекст колл-сайта, а тогда вообще все зря.


Или нет.
-----------------

TODO:

1. Улучшение архитектуры (сделать что-то, мать его, с этими свитчами!) - check

2. Редизайн для того, чтобы было удобней вводить новые эффекты (Как правило, каждый эффект представляет собой отдельную небольшую систему с несложными операциями комбинирования) - check

2. Механизм опроса выведенной системы - WIP
  "Я стою внутри if-a, и я знаю, что вернулось true". Дай-ка мне какую-то data-flow инфо, т.е. какая-то доп. инфа про переменные контекста.
  Или он может сказать: "Я заню, что вернулась такая-то хрень из enum-чика, а ну-ка расскажи мне чего"
  Т.о., компилятор всегда опрашивает **в обратную сторону**

  Или вот выполнился колл, расскажи какие функции вызвались

  Или вот выполнился колл, расскажи, что он мог бросить,

  Или расскжи, что получилось, если вот этот колл закончился удачно

3. Reducer - извлекалка простых и интересных зависимостей - WIP

4. Calls-count = definetly invoked. - check

5. Equals на эффект-схемах выглядит странно -- нужно как-то артикулировать, что это именно Equals на Return-ах этих схем (в равной степени относится и ко всяким And, Or и т.д.) - nvm

6. Flatten для `Returns`, `Throws`, и т.д. - check
7. Fix call-by-value! - WIP

## 17.02.2017

Великий Редизайн Эффектов - собсна, решаем проблему №2 выше.

**Соображение №1**. Нужно вводить типы эффектов.

- Большинство эффектов (пока что все?) не знают и знать не желают про другие типы
- Эффекты комбинируются только с эффектами такого же типа

Хочется получить такую архитектуру, в которой:

- Сам тип должен только определить логику комбинирования, т.е. тип `PrettyEffectType` должен реализовывать функцию вроде `combine : (left: List<PrettyEffectType>) -> (right: List<PrettyEffectType>) -> List<PrettyEffectType>`

- Тот, кто выполняет работу по компбинированю эффектов (тот, кто держит на руках две схемы эффектов) не должен знать о конкретных типах и том, как они комбинируются

Возможные варианты:

1. `Combiner` руками коллектит листы `left`, `right` для каждого типа, и потом делает на ком-то виртуальный вызов.
  - **Не понятно, на ком делать виртуальный вызов!!**.

2. `Combiner` на каждом эффекте из `lhs` дергает какой-то `combine'`, в который отдает *весь список* эффектов `rhs`.
  - Непонятная семантика: что должен делать `combine'`?
  - Наверное как-то должен модфицировать `destination`
  - Если сказать, что `combine'` должен оставить `destination` в таком виде, что про `this` в `lhs` можно забыть, то вроде ок
  - Потенциальный pitfall - если для принятия решения о комбинировании понадобится знать о еще каких-то эффектах *того же типа* из lhs.
  - Работает за квадрат (не то чтобы проблема, да и реализация №1 тоже в худшем случае работает за квадрат)
  - Работает за квадрат всегда (в отличии №1, который вырождается в квадрат только если оба списка состоят из эффектов одного и того же типа.)
    - Есть некотрое подозрение, что подобного рода вырождения будут частыми, т.к. пока что единственным неуникальным эффектом является `Calls`
      - Можно впендюрить мапу внутрь `Calls`, тогда он будет уникальным. **Так и надо бы сделать**
  - Получается эдакий pipline-pattern - некто (`Combiner`) берет некоторый объект (`rhs`) и дает его первому чуваку (эффект из `lhs`). Каждый из чуваков знает, что с этим объектом делать (правило для комбинирования), и выдает некоторый новый объект (`rhs` модифицированный с учетом текущего `this`), который будет обрабатывать следующий чувак.
  - **Кажется, что это наиболее разумный вариант**

3. Потенциальное упрощение - если постулировать, что в правой части может быть не более одного эффекта каждого типа и обязать каждый тип комбинироваться с собой, выдавая 1 (функия типа `(EffectType).(other: EffectType) -> EffectType`). Тогда просто упрощаются сигнатуры функций и логика комбинирования, которую нужно реализовать в каждом типе.
  **В целом очень хорошая идея, и кажется, что это не ограничит нас уж слишком сильно**

  ** А вот и хренушки**.

  Комбинируем `{a -> b && Throws(...)} == {x -> y && Returns(...)}`, получаем `{a && x -> b && y && (результат комбинации Throws и Returns)}`, что уже однозначно будет чушью, во чтобы `Throws` и `Returns` не скомбинировались, ибо сайд-эффекты `y` **не выстрелят**

  Забить на это нельзя, т.к. у нас появилась неконсистетная запись, это ничем не вылечить.

## 20.02.2017

В чем причина проблемы с комбинированием `Throws`?

Причина в том, что у нас есть неявный notion последовательности вычислений.

**Вариант №1**

Можно сделать его явным с помощью пары дополнительных условий в эффект-схеме:

  ```
  {
    rhs yields Throws(e) -> Throws(e)
    !(rhs yields Throws) && (lhs yields Throws(e')) -> Throws(e')
    !(rhs yields Throws) && !(lhs yields Throws)
        && rhs == lhs -> Returns true
    !(rhs yields Throws) && !(lhs yields Throws)
        && rhs != lhs -> Returns false
  }
  ```

- Приведет к сильному разбуханию эффект схем
- Нужно вводить `yields` и продумывать, как он работает и комбинируется
- Зато будут простые правила комбинирования эффектов

**Вариант №2**

Забить и сделать трейдофф: усложнить правила комбинирования эффектов, позволив влиять эффекту на другие. Зато получатся эффекты схемы проще.

- Вариант кажется разумным, т.к. есть основания полагать, что эффект-схемы будут создаваться чаще, чем новые эффекты
- В плане перформанса нельзя однозначно сказать, что лучше, т.к. в одном случае будут жирнее эффект-схемы (больше времени на обработку), а в другом случае -- сложнее правила комбинирования (больше времени на комбинирование)

**NB**. Последовательность вычислений присутствует при вычислении любых аргументов функций и операторов. Т.е. проблема не только при вычислении `Equals`, но и `Is`, `Then` (турникет эффекта), аргументы вызова `foo(bar(x), baz(x))`.
Это означает, что:
  a. Всем комбинаторам придется приседать с этим последовательным исполнением.
  b. Придется вкорячивать какую-то лыжу для вызова аргументов.

> Еще внезапно понял(вспомнил), что пока что аргументом сайд-эффектов могут быть только всякие константы, в то время как конечно хочется писать что-то в духе `Returns(foo(x))`. Поэтому каждый сайд-эффект должен уметь как комбинироваться (т.е. вмердживаться в список эффектов), так и флэттится (т.е. проваливаться внутрь эффект-схемы)

> Еще внезапно понял, что конструкция типа `NOT(EffectSchema)` ~~это нечто вообще не понятное~~ ладно, более-менее понятное.
`NOT` инвертирует `Return` на клозах, которые успешно завершаются, и не изменяет все остальные (например, `Throws`)

Итого:

- Есть операторы (`Not, And, Equal, Is`). Они должны уметь комбайнится (флэттится) от своих аргументов. Процесс вычисления запускает `Combiner`
- Есть эффекты (`Throws`, `Returns`, `Calls`, etc.). Они должны уметь:
  1. Комбайниться (флэттится) от своих аргументов. Это использует `Combiner` в ходе рекурсивных вызовов в левой и правой части клоза.
  2. Вмердживаться в список эффектов. Тоже использует `Combiner` при комбинировании клоза, хотя бы одним из аргументов которого является схема.
- И есть еще интересный подкласс эффектов - `Outcome`, которые комбинируются хитрее из-за пресловутой последовательности вычислений. Именно из-за этих пацанов приходится делать `merge` со сложной семантикой: им нужно знать, какие сайд-эффекты выстрелили сначала, а какие - потом. Потому что когда у нас появляется некоторый не-`Returns` исход, то это нужно корректно обрабатывать (например, если первые сайдэффекты упали со Throws, то вторые вообще не выстрелили, а вот наоборот неправда)
- Идея: кажется, что с такой логикой мы закладываемся на то, что `merge` в интервейсе `Outcome` будет дергаться только и исключительно при flattening левой и правой части клоза. Не проще ли тогда эту логику перенести в то, как флэттится `Then`? (заодно сделав его полноценным оператором)
  - Это более стройно с точки зрения дизайна, т.к. особенность комбинации этих эффектов больше проистекает не из их сущности, а из того факта, что `Then` вносит последовательность вычислений
  - Тогда вроде даже можно сделать правила комбинирования эффектов снова простыми

## 22.02.2017

Короче, дизайн с логикой комбинирования исходов в `Then` не понравился радикально, выпиливаем и откатываемся к варианту с более общей сигнатурой комбинирования эффектов. А кстати какой?
  - Хочется написать вариант: `(left: List<Effect>) -> (right: List<Effect>) -> Effect`, но не получится, т.к. левый throws
    никак не сможет дать знать остальному пайп-лайну о том, что надо бы больше ничего не комбинировать
      - Варирант: тащить через pipeline какой-нибудь `holder`, в который эффекты могут дописывать инфу: например, какой-нибудь флажок `leftFailed`
      - Кто будет смотреть на этот флажок?
      - Если другие эффекты, то это увеличивает `coupling`
      - Если только он сам, то толку нет - другие эффекты все равно не узнают, что им надо комбинироваться.
  - Другой вариант: `(destination: List<Effect>) -> (right: List<Effect>) -> List<Effect>`. Изначально `destination = left`.
  В результате `combine` выдается новый `destination'`, который передается дальше в пайплайн. Эффекты, которые комбинируются только с собой, должны просто поискать себя в `destination` и в `right` и скомбинироваться. `Outcome` могут поискать себя, плюс еще и дропнуть лишние эффекты
    - **Все равно проблема!**. Если `Outcome` комбинируются последними, то в `destination` уже может накомбинироваться куча всяких других, а нам нужно как-то оставить только `left`
  - Поэтому единственный вариант: `(left: List<Effect>) -> (right: List<Effect>) -> (destination: MutableList<Effect>) -> ()`.
    `combine` мутирует `destination`, глядя на `left` и `right`
    - Для не-`Outcome` можно написать перегрузку с более простым типом, отражающим локальность комбинации (придется ввести отдельный класс эффектов для этого)
    - **Все равно проблема!**. Если `Ouctome` комбинируются первыми, то после них в `destination` накомбинируется всякая хрень
  - Поэтому пришлось вводить состояние пайплайна, которое тащится через `flags`

Еще всякие технические мелочи:
- Приходится передавать в `merge` оператор, чтобы было что положить в два скомбинированных `Returns`
- Приходится вкорячивать в `EffectsPipelineFlags` уродливое `veto()` (по сути способ пробросить `return` через уровень абстракции)

## 23-26.02.2017

Имплементация вышеуказанного редизайна, поиск баг + немного выходных

## 27.02.2017

2. Механизм опроса выведенной системы - WIP
  "Я стою внутри if-a, и я знаю, что вернулось true". Дай-ка мне какую-то data-flow инфо, т.е. какая-то доп. инфа про переменные контекста.
  Или он может сказать: "Я заню, что вернулась такая-то хрень из enum-чика, а ну-ка расскажи мне чего"
  Т.о., компилятор всегда опрашивает **в обратную сторону**

  Или вот выполнился колл, расскажи какие функции вызвались

  Или вот выполнился колл, расскажи, что он мог бросить,

  Или расскжи, что получилось, если вот этот колл закончился удачно

3. Reducer - извлекалка простых и интересных зависимостей - WIP
4. Call-by-name - WIP
5. Убрать `AND` в качестве джойнера эффектов, т.к. это путает и неверно с
   семантической точки зрения (в некоторых частях системы `AND` -- это бинарный
   логический оператор, а в некоторых -- просто связка). На самом деле, это `cons`,
   он же `::`, т.е. оператор, который джойнит какие-то хрени в список.
   Кстати, если сделать тип `NodeList<T>` с двумя наследниками `Cons(NodeList<T>)`
   и `Nil`, то это может здорово сгладить некоторые корявые углы (типа `effectsAsList()`,
   возвращения пустого списка, кастов, и т.д.)



### Механизм опроса готовой эффект схемы

Несколько реквестов:

Общий вид:
- "Я знаю, что этот вот колл результировал в `Outcome` такой-то, дай **инфу**" (нужно продумать, в какой форме эта инфа будет выдаваться)

Более частные:
- "Колл вернул `X`, дай **инфу**"
- "Колл успешно завершился, но я не знаю, как именно, дай **инфу**"
- "Колл упал с эксепшеном `E`, дай **инфу**"
- "Колл упал, но я не знаю, как именно, дай **инфу**"

Пока что можно, наверное, считать, что `EffectSystem` просто выдает некоторый `EsInfoHolder`, в котором компилятор будет разбираться сам как хочет (i.e.`EsInfoHolder` является `white-box` для компилятора, что, в общем-то, reasonable, т.к. это часть их общего интерфейса)

Что должно быть в `EsInfoHolder`?

- Мапа из переменных в их значение/тип
- Мапа из функций в их call-counter'ы

Как собирать такие штуки?
- Проходимся по всем клозам
- У каждого клоза берем `Outcome`
- Проверяем, следует ли наш `Outcome` из того, что написан.
  - Здесь происходит некоторая нетривиальная арифметика на значениях. Кажется, в компиляторе должны были написать где-то чето похожее.
- Разбираем все премисы и добавляем их в мапу
  - Здесь происходит нетривиальный разбор булевского выражения, если в нем есть `OR`. Пока что будем считать, что их нет.
  - Здесь происходит и очень нетривиальное объединение утверждений о переменных, если таковое понадобится.
    - При объединении нескольких `Is` вылазят `Intersection-types`
    - При объединении нескольких `Equal` вылазят множества возможных значений.
    - А еще на все это можно вешать отрицания, что делает эту арифметику еще более нетривиальной
      - `A ∩ B ∩ (¬C)` -- это может вычисляться в очень интересные штуки. С другой стороны,
        вычислять это не обязательно, а проверять на конформность легко (вроде?)
      - `x = {5, 4, ¬3}` -- тоже самое, вычислять в нечто разумное сложно, проверять
        на конформность вроде понятно как.
  - Т.е., идея выдавать компилятору мапу "переменная - тип" вряд ли жизнеспособна, т.к. иначе нельзя ничего объединять.
  - Будем для первого прототипа считать, что объединять не надо.


> NB.  `EsInfoHolder` ≠ некорректный `EsInfoHolder`. Первый выдается тогда, когда мы ничего толкового не можем ответить
> компилятору. Второй выдается тогда, когда компилятор спросил что-то, про что мы уверены, что этого никогда быть не может. Например, если он спросил про `Returns(unit)` в `assert(false)`.

Как реагировать, если нас спросили про infeasible Outcome?
И вообще, когда бывает, что мы можем выдать пустой `EsInfoHolder`?

Вообще, семантика `EsInfoHolder` такова, что он содержит информацию о том, какой
должен был быть контекст, чтобы выполнилось то, что нас спросили. Т.е. это список
ограничений на контекст, которые должны выполняться, чтобы все было ок.

Соответственно, пустой `EsInfoHolder` допустим, если такой `Outcome` выполняется
всегда, т.е. не накладывает никаких ограничений на `Context`

Тогда надо понять, какой вид должен иметь `EsInfoHolder`, чтобы сказать, что
такой `Outcome` не достигается никогда.
  - Можно просто добавить особое значение (видимо, по имени `null`)
  - Было желание еще как-то передавать выполняемый `codepath`, но потом понял, что таких
    может быть несколько, да и в целом есть сомнения, что компилятору это интересно.
    Будет интересно - сам спросит.

Важные вопросы:
- Очевидно, в связи с появлением отрицаний и, потенциально, пересечений, интерфейс
  между компилятором и системой не может быть ограничен до "скажи, какое значение у этой
  переменной если то-то и то-то". Как тогда этот интерфейс делать? Можно ли договориться
  с компилятором, что он будет спрашивать не вопросы в духе: "Какое значение может быть
  у этой переменной?" или еще что-то такое, а "Правда ли, что эта переменная может иметь
  значение 3?". Полезно ли это? - забить.
- Как лучше справиться с call-by-name?
- Что делать с intersection types? -- забить.



TODO:
- Аппроксиматор
- создать список того, до какого состояния аппроксимирует аппроксиматор
- `Is` -- отрефакторить в унарный оператор, с полем 'Type' и убрать соответственно `EsType` из иерархии `EsNode`
- Идея как бороться с call-by-name:
  - Добавить некоторую временную переменную, соответствующую каждому коллу


- Kotlin Bytecode -- сделать что-то подобное, только чтобы показывало эффект схемы
  - ShowKotlinBytecodeAction
  - Hello, Idea -- научиться выводить строчку кода и файл.
- Потом спросить как по Location добыть PSI
- Потом посмотреть на структуру CallChecker, поразмышлять
- Попробовать написать CallChecker, который пройдется по коллу
- Еще можно смотреть `DeprecatedCallChecker`, он полезный. И `InfixCallChecker`.
- NB. CallChecker запускаются списком из DEFAULT_CALL_CHECKERS



## 28.02.2017 -- 03.03.2017
Вкорячиваемся в компилятор

## 03.03.2017
Ок, кое как работает.

Things to address:

- Аппроксиматор + список конечного состояния
- ~~Refactor Is~~. **DONE**
- ~~Refactor `And` into `Cons` in list of side-effects (or maybe even use list or whatever)~~ **DONE**
- ~~Refactor repository~~ - **DONE**
- ~~Как транслировать встроенные функции типа ==, is, и т.д.?~~ **DONE**
  - Можно написать фейковые функции для них, и вкорячить в `EffectSchemaGenerator` отдельным костылем
    - На самом деле, `EffectSchema` вообще лучше бы доставать из какого-нибудь отдельного объекта, типа `EffectSchemaProvider`,
      т.к. это может быть весьма нетривиальный процесс, да и генератор к нему никакого отношения не имеет, по сути
  - Можно вкорячить эти штуки непосредственно в `CallTreeGenerator`
    - Здесь это выглядит логично, т.к. `CallTree` и должно быть тем буффером между конструкциями компилятора и конструкциями системы эффектов
    - Нужно будет вводить дополнительные ноды в `CallTree`-иерархию.
    - **Пожалуй, получше вариант**
- Придумать чето с call-by-name
- Придумать чето с return-values (чтобы можно было писать всякие утверждение про результаты коллов)
- Внимательно подумать про захваты переменных и скоупы. Пока что переменные сравниваются по имени-значению, что означает, что вероятность коллизии при обходе поддерева крайне высока (пример: `foo(5, foo(10))` -- надо понимать, что второй аргумент `foo` разный для разных коллов)
- ~~Refactor Outcome as independant part of clause (presumably, will make combining more clear)~~ **DONE**
- Какой-то объект для обозначения неизвестности.
  - Ладно, если он используется вместо `EsConstant`, например, в аргументе `Returns`
  - А вот что, если он используется вместо `Outcome`?
    - Можно ли его туда пихунить? - Технически, должен быть механизм для того, чтобы выразить подобные случаи, иначе нельзя будет вызывать неаннотированные методы
    - Что делать, если мы комбинируем `Unknown`? Ну он пожирает все другие `Outcome`, но при этом подчиняется обычным правилам последовательных вычислений - если слева `Throws`, то эффекты справа не стрельнут. Если слева `Unknown`, то все не так тривиально. Если под `Unknown` скрывается `Throws`, то сайдэффекты справа не должны стрельнуть, а иначе они стрельнут, просто `Returns` будет неизвестным.
    - **Безопасно считать, что `Unknown` всегда `Throws`**, хоть мы и теряем некоторую информацию. **Теоретически, эту информацию мы можем отыграть обратно, если притащим последовательные вычисления**.
- `castToSchema()` -- formalize, think carefully, prove that it's OK


## 06.03.2017

- Refactor Outcome as independant part of clause (presumably, will make combining more clear)
  - Проблема: когда раньше все эффекты валялись в куче, `Outcome` можно было извлечь обходом поддерева. Теперь же у любой структуры должен появится дополнительный аттрибут `Outcome`. Но он даже не у каждой должен быть (откуда, например, у `Is` может быть `Outcome`?).
  - Кажется, что `Outcome` может быть у всего, у чего вообще могут быть сайд-эффекты
  - Кажется, что пора бы заиметь некоторый notion чего-то, у чего могут быть сайд-эффекты. Например, `Term` очень похож на именно эту самую абстракцию, только недодуманную до конца.
  - Однако `Term` не может быть той самой абстракцией, т.к. у `EffectSchema` нет `Outcome`
  - *Идея*: `EffectSchema` -- не терм. Но любой терм можно преобразовать в эффект схему (ровно также, как конверсия `List<T> -> T` не очевидна, а вот `T -> List<T>` вполне тривиальна)
  - Т.е. `Term` это набор чего-то, у чего есть сайд-эффекты
  - Но это, на секундочку, `Imply` в наших теримнах
  - Значит, нужно просто отерафачить `Imply` в какой-нибудь `Clause` и выпилить его наследования от бинопа
    - Хотелось бы сделать нечто в духе: `data class Imply(val premise: EsNode, val effects: List<Effect>, val outcome: Outcome)`.
    - Проблема в том, что у `Imply` бывают некоторые очень неудобные промежуточные состояния в ходе вычислений, в то время как `effects, outcome` бывают только у плоского `Imply`
    - Так что придется реализовывать его как `data class Imply(val left: EsNode, val right: EsNode)` с доп. геттерами, которые будут возвращать nullable-значения
    - И тогда, в принципе, можно его по праву считать и `BinaryOperator`
**NB**. Осталось такое ощущение, что выпиливание `Outcome` в отдельную иерархию было зря-зря.

## 07.03.2017

Some more refactoring

## 09.03.2017

TODO:
- Аппроксиматор + список конечного состояния
- Придумать чето с call-by-name
- Придумать чето с return-values (чтобы можно было писать всякие утверждение про результаты коллов)
- ~~Внимательно подумать про захваты переменных и скоупы. Пока что переменные сравниваются по имени-значению, что означает, что вероятность коллизии при обходе поддерева крайне высока. **Возможно, переход на `DataFlowValue` решит это**~~
- Какой-то объект для обозначения неизвестности.
  - Считать, что он всегда завершается и это все, что мы о нем знаем
- `castToSchema()` -- formalize, think carefully, prove that it's OK


### Грамматика

start
effectSchema
  : clause { SEMI+ }
  ;


clause
  : expression "->" effectList
  ;

expression
  : binaryOperatorCall
  : unaryOperatorCall
  : isExpression
  : literalConstant
  : SimpleName
  ;

binaryOperatorCall
  : expression binaryOperator expression
  ;

unaryOperatorCall
  : unaryOperator expression
  ;

binaryOperator
  : "&&"
  : "||"
  : "=="
  ;

unaryOperator
  : "!"

isExpression
  : expression "is" type

type
  : SimpleName

literalConstant
  : "true" | "false"
  : IntegerLiteral
  : "\"" stringElement* "\""
  : "null"
  ;

stringElement
  : RegularStringPart | EscapeSequence
  ;

Digit : ["0".."9"];

IntegerLiteral
  : Digit (Digit | "_")*
  ;

RegularStringPart
  : <any character other than backslash, quote, $ or newline>
  ;

EscapeSequence
  : "\" <any character other than newline>


## 22.03.2017

Вопросы:
  - Хорошо ли создавать `DataFlowInfo` через `DelegatingDataFlowInfo`?
  - Нормально ли, что у `DelegatingDataFlowInfo` поле `parent` изначально выставляется в
    `null` и потом никогда не меняется?
  - Правильно ли я понимаю, что в котлиновском дата-флоу отсуствует понятия "значения" переменной (кроме как для enum-чиков)? Т.е. если система эффектов каким-то раком вывела, что такая-то переменная равна, например, 42, то в дата-флоу это никак не протащить?
  - Дизайновый вопрос. Вот у меня есть `Collector`, который в мапки собирает всякие пары типа переменная-тип, переменная-значение, переменная-другая переменная. А потом по этим мапкам хожу еще раз и делаю всякие апдейты. Может, проще коллектору отдать `DataFlowInfo` и пусть он сам на нем дергает всякие `equate`, `establishSubtyping` и т.д.?
  - На этапе анализа колла мы также можем понять, что запрашиваемый исход вообще никогда не исполняется. Нужно ли это как-то артикулировать?

## 29.03.2017

Принцип работы CFA:
- `ControlFlowProcessor` по `KtElement` умеет генерить `Pseudocode`. Он знает про `BindingTrace`.
- Для этого он создает `CFPVisitor`, который обходит котлиновское AST и по нему строит `Pseudocode`. Он знает про `BindingTrace`, т.к. он `inner`-класс у `ControlFlowProcessor`
- Непосредственно генерация кода инкапсулируется в `ControlFlowInstructionBuilder`, инстанс которго хранит `ControlFlowProcessor` и по мере надобности выдает `CFPVisitor`у. Этот чувак ничего не знает про `BindingTrace`
  - Там еще какая-то муть со стеком билдеров из `ControlFlowInstructionsGeneratorWorker`ов, но я не понял, зачем она нужна (параллелить? скоупы?)
- Именно `CFPVisitor` рулит тем, какие инструкции генерить, и какая идет за какой.
- Потом `Pseudocode` при вызове `Pseudocode.postProcess` занимается довольно механической работой, расставляя ребра на следующие элементы (учитывает всякие джампы и прочее).
- Для `CallInstruction` *не предусмотрено*, что ребро из него может вести куда-то, кроме следующей по списку инструкции.
- Поэтому для обработки, например, `TODO()` есть отдельная логика в `CFPVisitor.checkNothingType`, которая работает примерно так:
  - Нас просят сгенерить код для элемента
  - Мы генерим код
  - А потом еще чекаем, не является ли тип этого элемента, случаем, Nothing
  - И если является, то дополнительно эмиттим джамп в егог.

Соответствено, думаю, лучшим вариантом будет положить наш чек где-то рядом. Например, после `checkNothingType` делать еще `checkUnseccussfullCall` или как-то так.
Как вариант, можно запихнуть это в `checkNothingType` и переименовать метод в более общий, типа `checkInfeasibleInstruction` или как-то так.

Вопросы:
- ~~У меня есть `KtElement`, я хочу проверить, не является ли он `KtCallExpression`. Видел в `checkNothingType`, что там сначала проверяют на `KtExpression`, потом делают `deparenthesize`, и только потом проверяют на конкретные типы. Надо всегда так делать? -- Забить~~
- ~~Когда я анализирую `Call` внутри `CallResolver`а, у меня есть `ResolutionContext` и `TypeResolver`, и вообще все на свете. А вот когда я вычисляю эффекты в `KotlinEffectsToolWindow`, у меня есть только `BindingContext`, полученный из `Call.analyze()`. Как следствие, я не могу отрезольвить типы, которые написанны строкой в аннотации `@Effects`.~~
  - Можно взять через слайс LEXICAL_SCOPE
  - TypeResolver взять у REsolutionFacade через `getFrontendService`
- ~~И вообще, хотелось бы весь зоопарк в EsResolutionUtils как-то привести к одному знаменателю. `ResolutionContext` кое где все равно нужен, так что наверное надо научиться добывать его там, где его нет~~.

- Intersection types это ведь легальная конструкция? В том плане, что мы можем в одном месте узнать что какая-то переменная `is A`, а в другом -- `is B`, и это +- легально, т.к. может же быть класс, который наследуется и от `A` и от `B` (видимо нужно наложить условие, что они -- интерфейсы)
  - Можно и нужно вытаскивать через 2 DFI и and на них

TODO:
- ~~Пока что нет дальнейшего анализа летящего исключения в try-catch блоках~~ Да хер с ним
- ~~Анричбл код репортится куда-то странно~~ Да хер с ним

---------------------------------------------------------------------------------
## Initialization Analysys

Принцип работы Initialization Analsys:
- Entry-point: `ControlFlowInformaionProvider.markUninitializedVariables()`
- Ключевой момент - вызов `pseudocode.traverse`
- Инструкции обходятся просто **подряд, безе учета ссылок next**
- Для `traverse` можно дополнительно дать мапку из инструкций во входящие-выходящие ребра. Идея делать так видимо родилась из желания сделать псевдокод простым парнем, содержащим список инструкций и не знающим ни про какие дата-контрол флоу. Соответственно, контрол флоу информация - это нашлепка поверх этого псведокода. Для того, чтобы их подружить, вот и нужна эта мапка `edgesMap`
- Т.о., в `pseudocode.traverse` все информация уже собрана и она только анализируется, извлекая полезные эффекты. Если мы хотим добавить какую-то информацию, то надо идти туда, где создается `edgesMap`
- А это происходит так:
  - `PseudocodeVariablesData` создается лениво, вызовом обычного конструктора.
  - `variableInitializers` создаются внутри `PresudocodeVariablesData` тоже лениво, вызовом `computeVariableInitializers()`
  - `computeVariableInitializers()` запускает обход псевдокода. Метод `pseudocodeVariableDataCollector.collectData()` принимает третим аргументом лямбду, которая должна взять инструкцию и ведущие в нее ребра и выдать пару ребер: входящее и выходящее, типа `InitControlFlowInfo`.
    - `InitControlFlowInfo` наследуется от `ControlFlowInfo` с небольшим добавлением логики для `when`. В свою очередь, `ControlFlowInfo` -- это просто мапка из `VariableDescriptor` в некоторый генерик `D` (для `InitControlFlowInfo` это собсна `InitControlFlowInfo`)
  - Входящее ребро получается вызовом `mergeIncomingEdgesDataForInitializers`.
    - В нем делается довольно несложный алгоритм: берутся все-все переменные, упомянутые во входящих ребрах.
    - Затем перебираются пары (переменная, ребро).
    - Если ребро хранит информацию об этой переменной, то давайте вольем эту информацию в итоговую инфу про переменную, иначе возьмем дефолтную инфу
      - А она определяется так: если переменная объявлена не в нашем скоупе, то считаем, что она уже кем-то инициализирована. Это более-менее корректно, т.к. если ее на самом деле никто не инициализировал, то с этим разберутся в ее скоупе
      - Мерджится по некоторым более-менее логичным правилам. Поверим на слово, что ифики написаны правильно
    - Еще там есть некоторый анализ с объявлением, но на него забьем пока, он нас не интересует
  - Нас больше интересует метод `addVariableInitStateFromCurrentInstructionIfAny`
    - Туда дают только что смердженные входящие ребра - что и логично, надо же куда-то добавлять контрол флоу инфо.
    - Начинается все с лыжи для exhaustive when.
    - Дальше смотрим, если текущая инструкция не про переменную, то пропускаем
    - Елси про переменную, то смотрим ее тип. Пусть это инструкция записи.
      - Если это пропертя чужого класса, то считаем ее уже инициализированной. Опять же, разберутся в том скоупе
      - Дальше создаем новый `VariableControlFlowState`. Поскольку мы только что поняли, что мы написали в эту переменную, то мы создаем контрол флоу, оповещающий о том, что эта переменная инициализирована.
        - Кстати, `create()` вызывает у меня лютую боль - внешний контракт метода определяет выбранная перегрузка. По сути, это должны быть разные методы! Если переименовать конкретно эту перегрузку в `createInitialized()`, то все станет в 100 раз легче
    - Пусть теперь это инструкция объявления переменной
      - Тогда возьмем уже готовую инфо из входящих ребер либо же возьмем дефолтное значение
      - Дальше очень странный иф, который я понимаю только на половину (вторую половину). Если переменная не объявлена, то объявим. А вот нафига там какой-то чек `!mayBeInitialized()`, я не понимаю
- Из всей этой истории становится понятно, что шансов вкорячится куда-нибудь по тихой у нас не очень много. Вариантов, по сути, два:
    1. Или в `addVariableInitStateFromCurrentInstructionIfAny` проверять колл, анализировать его эффектами и если что руками запускать дополнительный обход внутренностей лямбды. Что хоть убей не выглядит хорошей идеей.
    2. Или врезаться прямо в генерацию псевдокода, расширяя правила генерации.



В конечном счете, все равно нужно лезть в контрол флоу, чотбы собрать инфу об инициализации

Как было:
- Т.к. последовательность инструкций в псевдокоде определяется довольно тривиально (по большей части последоватлеьно), то перед тем, как генерить код для локальной декларации, нужно подпрыгнуть в буквальном смысле и сгенерить джамп, обходящий тело декларации
- Соответственно, стартовые вершины локальных деклараций в контрол-флоу графе висят ~~как вершины без~~ ~~входщих ребер. Тела локальных деклараций сливаются в SINK.~~ вообще отдельно, к declaration-site относятся весьма посредственно.
- Чтобы обходить и тела деклараций тоже, `PseudocodeTraverser.traverse` отдельно обрабатывает `LocalFunctionDeclarationInstruction`, рекурсивно запуская обход внутрь

Что набросал Миша:
- Не генерить джамп обходяший тело локальной декларации в `ControlFlowProcessor`
  - Этот джамп Nondeterministic в том смысле, что у этой инструкции в каком-то смысле два некста: просто следующая инструкция (заходящая в тело декларации) и цель джампа, обводящая тело/
- Если убрать только этот джамп, то весь код после декларации оторвется от общего контрол-флоу графа, став анричабл (т.к. тело деклорации выводится в синк).
- К сожалению, логика генерации некст-инструкций у локальных деклараций вшита на более низком уровне, в `PseudocodeImpl.postProcess() -> processInstruction() -> <anonymous-visitor>.visitLocalFunctionDeclarationDescriptor()`
- Вот там-то мы и изменим, направив некст не в синк, а в обычную следующую инструкцию

Логические проблемы:
- Вообще говоря, мы должны посещать тело локальной декларации не в том месте, где оно объявлено, а там, где вызвалась лямбда, спровоцировавшая посещение этой декларации. Иначе можно легко поймать false-negative:
  ```java
    val t: Int
    val block = { t = 10 }
    println(t)  // t is not yet initialized here
    run(block)  // only here
  ```
- Увести контро флоу от callee внутрь declaration еще можно, а вот выводить будет прикольно, т.к. получается, что если лямбда дергается несколько раз, то next для тела будет несколько инструкций.


Что нам нужно сделать по-хорошему?
- На колл-сайте нужно посмотреть на аргумент и понять, что он - definitely invoked lambda
  - Это тривиально делается в `ControlFlowProcessor.CFPVisitor.generateCall`
- Дальше нужно завести контрол-флоу внутрь тела декларейшена
  - Для этого нужно сгенерить джамп
  - Для этого нужно понять, куда этот джамп должен прыгать
  - Поэтому надо бы устроить мапку KtDeclaration -> Label
  - При обработке декларации нужно добавлять лейбл
- Дальше нужно вывести контрол-флоу их тела декларейшена
  - Для этого приедтся добавить какой-т ометод в `LocalFunctionDeclarationInstruction`, типа `addOnceInvokingCallee`
  - При вызове он будет добавлять в `nextInstructions` декларации еще одну, которая идет после декларейшена
  -
------------------------------------------

TODO:
- ~~DataFlow для ифов~~
- ~~DataFlow для When-ов~~
- Add types to the list of possibel args of Return in grammar
  - Rewrite `whenSimpleIs`
- Definetly Invoked lambdas
- Smart casts in collections
- Effects inference from lambdas
- Think about merging effects and explicitly bringing notion of `And` and `Or` operators in process of merging because it influences result heavily. Currently, everything is written like we have only AND, but in fact we do want to merge effects with OR sometimes (namely, when we want to make a section of EffectSchema at some condition). This **will** be needed when we will want to introduce `at`-operator in the system.


--------------------------------------------

### Плаваем в `checkValReassignment`

1. Первый чек -- это про то, что можно переприсвоить val внутри геттера. Например, вот так:
```
class ValReassignmentInGetter {
    val t: Int = 1
    	get() { field = 5; return field } // WHAT THE FUCK ??
}
```

2. Второй чек -- это про то, что если поле -- var, и у него есть сеттер, но он невидимый в текущем скоупе, то это ошибка. Хрен ли тут делает этот чек, не понятно.

3. Дальше проверяется условие:
```
if ((mayBeInitializedNotHere || !hasBackingField || !isThisOrNoDispatchReceiver || captured) &&
            variableDescriptor != null && !variableDescriptor.isVar)
```
Если оно не выполняется, то все, до свиданья, все ок. Действительно, если это не выполняется, то:
  - `mayBeInitializedNotHere = false`. Это про то, что есть ли шанс, что данное поле было где-то инициализировано не здесь. Это `false` для локальных переменных, например. Понятно дело, что если хотя бы это `true`, то нужен доп. анализ
  - `hasBackingField = true`. Это про, собственно, существование backing field. Оно может не существовать для синтетических пропертей, типа `val isEmpty: Boolean get() = this.size == 0`. Понятно дело, что если хотя бы это `false`, то надо смотреть, не пишем ли мы в синтетическое проперти
  - `isThisOrNoDispathReceiver = true`. Смысл понятен из названия. Зачем оно тут надо - не понятно. Более того, кажется, что если `isThisOrNoDispatchReceiver = false`, то и `mayBeInitializedNotHere = true`.
  - `captured = false`. Понятно из названия. Понятно дело, что если `true`, то надо проверять, не пишем ли мы в захвате.

4. Если выполняется, то делаем чек `hasReassignMethodReturningUnit`. Это про то, что даже если у нас поле `val`, мы можем вызвать на нем операторы вида `?=`, буде такие у него имеются.

5. Если мы не смогли доказать в прошлом чеке, что это легитимный `reassignment`, то это уже точно ошибка. Осталось понять, куда ее репортить.
  - `captured && !mayBeInitializedNotHere && hasBackingField && isThisOrNoDispatchReceiver` -- тогда это переприсваивание через захват
  - иначе обычное переприсваивание
  - И еще на это все наворачиваем машинерию с `isThisOrNoDispatchReceiver` и `varWithValReassignErrorGenerated` просто для того, чтобы не репортить по сто раз на одну и ту же переменную эту ошибку. Косметика.

Мораль, которая интересует конкретно нас: пока что `ControlFlow` репортит `capturedValInitialization` если, грубо говоря, мы захватили локальную переменную.

Это значит, что дешево пофиксить это не выйдет:
  - Можно попытаться как-то раскорячить сборку Control Flow Infomartion таким образом, чтобы она репортила `captured` только если захват произошел из лямбды, про которую мы не знаем, сколько раз она вызывается
    - Большой минус в том, что это сильно нарушит семантику `captured`
  - Нормальное решение заключается в том, чтобы собирать еще одну диагностику: `definitelyInvoked` (`invokedExactlyOnce`) скажем, и добавить ее как доп. условие для идентификации ошибки.
  - По сути, все равно придется разбираться, как и где вклинить обращение в систему эффектов с вопросом: "а точно ли вызовется лямбда из этого колла". Поэтому первый вариант на самом деле не особо дешевле второго.

Куда вкорячить обращение в систему эффектов?
  - `isCapturedWrite` просто сравнивает, в каком скоупе произошла запись и объявление переменной (со скидкой на то, что анонимные объекты пропускаются)
  - Можно не лезть в ~~жопу~~ недра контрол флоу аналайзера, а сделать обращение в систему эффектов прямо в `checkValReassignment`
    - Потенциальный минус в том, что если бы мы прокинули честное ребро внутрь лямбды, то мы бы получили (?) много всяких плюшек автоматически. Или не получили бы.
  - **Проблемка**: чето тип лямбды не резольвится. Такое ощущение, что `CallResolver` отрабатывает раньше, чем `FunctionsTypingVisitor` (что, впрочем, и логично)
    - Это, на самом деле, довольно серьезная проблема, т.к. поулчается, что мы должны выполнять некоторый анализ в`CallResolver`е, но если там есть лямбда, то нифига мы проанализировать не можем
    - Как бы наверное и фиг с ним, иногда не будем что-то выводить, но вообще надо думать про это в будущем.
    - И получается, что в `ControlFlowInformationProvider` надо запускать весь вывод еще раз
      - Кеши нам помогут
      - Следует заметить, что в конкретной ситуации с лямбдами оверхед в основном на резольвинг схемы, а не на вычисления на колл-сайте: мы даже не успели `CallTree` построить, и уж тем более повычислять что-то.
      - Поэтому таки да, кэши нам помогут
  - А еще надо каким-то раком получить верхний колл в иерархии вложенных коллов
    - **На самом деле я тупанул и верхний получать не нужно, достаточно непосредственно предка лямбды**
    - Но раз уж исследовал этот вопрос, то законспектирую:
      - Если лямбда передается как аргумент в вызове функции, то ее родитель - это `KtLambdaArgument`, наследник `KtValueArgument`. Кажется, что ничего другого быть не может, т.к. никакого экспрешшена с лямбдой не состряпаешь.
      - Судя по всему, если у функции не один параметр, то следующим родителем может быть `KtValueArgumentList`. Если параметр один, то его нет.
      - А у него предок это `KtCallExpression`
  - **Еще проблемка**: у `ControlFlowInformationProvider`а нет `TypeResolver`а, что тоже вполне понятно.
    - Утверждается, что ему он и не нужен. Дейсвтиетельно, `typeResolver` нужен чтобы отрезольвить сигнатуру эффект схемы. Утверждается (?) что это уже было один раз сделано в `CallResolver`, просто мы ленивые и не устроили себе кэш.
    - Поэтому сделаем специальный метод

-------------------------------------------------------------------------------

Вопросы:
  - Есть ли смысл собирать информацию вида `x !is T` и употребляется ли она хоть как-то?
  - В `PatternMatchingTypeingVisitor.checkWhenCondition.anonObject.visitWhenPattern` все как-то немного криво получается.
    - Приходится два раза резольвить тип (проблема ли это?) - внутри `checkTypeForIs` и внутри эффект схемы. В целом, повторяющаяся логика
    - `ConditionalDataFlowInfo` нужная штука. Пока что просто сделал его публичным, но наверное, надо более аккуратно как-то все сделать
      - На них тоже хорошо бы уметь делать `and`, `negate` с очевидной семантикой.
    - Лыжа с `isNegated` и обменом полей у `ConditionalDataFlowInfo` - неоч.
  - Че такое RttiInformation и зачем она в `visitWhenPattern`? Что проверяют чекеры?
  - Какие полезные классы эквивалентности `Calls` можно выделить? `NOT_INVOKED` (не стреляют сайдэффекты, анричабл код, етк), `EXACTLY_ONCE` (можно инициализировать вал), `AT_LEAST_ONCE` (можно иницаилизировать вар), еще какие-то? Имеет ли смысл `AT_MOST_ONCE`?\
  - Для того, чтобы получить смарткасты в коллекциях, нужно научиться подправлять тип экспрешшона (колла) на основе эффектов.
    - Суть в том, что в dataFlowInfoForArguments хранится тайп-инфо про весь колл, но оно почему-то не исользуется, а просто берется return-type.
    - Я это поборол, вкорячив небольшой чек в `CallExpressionResolver:227`
    - Но выглядит как-то странно немного


-----------------------------------------------------------------

TODO для смарткастов в коллекциях:
- ~~Нужно ввести эффект, который бы утверждал что-то про тип некоторой переменной~~
  - ~~Это несложно, например, `Hints(x, Int)`~~-
- ~~Нужно ввести способ ссылаться на return-Value~~
  - Это сложней, т.к. надо откуда-то взять нужное `DataFlowValue`
  - Можно заметить, что `EffectSchema` всегда соответствует некоторому экспрешшену. Нужно только явно сохранить где-то это знание
    - Проблема в том, что во всякие операторы тоже надо будет тащить экспрешшоны
  - Тогда биндер должен будет зайти внутрь хинтс и корректно переписать переменные
  - По сути, нужно просто в мапке подстановок корректно поддерживать отображение `SomeSpecialReservedVariableForReturn -> actualDataFlowValue`
  - Какой-нибудь стек-хуек
  - Ну и в грамматику надо будет добавить синтаксис для ссылки на это значнеие
  - И какой-нибудь объект-синглтон в который будет резольвится ссылка на ретурн-значние. И чтобы equality норм было на нем
- ~~Придумать как этот эффект будет комбинироваться~~
  - Тривиальный мердж мапок а la `EsCalls`
- Добавить синтаксис для сечения схемы в некоторой точке.
  - Оператор `at`?
- Научиться вычислять этот оператор.
  - Должно быть не сложно, ибо он действует на двух аргументах вполне конкретного типа, и только на них
  - Продумать, что он выдает. Кажется, что можно и эффект схему, хоть и немного глупо выглядит
- Добавить понятие вызова в систему. А то мы хитро замяли этот вопрос, а это важно.
- Добавить синтаксис для взятие типа некоторой переменной у эффект схемы
  - Оператор `typeOf`
  - Где-то здесь мы вновь понимаем, что тип все-таки хотелось бы иметь в иерархии нод - потому что `typeOf` должен возвращать тип, но с другой стороны, конструкции `(f at Returns(true)) typeOf arg` видимо часто будут жить как аргумент какого-нибудь `Hints`

--------------------------------------------------------------------------

Recap:
1. Сделал definitely-invoked lambdas.
  - Идея в том, чтобы завести контрол флоу в локальную декларацию и потом вывести оттуда
  - Работает только для анонимных лямбд, переданных как аргумент
  - Для именованных callable так "просто" не выйдет, см. пример в проекте
2. Пофиксил багу в When.
  - Она была неожиданно глубокой и связанной с правильным сбором информации через 'and' и 'or'
3. Попытался сделать collections-smartcasts
  - Еще надо доделать некоторые моменты (см. вопросы) и поддержать больше expression-ов в лямбдах (например, if)
    - Скажем, всякие уточнения типов мы сделаем, и если ~~выкинуть весь код к херам и написать заново~~ аккуратнее передизайнить, то будет даже съедобно. Но как это расширять до более интересных случаев - глубоко не ясно
    - В частности, у нас нет понятия **размера коллекции**, которое является очень важным при анализе кода, работающего с коллекциями. Действительно, мы умеем говорить, что мы выдаем коллекцию, для каждого элемента которой верен предикат. Но это не дает нам никаких оснований говорить о том, сколько раз он вызовется и какие его сайд-эффекты выстрелят
  - Альтернативный путь - это все-таки притащить нотацию со множествами
    - Из минусов - это, по сути, это даже еще более самое прибивание гвоздями некоторого функционала. У нотации со множествами нет никакой надежды стать полезной для чего-либо, кроме коллекций
    - Из плюсов - гвозди ровнее и более математичные
    - Вообще это требует детального сравнения и исследования


Вопросы:

1. Expose ConditionalDataFlowInfo?
2. Для того, чтобы получить смарткасты в коллекциях, нужно научиться подправлять тип экспрешшона (колла) на основе эффектов.
  - Суть в том, что в dataFlowInfoForArguments хранится тайп-инфо про весь колл, но оно почему-то не исользуется, а просто берется return-type.
  - Я это поборол, вкорячив небольшой чек в `CallExpressionResolver:227`
  - Но я уверен, что это должно работать не так. Да и смарткаст не подсвечивается, а хотелось бы
3. Большая проблема: я анализирую колл и записываю DFI в `doResolveCall` в `CallResolver`. Судя по всему, в этот момент еще не разрезолвены лямбды, фигурирующие в колле
  - В частности, не могу взять дескриптор лямбды через `BindingContext.get(DECLARATION_TO_DESCRIPTOR)`
  - Он нужен для того, чтобы взять лямбды и осуществить подстановку в теле лямбды, убирая абстракцию по параметрам лямбды (потом сделаем еще одну подстановку во всей схеме вызова, убирая абстракцию по параметрам calee)
  - Решение: идти в `CallCompleter` и запускать всю шарагу там. Он будет вызываться для всех коллов, а нам хотелось бы только от верхнего. Для этого смотреть на CONTEXT_DEPENDENCY (кажется = INDEPENDENT для верхнего колла)

4. У LEXOCAL_SCOPE попросить Classifier для List. У него потом можно взять typeConstructor и потом ему дать дженерик аргументы и полуится тип.

5. Хорошо оттестить примеры

## Как писать диплом?

- Название
- Аннотация - то, как будет индексироваться работа. Должна пояснить, хочет ли человек читать работу. Очень краткое описание: "Задача важная, мы рассматрвиаем такие-то подходы, и у нас все получается"
- Введение. Рассказать человеку, который заинтересовался, почему ему следует прочитать всю работу. "О чем?", немного "Как", "Почему актуально", какие вопросы были рассмотрены, о чем задумались, какие подходы были рассмотрены. 1-2 стр. Если здесь хочется какое-нибудь определение, то надо бы его пересказать разумными словами.
- Глава 1
  - Обзор. < 20
    - Теоретические основы
    - Обзор статей.
    - Актуальность.
    - Постановка задачи: цель (одно предложение) и задачи (какими путями мы будем идти к цели). Можно вынести на уровень глав, но не нумеровать как главу)
- Глава2.
  - Описание подхода. Более-менее теоретическая, идейная часть работы. Здесь могут жить определения, правила, семантика.
- Глава 3.
  - Реализация. Как мы все это сделали в деталях. Со всеми мучительными рассуждениями о тяжелой действительности, ограничениях платформы.
- Глава 4.
  - Измерения ("Evaluation"). Как оно работает, прогнали на таких-то тестах. Здесь все числа о быстродействии. Сравнение с существующими аналогами (легче с колиественными. Качественные сравнения - тяжелей, но хорошо если в духе "У нас поддерживается вот такой кейс, а больше ни у кого не поддерживается"). Все сравнения интерпретировать: "Почему медленней? Почему быстрее?". Для качественного сравнения по большому количеству параметров сделать табличку, чтобы хотя бы количество галочек в строке можно посчитать.
- ...
- Заклюение. Подведение итогов: повторить более-мнее то, что было во введении. "Мы делали то-то, получили результы такие-то, мы молодцы потому-то потому-то". Future work. Лучшее заключение - которое читается и понятно человеку, который не читал вообще ничего кроме заключения. Следить за тем, чтобы слова про цель из введения совпадали со словами с итогами из заключения (типа цели достигнуты) - чтобы не занудничали.
- Список литературы. Должен быть печатный. 20 links - too small. Для хорошей рабоыт на 60 стр. >40 ссылок
- Приложения. Выносится все, что длинное и не влезает в основной текст. Отсылать туда с задумкой, что туда не пойдут: "Если вы хотите больше подробностей, то идите вот туда" < 20


- Объяснение data-flow analysis куда-нибудь вытащить (поближе к тому, где это непосредственно будет нужно)
- Более явно артикулировать возможности рассмотренных систем
- Рассказ про Котлин переставить после обзора статей, написать небольшую подводку
- ~~Меньше воды в аннотации (меньше вычурных оборотов). Больше смысла, некоторые термины объяснить (в частности, межпроцедурный анализ)~~
- Пофиксить табличку 1 (смерджить последние две строки)
- Более явно и жирно артикулировать, что у нас будут условные эффекты.
- СДелать список мыслей, которые мы хотим выразить в названии. По нему предложить пару названий.



# Пишем текст

Вопросы:

- Как писать side-effect? "Побочный эффект"? Транслитерировать в "сайд-эффект"? Или вообще не париться и писать "side-effect"?
