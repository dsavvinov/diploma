## 13.02.2017

### `Is`-оператор.

Рассмотрим ситуацию: `{ bla-bla -> Returns(value, returnType) } is rhs -> bla-bla`

**Важное наблюдение:** верхней границей `returnType` является тип из сигнатуры вызываемой функции. В процессе работы системы эффектов `returnType` может уточняться, т.е. спускаться вниз по иерархии типов.

**Следствие 1**. Если `returnType` и `rhs` находятся в разных ветках иерархии, то результат `Is` -- точно `False`.

**Следствие 2**. Если `returnType` -- потомок `rhs`, то результат `Is` -- точно `True`

**Следствие 3**. Если `rhs` -- потомок `returnType`, то результат `Is` не может быть выведен статически.

> Нужно как-то различать тип, который мы получили из сигнатуры и тип, который был декларирован в эффекте.

> В первом случае в ситуации №3 мы действительно ничего не знаем о результате `Is`.
> Пример: `fun foo(): Any? = "haha, tricked you!"`

> Во втором же случае в ситуации №3 мы можем с уверенностью заявить, что результат `Is` -- `False`.

> В конечном итоге, это упирается в то, что мы хотим знать -- может ли `returnType` быть еще подвинут вниз, или это уже конечная станция и дальше он ну никак не уточнится (бывает ли такое?)

--------

- А еще неплохо было бы наверное договориться, что любой Conclusion содержит или `Returns` (если ничего не знаем, то с пустыми полями -- он просто будет показывать завершение функции) или `Throws`.

## 14.02.2017

- Код в `Evaluator` при визите `Is` выглядит настолько стремно, что аж плохо. Нужно подумать, куда вытащить `evaluateIs`. Может быть, интерфейс `Evaluatable`?

- `Effect` на самом деле является еще одной связкой с семантикой "влечет", типа `Then`.

## 15.02.2017

- Идея обобщения `Effect` до связки с семантикой импликации нравится все больше:
  - Описание того, что происходит при вычислениях в эффекте становится намного более ясным и понятным - просто еще несколько правил вывода для еще одного комбинатора.
  - Исчезают уродливые конструкции вида `true → ...` для обозначения безусловных эффектов (выполняются всегда).
  Причина их появления была в том, что раньше `EffectSchema` -- это всегда список эффектов. Теперь же `EffectSchema` -- это просто пучок детей типа `EsNode` (можно конкретизировать дальше, чтобы запретить всяким константам быть непосредственными детьми схемы), поэтому абсолюно корректно, если `EffectSchema` имеет ровно одного ребенка (например, `Returns(42)` для константной функции, или `throws RuntimeException` для функции делящей на ноль и т.д.)

- Пока пишем так, потом зарефачимся если чо.

- Стойкое ощущение, что для симметрических комбинаторов понадобится double-dispatching, т.к. даже если тем или иным способом сделать `evalute()` виртуальным, то тип правой части все равно придется уточнять для вызова корректной перегрузки.

Алгоритм комбинации двух схем **E1** и **E2**

```java
for (effect : E1.effects) {
  r = getReturnValue(effect)
  p = effect.premise
  c = effect.conclusion without Returns-clause
  switch(r) {
    case TRUE: // дописать `p` к каждому эффекту E2 слева и дописать `c` к каждому эффекту E2 справа
    // Действительно, в результате выполнения `p`, `E1` возвращает True (и вызывает некоторые сайд-эффекты `c`), и как следствие, вызывает правую часть.
    case FALSE: // добавить эффект вида: `p -> c`
    // Действительно, если выполнится `p`, то `E1` вернет False, и правая часть не запустится, НО выстрелят сайдэффекты `c`
    case UNKNOWN: // дописать `p AND E1.return == True` к каждому эффекту E2 слева и `c` справа
    // добавить эффект вида `p and E1.return == False -> c`
    // Действительно, просто рассмотрели два случая и сделали то, что делали бы при точно известном значении.
  }
}
```

Непонятно как имплементить!

Фикс:

```java
trueEffects = // все эффекты из E1, которые возвращают True
falseEffects = // все эффекты из E1, которые возвращают False
unknownEffects = // все эффекты из E1, которые что-то возвращают, но неизвестно, что именно

1. Копируем в результирующую схему все из E1 -- это опишет все сайдэффекты E1
2. Дополнительно копируем все эффекты из E2, дописывая к каждому в premise `trueEffects.premises.join(OR) OR (unknownEffects.premises.map { it AND E1.return == True}.join(OR))` -- это опишет нам возможные сайдэффекты из E2 + точные условия, когда это может произойти.
```

Проблема: схватили факториал по глубине в наивной имплементации! Теоретически, можно сэкономить, если не копировать вот эту здоровенную ноду: `trueEffects.premises.join(OR) OR (unknownEffects.premises.map { it AND E1.return == True}.join(OR))`, а создать ее один раз и везде выставлять ссылки на нее (потенциально может потом взорваться мозг, хотя вроде как не должен бы)

Алсо, можно решать это, если после каждой комбинации редуцировать ES до какого-то разумного размера.   Действительно, априори нас не очень интересуют какие-то очень конкретные code-paths, типа "первый аргумент равен тому-то, и если второй не равен тому-то и третий равен тому-то, и глобальная переменная такая-то, то выдаем то-то". Проблема таких клозов в том, что они покрывают очень малое пространство домена функции, а при этом на работу с ними мы тратим, напротив, много времени и памяти.
Поэтому в принципе можно считать, что ES у нас не слишком большие.

### Размышления

Recap: чего хотим:

- Эффекты, завязанные на значениях (контракты)
- Эффекты invoke-counter

- Текущий код пишется из предположения, что схемы всех функций мы знаем. В таком случае, нет необходимости запариваться с частичным применением - нам остается только анализировать вызовы, и можно считать, что они делаются полные
  - Однако нужно разобраться с переменными, про которые мы ничего не знаем.
  - Хотелось бы даже в таких случаях что-то понимать, например `isNull(unknown) == isNotNull(unknown)` (при условии хорошей ES isNull, конечно же)

## 16.02.2017

Хорошо бы задуматься о введении новых эффектов и их комбинировании.

- Безусловные эффекты являются частным случаем ES (у них в premise просто какой-нибудь stub, например, true)

- Возьмем, к примеру, эффект "вызываем callable такой-то столько-то раз", будем писать `Calls(callable, times)`

- Если мы знаем, что foo(x) всегда `Calls(f, 1)` и bar(x) всегда `Calls(f, 2)`, то хотелось бы как-то научиться понимать, что foo(bar(x)) всегда `Calls(f, 3)`

Как это работает на данный момент?

foo {
  true -> Calls(f, 1) & Returns(x)
}

bar {
  true -> Calls(f, 2) & Returns(x)
}

foo (bar(x)) {
  true -> Calls(f, 1) & Returns(bar(x))
} ⇒ {
  true -> Calls(f, 1) & Returns({
    true -> Calls(f, 2) & Return
  })
}

Чет жопа.

---------------------

Возможно, стоит не париться на этапе вычисления, и просто комбинировать все подряд, а потом сделать отдельную фазу упрощения, когда будет отрезать всякую хрень

Вообще, очень нужно понятие `Return-Value`, потому что нужно на него иногда ссылаться (особенно если хотим работать с неизвестными значениями). А работать с неизвестными значениями мы точно хотим, т.к. иначе нельзя будет в результате вызова узнать что-то про контекст колл-сайта, а тогда вообще все зря.


Или нет.
-----------------

TODO:

1. Улучшение архитектуры (сделать что-то, мать его, с этими свитчами!) - check

2. Редизайн для того, чтобы было удобней вводить новые эффекты (Как правило, каждый эффект представляет собой отдельную небольшую систему с несложными операциями комбинирования) - check

2. Механизм опроса выведенной системы - WIP
  "Я стою внутри if-a, и я знаю, что вернулось true". Дай-ка мне какую-то data-flow инфо, т.е. какая-то доп. инфа про переменные контекста.
  Или он может сказать: "Я заню, что вернулась такая-то хрень из enum-чика, а ну-ка расскажи мне чего"
  Т.о., компилятор всегда опрашивает **в обратную сторону**

  Или вот выполнился колл, расскажи какие функции вызвались

  Или вот выполнился колл, расскажи, что он мог бросить,

  Или расскжи, что получилось, если вот этот колл закончился удачно

3. Reducer - извлекалка простых и интересных зависимостей - WIP

4. Calls-count = definetly invoked. - check

5. Equals на эффект-схемах выглядит странно -- нужно как-то артикулировать, что это именно Equals на Return-ах этих схем (в равной степени относится и ко всяким And, Or и т.д.) - nvm

6. Flatten для `Returns`, `Throws`, и т.д. - check
7. Fix call-by-value! - WIP

## 17.02.2017

Великий Редизайн Эффектов - собсна, решаем проблему №2 выше.

**Соображение №1**. Нужно вводить типы эффектов.

- Большинство эффектов (пока что все?) не знают и знать не желают про другие типы
- Эффекты комбинируются только с эффектами такого же типа

Хочется получить такую архитектуру, в которой:

- Сам тип должен только определить логику комбинирования, т.е. тип `PrettyEffectType` должен реализовывать функцию вроде `combine : (left: List<PrettyEffectType>) -> (right: List<PrettyEffectType>) -> List<PrettyEffectType>`

- Тот, кто выполняет работу по компбинированю эффектов (тот, кто держит на руках две схемы эффектов) не должен знать о конкретных типах и том, как они комбинируются

Возможные варианты:

1. `Combiner` руками коллектит листы `left`, `right` для каждого типа, и потом делает на ком-то виртуальный вызов.
  - **Не понятно, на ком делать виртуальный вызов!!**.

2. `Combiner` на каждом эффекте из `lhs` дергает какой-то `combine'`, в который отдает *весь список* эффектов `rhs`.
  - Непонятная семантика: что должен делать `combine'`?
  - Наверное как-то должен модфицировать `destination`
  - Если сказать, что `combine'` должен оставить `destination` в таком виде, что про `this` в `lhs` можно забыть, то вроде ок
  - Потенциальный pitfall - если для принятия решения о комбинировании понадобится знать о еще каких-то эффектах *того же типа* из lhs.
  - Работает за квадрат (не то чтобы проблема, да и реализация №1 тоже в худшем случае работает за квадрат)
  - Работает за квадрат всегда (в отличии №1, который вырождается в квадрат только если оба списка состоят из эффектов одного и того же типа.)
    - Есть некотрое подозрение, что подобного рода вырождения будут частыми, т.к. пока что единственным неуникальным эффектом является `Calls`
      - Можно впендюрить мапу внутрь `Calls`, тогда он будет уникальным. **Так и надо бы сделать**
  - Получается эдакий pipline-pattern - некто (`Combiner`) берет некоторый объект (`rhs`) и дает его первому чуваку (эффект из `lhs`). Каждый из чуваков знает, что с этим объектом делать (правило для комбинирования), и выдает некоторый новый объект (`rhs` модифицированный с учетом текущего `this`), который будет обрабатывать следующий чувак.
  - **Кажется, что это наиболее разумный вариант**

3. Потенциальное упрощение - если постулировать, что в правой части может быть не более одного эффекта каждого типа и обязать каждый тип комбинироваться с собой, выдавая 1 (функия типа `(EffectType).(other: EffectType) -> EffectType`). Тогда просто упрощаются сигнатуры функций и логика комбинирования, которую нужно реализовать в каждом типе.
  **В целом очень хорошая идея, и кажется, что это не ограничит нас уж слишком сильно**

  ** А вот и хренушки**.

  Комбинируем `{a -> b && Throws(...)} == {x -> y && Returns(...)}`, получаем `{a && x -> b && y && (результат комбинации Throws и Returns)}`, что уже однозначно будет чушью, во чтобы `Throws` и `Returns` не скомбинировались, ибо сайд-эффекты `y` **не выстрелят**

  Забить на это нельзя, т.к. у нас появилась неконсистетная запись, это ничем не вылечить.

## 20.02.2017

В чем причина проблемы с комбинированием `Throws`?

Причина в том, что у нас есть неявный notion последовательности вычислений.

**Вариант №1**

Можно сделать его явным с помощью пары дополнительных условий в эффект-схеме:

  ```
  {
    rhs yields Throws(e) -> Throws(e)
    !(rhs yields Throws) && (lhs yields Throws(e')) -> Throws(e')
    !(rhs yields Throws) && !(lhs yields Throws)
        && rhs == lhs -> Returns true
    !(rhs yields Throws) && !(lhs yields Throws)
        && rhs != lhs -> Returns false
  }
  ```

- Приведет к сильному разбуханию эффект схем
- Нужно вводить `yields` и продумывать, как он работает и комбинируется
- Зато будут простые правила комбинирования эффектов

**Вариант №2**

Забить и сделать трейдофф: усложнить правила комбинирования эффектов, позволив влиять эффекту на другие. Зато получатся эффекты схемы проще.

- Вариант кажется разумным, т.к. есть основания полагать, что эффект-схемы будут создаваться чаще, чем новые эффекты
- В плане перформанса нельзя однозначно сказать, что лучше, т.к. в одном случае будут жирнее эффект-схемы (больше времени на обработку), а в другом случае -- сложнее правила комбинирования (больше времени на комбинирование)

**NB**. Последовательность вычислений присутствует при вычислении любых аргументов функций и операторов. Т.е. проблема не только при вычислении `Equals`, но и `Is`, `Then` (турникет эффекта), аргументы вызова `foo(bar(x), baz(x))`.
Это означает, что:
  a. Всем комбинаторам придется приседать с этим последовательным исполнением.
  b. Придется вкорячивать какую-то лыжу для вызова аргументов.

> Еще внезапно понял(вспомнил), что пока что аргументом сайд-эффектов могут быть только всякие константы, в то время как конечно хочется писать что-то в духе `Returns(foo(x))`. Поэтому каждый сайд-эффект должен уметь как комбинироваться (т.е. вмердживаться в список эффектов), так и флэттится (т.е. проваливаться внутрь эффект-схемы)

> Еще внезапно понял, что конструкция типа `NOT(EffectSchema)` ~~это нечто вообще не понятное~~ ладно, более-менее понятное.
`NOT` инвертирует `Return` на клозах, которые успешно завершаются, и не изменяет все остальные (например, `Throws`)

Итого:

- Есть операторы (`Not, And, Equal, Is`). Они должны уметь комбайнится (флэттится) от своих аргументов. Процесс вычисления запускает `Combiner`
- Есть эффекты (`Throws`, `Returns`, `Calls`, etc.). Они должны уметь:
  1. Комбайниться (флэттится) от своих аргументов. Это использует `Combiner` в ходе рекурсивных вызовов в левой и правой части клоза.
  2. Вмердживаться в список эффектов. Тоже использует `Combiner` при комбинировании клоза, хотя бы одним из аргументов которого является схема.
- И есть еще интересный подкласс эффектов - `Outcome`, которые комбинируются хитрее из-за пресловутой последовательности вычислений. Именно из-за этих пацанов приходится делать `merge` со сложной семантикой: им нужно знать, какие сайд-эффекты выстрелили сначала, а какие - потом. Потому что когда у нас появляется некоторый не-`Returns` исход, то это нужно корректно обрабатывать (например, если первые сайдэффекты упали со Throws, то вторые вообще не выстрелили, а вот наоборот неправда)
- Идея: кажется, что с такой логикой мы закладываемся на то, что `merge` в интервейсе `Outcome` будет дергаться только и исключительно при flattening левой и правой части клоза. Не проще ли тогда эту логику перенести в то, как флэттится `Then`? (заодно сделав его полноценным оператором)
  - Это более стройно с точки зрения дизайна, т.к. особенность комбинации этих эффектов больше проистекает не из их сущности, а из того факта, что `Then` вносит последовательность вычислений
  - Тогда вроде даже можно сделать правила комбинирования эффектов снова простыми

## 22.02.2017

Короче, дизайн с логикой комбинирования исходов в `Then` не понравился радикально, выпиливаем и откатываемся к варианту с более общей сигнатурой комбинирования эффектов. А кстати какой?
  - Хочется написать вариант: `(left: List<Effect>) -> (right: List<Effect>) -> Effect`, но не получится, т.к. левый throws
    никак не сможет дать знать остальному пайп-лайну о том, что надо бы больше ничего не комбинировать
      - Варирант: тащить через pipeline какой-нибудь `holder`, в который эффекты могут дописывать инфу: например, какой-нибудь флажок `leftFailed`
      - Кто будет смотреть на этот флажок?
      - Если другие эффекты, то это увеличивает `coupling`
      - Если только он сам, то толку нет - другие эффекты все равно не узнают, что им надо комбинироваться.
  - Другой вариант: `(destination: List<Effect>) -> (right: List<Effect>) -> List<Effect>`. Изначально `destination = left`.
  В результате `combine` выдается новый `destination'`, который передается дальше в пайплайн. Эффекты, которые комбинируются только с собой, должны просто поискать себя в `destination` и в `right` и скомбинироваться. `Outcome` могут поискать себя, плюс еще и дропнуть лишние эффекты
    - **Все равно проблема!**. Если `Outcome` комбинируются последними, то в `destination` уже может накомбинироваться куча всяких других, а нам нужно как-то оставить только `left`
  - Поэтому единственный вариант: `(left: List<Effect>) -> (right: List<Effect>) -> (destination: MutableList<Effect>) -> ()`.
    `combine` мутирует `destination`, глядя на `left` и `right`
    - Для не-`Outcome` можно написать перегрузку с более простым типом, отражающим локальность комбинации (придется ввести отдельный класс эффектов для этого)
    - **Все равно проблема!**. Если `Ouctome` комбинируются первыми, то после них в `destination` накомбинируется всякая хрень
  - Поэтому пришлось вводить состояние пайплайна, которое тащится через `flags`

Еще всякие технические мелочи:
- Приходится передавать в `merge` оператор, чтобы было что положить в два скомбинированных `Returns`
- Приходится вкорячивать в `EffectsPipelineFlags` уродливое `veto()` (по сути способ пробросить `return` через уровень абстракции)

## 23-26.02.2017

Имплементация вышеуказанного редизайна, поиск баг + немного выходных

## 27.02.2017

2. Механизм опроса выведенной системы - WIP
  "Я стою внутри if-a, и я знаю, что вернулось true". Дай-ка мне какую-то data-flow инфо, т.е. какая-то доп. инфа про переменные контекста.
  Или он может сказать: "Я заню, что вернулась такая-то хрень из enum-чика, а ну-ка расскажи мне чего"
  Т.о., компилятор всегда опрашивает **в обратную сторону**

  Или вот выполнился колл, расскажи какие функции вызвались

  Или вот выполнился колл, расскажи, что он мог бросить,

  Или расскжи, что получилось, если вот этот колл закончился удачно

3. Reducer - извлекалка простых и интересных зависимостей - WIP
4. Call-by-name - WIP
5. Убрать `AND` в качестве джойнера эффектов, т.к. это путает и неверно с
   семантической точки зрения (в некоторых частях системы `AND` -- это бинарный
   логический оператор, а в некоторых -- просто связка). На самом деле, это `cons`,
   он же `::`, т.е. оператор, который джойнит какие-то хрени в список.
   Кстати, если сделать тип `NodeList<T>` с двумя наследниками `Cons(NodeList<T>)`
   и `Nil`, то это может здорово сгладить некоторые корявые углы (типа `effectsAsList()`,
   возвращения пустого списка, кастов, и т.д.)



### Механизм опроса готовой эффект схемы

Несколько реквестов:

Общий вид:
- "Я знаю, что этот вот колл результировал в `Outcome` такой-то, дай **инфу**" (нужно продумать, в какой форме эта инфа будет выдаваться)

Более частные:
- "Колл вернул `X`, дай **инфу**"
- "Колл успешно завершился, но я не знаю, как именно, дай **инфу**"
- "Колл упал с эксепшеном `E`, дай **инфу**"
- "Колл упал, но я не знаю, как именно, дай **инфу**"

Пока что можно, наверное, считать, что `EffectSystem` просто выдает некоторый `EsInfoHolder`, в котором компилятор будет разбираться сам как хочет (i.e.`EsInfoHolder` является `white-box` для компилятора, что, в общем-то, reasonable, т.к. это часть их общего интерфейса)

Что должно быть в `EsInfoHolder`?

- Мапа из переменных в их значение/тип
- Мапа из функций в их call-counter'ы

Как собирать такие штуки?
- Проходимся по всем клозам
- У каждого клоза берем `Outcome`
- Проверяем, следует ли наш `Outcome` из того, что написан.
  - Здесь происходит некоторая нетривиальная арифметика на значениях. Кажется, в компиляторе должны были написать где-то чето похожее.
- Разбираем все премисы и добавляем их в мапу
  - Здесь происходит нетривиальный разбор булевского выражения, если в нем есть `OR`. Пока что будем считать, что их нет.
  - Здесь происходит и очень нетривиальное объединение утверждений о переменных, если таковое понадобится.
    - При объединении нескольких `Is` вылазят `Intersection-types`
    - При объединении нескольких `Equal` вылазят множества возможных значений.
    - А еще на все это можно вешать отрицания, что делает эту арифметику еще более нетривиальной
      - `A ∩ B ∩ (¬C)` -- это может вычисляться в очень интересные штуки. С другой стороны,
        вычислять это не обязательно, а проверять на конформность легко (вроде?)
      - `x = {5, 4, ¬3}` -- тоже самое, вычислять в нечто разумное сложно, проверять
        на конформность вроде понятно как.
  - Т.е., идея выдавать компилятору мапу "переменная - тип" вряд ли жизнеспособна, т.к. иначе нельзя ничего объединять.
  - Будем для первого прототипа считать, что объединять не надо.


> NB.  `EsInfoHolder` ≠ некорректный `EsInfoHolder`. Первый выдается тогда, когда мы ничего толкового не можем ответить
> компилятору. Второй выдается тогда, когда компилятор спросил что-то, про что мы уверены, что этого никогда быть не может. Например, если он спросил про `Returns(unit)` в `assert(false)`.

Как реагировать, если нас спросили про infeasible Outcome?
И вообще, когда бывает, что мы можем выдать пустой `EsInfoHolder`?

Вообще, семантика `EsInfoHolder` такова, что он содержит информацию о том, какой
должен был быть контекст, чтобы выполнилось то, что нас спросили. Т.е. это список
ограничений на контекст, которые должны выполняться, чтобы все было ок.

Соответственно, пустой `EsInfoHolder` допустим, если такой `Outcome` выполняется
всегда, т.е. не накладывает никаких ограничений на `Context`

Тогда надо понять, какой вид должен иметь `EsInfoHolder`, чтобы сказать, что
такой `Outcome` не достигается никогда.
  - Можно просто добавить особое значение (видимо, по имени `null`)
  - Было желание еще как-то передавать выполняемый `codepath`, но потом понял, что таких
    может быть несколько, да и в целом есть сомнения, что компилятору это интересно.
    Будет интересно - сам спросит.

Важные вопросы:
- Очевидно, в связи с появлением отрицаний и, потенциально, пересечений, интерфейс
  между компилятором и системой не может быть ограничен до "скажи, какое значение у этой
  переменной если то-то и то-то". Как тогда этот интерфейс делать? Можно ли договориться
  с компилятором, что он будет спрашивать не вопросы в духе: "Какое значение может быть
  у этой переменной?" или еще что-то такое, а "Правда ли, что эта переменная может иметь
  значение 3?". Полезно ли это? - забить.
- Как лучше справиться с call-by-name?
- Что делать с intersection types? -- забить.



TODO:
- Аппроксиматор
- создать список того, до какого состояния аппроксимирует аппроксиматор
- `Is` -- отрефакторить в унарный оператор, с полем 'Type' и убрать соответственно `EsType` из иерархии `EsNode`
- Идея как бороться с call-by-name:
  - Добавить некоторую временную переменную, соответствующую каждому коллу


- Kotlin Bytecode -- сделать что-то подобное, только чтобы показывало эффект схемы
  - ShowKotlinBytecodeAction
  - Hello, Idea -- научиться выводить строчку кода и файл.
- Потом спросить как по Location добыть PSI
- Потом посмотреть на структуру CallChecker, поразмышлять
- Попробовать написать CallChecker, который пройдется по коллу
- Еще можно смотреть `DeprecatedCallChecker`, он полезный. И `InfixCallChecker`.
- NB. CallChecker запускаются списком из DEFAULT_CALL_CHECKERS



## 28.02.2017 -- 03.03.2017
Вкорячиваемся в компилятор

## 03.03.2017
Ок, кое как работает.

Things to address:

- Аппроксиматор + список конечного состояния
- ~~Refactor Is~~. **DONE**
- ~~Refactor `And` into `Cons` in list of side-effects (or maybe even use list or whatever)~~ **DONE**
- ~~Refactor repository~~ - **DONE**
- ~~Как транслировать встроенные функции типа ==, is, и т.д.?~~ **DONE**
  - Можно написать фейковые функции для них, и вкорячить в `EffectSchemaGenerator` отдельным костылем
    - На самом деле, `EffectSchema` вообще лучше бы доставать из какого-нибудь отдельного объекта, типа `EffectSchemaProvider`,
      т.к. это может быть весьма нетривиальный процесс, да и генератор к нему никакого отношения не имеет, по сути
  - Можно вкорячить эти штуки непосредственно в `CallTreeGenerator`
    - Здесь это выглядит логично, т.к. `CallTree` и должно быть тем буффером между конструкциями компилятора и конструкциями системы эффектов
    - Нужно будет вводить дополнительные ноды в `CallTree`-иерархию.
    - **Пожалуй, получше вариант**
- Придумать чето с call-by-name
- Придумать чето с return-values (чтобы можно было писать всякие утверждение про результаты коллов)
- Внимательно подумать про захваты переменных и скоупы. Пока что переменные сравниваются по имени-значению, что означает, что вероятность коллизии при обходе поддерева крайне высока (пример: `foo(5, foo(10))` -- надо понимать, что второй аргумент `foo` разный для разных коллов)
- ~~Refactor Outcome as independant part of clause (presumably, will make combining more clear)~~ **DONE**
- Какой-то объект для обозначения неизвестности.
  - Ладно, если он используется вместо `EsConstant`, например, в аргументе `Returns`
  - А вот что, если он используется вместо `Outcome`?
    - Можно ли его туда пихунить? - Технически, должен быть механизм для того, чтобы выразить подобные случаи, иначе нельзя будет вызывать неаннотированные методы
    - Что делать, если мы комбинируем `Unknown`? Ну он пожирает все другие `Outcome`, но при этом подчиняется обычным правилам последовательных вычислений - если слева `Throws`, то эффекты справа не стрельнут. Если слева `Unknown`, то все не так тривиально. Если под `Unknown` скрывается `Throws`, то сайдэффекты справа не должны стрельнуть, а иначе они стрельнут, просто `Returns` будет неизвестным.
    - **Безопасно считать, что `Unknown` всегда `Throws`**, хоть мы и теряем некоторую информацию. **Теоретически, эту информацию мы можем отыграть обратно, если притащим последовательные вычисления**.
- `castToSchema()` -- formalize, think carefully, prove that it's OK


## 06.03.2017

- Refactor Outcome as independant part of clause (presumably, will make combining more clear)
  - Проблема: когда раньше все эффекты валялись в куче, `Outcome` можно было извлечь обходом поддерева. Теперь же у любой структуры должен появится дополнительный аттрибут `Outcome`. Но он даже не у каждой должен быть (откуда, например, у `Is` может быть `Outcome`?).
  - Кажется, что `Outcome` может быть у всего, у чего вообще могут быть сайд-эффекты
  - Кажется, что пора бы заиметь некоторый notion чего-то, у чего могут быть сайд-эффекты. Например, `Term` очень похож на именно эту самую абстракцию, только недодуманную до конца.
  - Однако `Term` не может быть той самой абстракцией, т.к. у `EffectSchema` нет `Outcome`
  - *Идея*: `EffectSchema` -- не терм. Но любой терм можно преобразовать в эффект схему (ровно также, как конверсия `List<T> -> T` не очевидна, а вот `T -> List<T>` вполне тривиальна)
  - Т.е. `Term` это набор чего-то, у чего есть сайд-эффекты
  - Но это, на секундочку, `Imply` в наших теримнах
  - Значит, нужно просто отерафачить `Imply` в какой-нибудь `Clause` и выпилить его наследования от бинопа
    - Хотелось бы сделать нечто в духе: `data class Imply(val premise: EsNode, val effects: List<Effect>, val outcome: Outcome)`.
    - Проблема в том, что у `Imply` бывают некоторые очень неудобные промежуточные состояния в ходе вычислений, в то время как `effects, outcome` бывают только у плоского `Imply`
    - Так что придется реализовывать его как `data class Imply(val left: EsNode, val right: EsNode)` с доп. геттерами, которые будут возвращать nullable-значения
    - И тогда, в принципе, можно его по праву считать и `BinaryOperator`
**NB**. Осталось такое ощущение, что выпиливание `Outcome` в отдельную иерархию было зря-зря.

## 07.03.2017

Some more refactoring

## 09.03.2017

TODO:
- Аппроксиматор + список конечного состояния
- Придумать чето с call-by-name
- Придумать чето с return-values (чтобы можно было писать всякие утверждение про результаты коллов)
- ~~Внимательно подумать про захваты переменных и скоупы. Пока что переменные сравниваются по имени-значению, что означает, что вероятность коллизии при обходе поддерева крайне высока. **Возможно, переход на `DataFlowValue` решит это**~~
- Какой-то объект для обозначения неизвестности.
  - Считать, что он всегда завершается и это все, что мы о нем знаем
- `castToSchema()` -- formalize, think carefully, prove that it's OK


### Грамматика

start
effectSchema
  : clause { SEMI+ }
  ;


clause
  : expression "->" effectList
  ;

expression
  : binaryOperatorCall
  : unaryOperatorCall
  : isExpression
  : literalConstant
  : SimpleName
  ;

binaryOperatorCall
  : expression binaryOperator expression
  ;

unaryOperatorCall
  : unaryOperator expression
  ;

binaryOperator
  : "&&"
  : "||"
  : "=="
  ;

unaryOperator
  : "!"

isExpression
  : expression "is" type

type
  : SimpleName

literalConstant
  : "true" | "false"
  : IntegerLiteral
  : "\"" stringElement* "\""
  : "null"
  ;

stringElement
  : RegularStringPart | EscapeSequence
  ;

Digit : ["0".."9"];

IntegerLiteral
  : Digit (Digit | "_")*
  ;

RegularStringPart
  : <any character other than backslash, quote, $ or newline>
  ;

EscapeSequence
  : "\" <any character other than newline>


## 22.03.2017

Вопросы:
  - Хорошо ли создавать `DataFlowInfo` через `DelegatingDataFlowInfo`?
  - Нормально ли, что у `DelegatingDataFlowInfo` поле `parent` изначально выставляется в
    `null` и потом никогда не меняется?
  - Правильно ли я понимаю, что в котлиновском дата-флоу отсуствует понятия "значения" переменной (кроме как для enum-чиков)? Т.е. если система эффектов каким-то раком вывела, что такая-то переменная равна, например, 42, то в дата-флоу это никак не протащить?
  - Дизайновый вопрос. Вот у меня есть `Collector`, который в мапки собирает всякие пары типа переменная-тип, переменная-значение, переменная-другая переменная. А потом по этим мапкам хожу еще раз и делаю всякие апдейты. Может, проще коллектору отдать `DataFlowInfo` и пусть он сам на нем дергает всякие `equate`, `establishSubtyping` и т.д.?
  - На этапе анализа колла мы также можем понять, что запрашиваемый исход вообще никогда не исполняется. Нужно ли это как-то артикулировать?

## 29.03.2017

Принцип работы CFA:
- `ControlFlowProcessor` по `KtElement` умеет генерить `Pseudocode`. Он знает про `BindingTrace`.
- Для этого он создает `CFPVisitor`, который обходит котлиновское AST и по нему строит `Pseudocode`. Он знает про `BindingTrace`, т.к. он `inner`-класс у `ControlFlowProcessor`
- Непосредственно генерация кода инкапсулируется в `ControlFlowInstructionBuilder`, инстанс которго хранит `ControlFlowProcessor` и по мере надобности выдает `CFPVisitor`у. Этот чувак ничего не знает про `BindingTrace`
  - Там еще какая-то муть со стеком билдеров из `ControlFlowInstructionsGeneratorWorker`ов, но я не понял, зачем она нужна (параллелить? скоупы?)
- Именно `CFPVisitor` рулит тем, какие инструкции генерить, и какая идет за какой.
- Потом `Pseudocode` при вызове `Pseudocode.postProcess` занимается довольно механической работой, расставляя ребра на следующие элементы (учитывает всякие джампы и прочее).
- Для `CallInstruction` *не предусмотрено*, что ребро из него может вести куда-то, кроме следующей по списку инструкции.
- Поэтому для обработки, например, `TODO()` есть отдельная логика в `CFPVisitor.checkNothingType`, которая работает примерно так:
  - Нас просят сгенерить код для элемента
  - Мы генерим код
  - А потом еще чекаем, не является ли тип этого элемента, случаем, Nothing
  - И если является, то дополнительно эмиттим джамп в егог.

Соответствено, думаю, лучшим вариантом будет положить наш чек где-то рядом. Например, после `checkNothingType` делать еще `checkUnseccussfullCall` или как-то так.
Как вариант, можно запихнуть это в `checkNothingType` и переименовать метод в более общий, типа `checkInfeasibleInstruction` или как-то так.

Вопросы:
- ~~У меня есть `KtElement`, я хочу проверить, не является ли он `KtCallExpression`. Видел в `checkNothingType`, что там сначала проверяют на `KtExpression`, потом делают `deparenthesize`, и только потом проверяют на конкретные типы. Надо всегда так делать? -- Забить~~
- ~~Когда я анализирую `Call` внутри `CallResolver`а, у меня есть `ResolutionContext` и `TypeResolver`, и вообще все на свете. А вот когда я вычисляю эффекты в `KotlinEffectsToolWindow`, у меня есть только `BindingContext`, полученный из `Call.analyze()`. Как следствие, я не могу отрезольвить типы, которые написанны строкой в аннотации `@Effects`.~~
  - Можно взять через слайс LEXICAL_SCOPE
  - TypeResolver взять у REsolutionFacade через `getFrontendService`
- ~~И вообще, хотелось бы весь зоопарк в EsResolutionUtils как-то привести к одному знаменателю. `ResolutionContext` кое где все равно нужен, так что наверное надо научиться добывать его там, где его нет~~.

- Intersection types это ведь легальная конструкция? В том плане, что мы можем в одном месте узнать что какая-то переменная `is A`, а в другом -- `is B`, и это +- легально, т.к. может же быть класс, который наследуется и от `A` и от `B` (видимо нужно наложить условие, что они -- интерфейсы)
  - Можно и нужно вытаскивать через 2 DFI и and на них

TODO:
- ~~Пока что нет дальнейшего анализа летящего исключения в try-catch блоках~~ Да хер с ним
- ~~Анричбл код репортится куда-то странно~~ Да хер с ним

Принцип работы Initialization Analsys:
- Entry-point: `ControlFlowInformaionProvider.markUninitializedVariables()`
- Траверсятся все `PseudocodeVariablesData.variableInitializers`
  - `PseudocodeVariablesData` создается лениво, вызовом обычного конструктора.
  - `variableInitializers` создаются внутри `PresudocodeVariablesData` тоже лениво, вызовом `computeVariableInitializers()`
  - `computeVariableInitializers()` запускает обход псевдокода с помощью `PseudocodeVariableDataCollector`



`ControlStructureTYpingVisitor.visitIfExpression` - DFI для ифов
`PatternMatchingTYpingVisitor` - DFI для when

По поводу коллекций:
  - Параметры лямбды можно явно именовать
  - Ввести в язык явно оператор `at`, который делает сечение эффект схемы по передаваемому исходу, e.g. `at Returns(true)`
  - Ввести оператор `typeOf`, который работает на эффект схеме и выдает тип аргумента, e.g. `typeOf arg`


------------------------------------------

Вопросы:
- Есть ли смысл собирать информацию вида `x !is T`